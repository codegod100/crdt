var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
__name(createNotImplementedError, "createNotImplementedError");
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
__name(notImplemented, "notImplemented");
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
__name(notImplementedClass, "notImplementedClass");

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
var _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
var nodeTiming = {
  name: "node",
  entryType: "node",
  startTime: 0,
  duration: 0,
  nodeStart: 0,
  v8Start: 0,
  bootstrapComplete: 0,
  environment: 0,
  loopStart: 0,
  loopExit: 0,
  idleTime: 0,
  uvMetricsInfo: {
    loopCount: 0,
    events: 0,
    eventsWaiting: 0
  },
  detail: void 0,
  toJSON() {
    return this;
  }
};
var PerformanceEntry = class {
  static {
    __name(this, "PerformanceEntry");
  }
  __unenv__ = true;
  detail;
  entryType = "event";
  name;
  startTime;
  constructor(name, options2) {
    this.name = name;
    this.startTime = options2?.startTime || _performanceNow();
    this.detail = options2?.detail;
  }
  get duration() {
    return _performanceNow() - this.startTime;
  }
  toJSON() {
    return {
      name: this.name,
      entryType: this.entryType,
      startTime: this.startTime,
      duration: this.duration,
      detail: this.detail
    };
  }
};
var PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
  static {
    __name(this, "PerformanceMark");
  }
  entryType = "mark";
  constructor() {
    super(...arguments);
  }
  get duration() {
    return 0;
  }
};
var PerformanceMeasure = class extends PerformanceEntry {
  static {
    __name(this, "PerformanceMeasure");
  }
  entryType = "measure";
};
var PerformanceResourceTiming = class extends PerformanceEntry {
  static {
    __name(this, "PerformanceResourceTiming");
  }
  entryType = "resource";
  serverTiming = [];
  connectEnd = 0;
  connectStart = 0;
  decodedBodySize = 0;
  domainLookupEnd = 0;
  domainLookupStart = 0;
  encodedBodySize = 0;
  fetchStart = 0;
  initiatorType = "";
  name = "";
  nextHopProtocol = "";
  redirectEnd = 0;
  redirectStart = 0;
  requestStart = 0;
  responseEnd = 0;
  responseStart = 0;
  secureConnectionStart = 0;
  startTime = 0;
  transferSize = 0;
  workerStart = 0;
  responseStatus = 0;
};
var PerformanceObserverEntryList = class {
  static {
    __name(this, "PerformanceObserverEntryList");
  }
  __unenv__ = true;
  getEntries() {
    return [];
  }
  getEntriesByName(_name, _type) {
    return [];
  }
  getEntriesByType(type) {
    return [];
  }
};
var Performance = class {
  static {
    __name(this, "Performance");
  }
  __unenv__ = true;
  timeOrigin = _timeOrigin;
  eventCounts = /* @__PURE__ */ new Map();
  _entries = [];
  _resourceTimingBufferSize = 0;
  navigation = void 0;
  timing = void 0;
  timerify(_fn, _options) {
    throw createNotImplementedError("Performance.timerify");
  }
  get nodeTiming() {
    return nodeTiming;
  }
  eventLoopUtilization() {
    return {};
  }
  markResourceTiming() {
    return new PerformanceResourceTiming("");
  }
  onresourcetimingbufferfull = null;
  now() {
    if (this.timeOrigin === _timeOrigin) {
      return _performanceNow();
    }
    return Date.now() - this.timeOrigin;
  }
  clearMarks(markName) {
    this._entries = markName ? this._entries.filter((e3) => e3.name !== markName) : this._entries.filter((e3) => e3.entryType !== "mark");
  }
  clearMeasures(measureName) {
    this._entries = measureName ? this._entries.filter((e3) => e3.name !== measureName) : this._entries.filter((e3) => e3.entryType !== "measure");
  }
  clearResourceTimings() {
    this._entries = this._entries.filter((e3) => e3.entryType !== "resource" || e3.entryType !== "navigation");
  }
  getEntries() {
    return this._entries;
  }
  getEntriesByName(name, type) {
    return this._entries.filter((e3) => e3.name === name && (!type || e3.entryType === type));
  }
  getEntriesByType(type) {
    return this._entries.filter((e3) => e3.entryType === type);
  }
  mark(name, options2) {
    const entry = new PerformanceMark(name, options2);
    this._entries.push(entry);
    return entry;
  }
  measure(measureName, startOrMeasureOptions, endMark) {
    let start;
    let end;
    if (typeof startOrMeasureOptions === "string") {
      start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
      end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
    } else {
      start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
      end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
    }
    const entry = new PerformanceMeasure(measureName, {
      startTime: start,
      detail: {
        start,
        end
      }
    });
    this._entries.push(entry);
    return entry;
  }
  setResourceTimingBufferSize(maxSize) {
    this._resourceTimingBufferSize = maxSize;
  }
  addEventListener(type, listener, options2) {
    throw createNotImplementedError("Performance.addEventListener");
  }
  removeEventListener(type, listener, options2) {
    throw createNotImplementedError("Performance.removeEventListener");
  }
  dispatchEvent(event) {
    throw createNotImplementedError("Performance.dispatchEvent");
  }
  toJSON() {
    return this;
  }
};
var PerformanceObserver = class {
  static {
    __name(this, "PerformanceObserver");
  }
  __unenv__ = true;
  static supportedEntryTypes = [];
  _callback = null;
  constructor(callback) {
    this._callback = callback;
  }
  takeRecords() {
    return [];
  }
  disconnect() {
    throw createNotImplementedError("PerformanceObserver.disconnect");
  }
  observe(options2) {
    throw createNotImplementedError("PerformanceObserver.observe");
  }
  bind(fn) {
    return fn;
  }
  runInAsyncScope(fn, thisArg, ...args) {
    return fn.call(thisArg, ...args);
  }
  asyncId() {
    return 0;
  }
  triggerAsyncId() {
    return 0;
  }
  emitDestroy() {
    return this;
  }
};
var performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251008.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
globalThis.performance = performance2;
globalThis.Performance = Performance;
globalThis.PerformanceEntry = PerformanceEntry;
globalThis.PerformanceMark = PerformanceMark;
globalThis.PerformanceMeasure = PerformanceMeasure;
globalThis.PerformanceObserver = PerformanceObserver;
globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
globalThis.PerformanceResourceTiming = PerformanceResourceTiming;

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default = Object.assign(() => {
}, { __unenv__: true });

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/console.mjs
var _console = globalThis.console;
var _ignoreErrors = true;
var _stderr = new Writable();
var _stdout = new Writable();
var log = _console?.log ?? noop_default;
var info = _console?.info ?? log;
var trace = _console?.trace ?? info;
var debug = _console?.debug ?? log;
var table = _console?.table ?? log;
var error = _console?.error ?? log;
var warn = _console?.warn ?? error;
var createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
var clear = _console?.clear ?? noop_default;
var count = _console?.count ?? noop_default;
var countReset = _console?.countReset ?? noop_default;
var dir = _console?.dir ?? noop_default;
var dirxml = _console?.dirxml ?? noop_default;
var group = _console?.group ?? noop_default;
var groupEnd = _console?.groupEnd ?? noop_default;
var groupCollapsed = _console?.groupCollapsed ?? noop_default;
var profile = _console?.profile ?? noop_default;
var profileEnd = _console?.profileEnd ?? noop_default;
var time = _console?.time ?? noop_default;
var timeEnd = _console?.timeEnd ?? noop_default;
var timeLog = _console?.timeLog ?? noop_default;
var timeStamp = _console?.timeStamp ?? noop_default;
var Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
var _times = /* @__PURE__ */ new Map();
var _stdoutErrorHandler = noop_default;
var _stderrErrorHandler = noop_default;

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251008.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole = globalThis["console"];
var {
  assert,
  clear: clear2,
  // @ts-expect-error undocumented public API
  context,
  count: count2,
  countReset: countReset2,
  // @ts-expect-error undocumented public API
  createTask: createTask2,
  debug: debug2,
  dir: dir2,
  dirxml: dirxml2,
  error: error2,
  group: group2,
  groupCollapsed: groupCollapsed2,
  groupEnd: groupEnd2,
  info: info2,
  log: log2,
  profile: profile2,
  profileEnd: profileEnd2,
  table: table2,
  time: time2,
  timeEnd: timeEnd2,
  timeLog: timeLog2,
  timeStamp: timeStamp2,
  trace: trace2,
  warn: warn2
} = workerdConsole;
Object.assign(workerdConsole, {
  Console,
  _ignoreErrors,
  _stderr,
  _stderrErrorHandler,
  _stdout,
  _stdoutErrorHandler,
  _times
});
var console_default = workerdConsole;

// node_modules/.pnpm/wrangler@4.42.2_@cloudflare+workers-types@4.20251008.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
globalThis.console = console_default;

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
  const now = Date.now();
  const seconds = Math.trunc(now / 1e3);
  const nanos = now % 1e3 * 1e6;
  if (startTime) {
    let diffSeconds = seconds - startTime[0];
    let diffNanos = nanos - startTime[0];
    if (diffNanos < 0) {
      diffSeconds = diffSeconds - 1;
      diffNanos = 1e9 + diffNanos;
    }
    return [diffSeconds, diffNanos];
  }
  return [seconds, nanos];
}, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
  return BigInt(Date.now() * 1e6);
}, "bigint") });

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream = class {
  static {
    __name(this, "ReadStream");
  }
  fd;
  isRaw = false;
  isTTY = false;
  constructor(fd) {
    this.fd = fd;
  }
  setRawMode(mode) {
    this.isRaw = mode;
    return this;
  }
};

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream = class {
  static {
    __name(this, "WriteStream");
  }
  fd;
  columns = 80;
  rows = 24;
  isTTY = false;
  constructor(fd) {
    this.fd = fd;
  }
  clearLine(dir3, callback) {
    callback && callback();
    return false;
  }
  clearScreenDown(callback) {
    callback && callback();
    return false;
  }
  cursorTo(x, y, callback) {
    callback && typeof callback === "function" && callback();
    return false;
  }
  moveCursor(dx, dy, callback) {
    callback && callback();
    return false;
  }
  getColorDepth(env2) {
    return 1;
  }
  hasColors(count3, env2) {
    return false;
  }
  getWindowSize() {
    return [this.columns, this.rows];
  }
  write(str, encoding, cb) {
    if (str instanceof Uint8Array) {
      str = new TextDecoder().decode(str);
    }
    try {
      console.log(str);
    } catch {
    }
    cb && typeof cb === "function" && cb();
    return false;
  }
};

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION = "22.14.0";

// node_modules/.pnpm/unenv@2.0.0-rc.21/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
var Process = class _Process extends EventEmitter {
  static {
    __name(this, "Process");
  }
  env;
  hrtime;
  nextTick;
  constructor(impl) {
    super();
    this.env = impl.env;
    this.hrtime = impl.hrtime;
    this.nextTick = impl.nextTick;
    for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
      const value = this[prop];
      if (typeof value === "function") {
        this[prop] = value.bind(this);
      }
    }
  }
  // --- event emitter ---
  emitWarning(warning, type, code) {
    console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
  }
  emit(...args) {
    return super.emit(...args);
  }
  listeners(eventName) {
    return super.listeners(eventName);
  }
  // --- stdio (lazy initializers) ---
  #stdin;
  #stdout;
  #stderr;
  get stdin() {
    return this.#stdin ??= new ReadStream(0);
  }
  get stdout() {
    return this.#stdout ??= new WriteStream(1);
  }
  get stderr() {
    return this.#stderr ??= new WriteStream(2);
  }
  // --- cwd ---
  #cwd = "/";
  chdir(cwd2) {
    this.#cwd = cwd2;
  }
  cwd() {
    return this.#cwd;
  }
  // --- dummy props and getters ---
  arch = "";
  platform = "";
  argv = [];
  argv0 = "";
  execArgv = [];
  execPath = "";
  title = "";
  pid = 200;
  ppid = 100;
  get version() {
    return `v${NODE_VERSION}`;
  }
  get versions() {
    return { node: NODE_VERSION };
  }
  get allowedNodeEnvironmentFlags() {
    return /* @__PURE__ */ new Set();
  }
  get sourceMapsEnabled() {
    return false;
  }
  get debugPort() {
    return 0;
  }
  get throwDeprecation() {
    return false;
  }
  get traceDeprecation() {
    return false;
  }
  get features() {
    return {};
  }
  get release() {
    return {};
  }
  get connected() {
    return false;
  }
  get config() {
    return {};
  }
  get moduleLoadList() {
    return [];
  }
  constrainedMemory() {
    return 0;
  }
  availableMemory() {
    return 0;
  }
  uptime() {
    return 0;
  }
  resourceUsage() {
    return {};
  }
  // --- noop methods ---
  ref() {
  }
  unref() {
  }
  // --- unimplemented methods ---
  umask() {
    throw createNotImplementedError("process.umask");
  }
  getBuiltinModule() {
    return void 0;
  }
  getActiveResourcesInfo() {
    throw createNotImplementedError("process.getActiveResourcesInfo");
  }
  exit() {
    throw createNotImplementedError("process.exit");
  }
  reallyExit() {
    throw createNotImplementedError("process.reallyExit");
  }
  kill() {
    throw createNotImplementedError("process.kill");
  }
  abort() {
    throw createNotImplementedError("process.abort");
  }
  dlopen() {
    throw createNotImplementedError("process.dlopen");
  }
  setSourceMapsEnabled() {
    throw createNotImplementedError("process.setSourceMapsEnabled");
  }
  loadEnvFile() {
    throw createNotImplementedError("process.loadEnvFile");
  }
  disconnect() {
    throw createNotImplementedError("process.disconnect");
  }
  cpuUsage() {
    throw createNotImplementedError("process.cpuUsage");
  }
  setUncaughtExceptionCaptureCallback() {
    throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
  }
  hasUncaughtExceptionCaptureCallback() {
    throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
  }
  initgroups() {
    throw createNotImplementedError("process.initgroups");
  }
  openStdin() {
    throw createNotImplementedError("process.openStdin");
  }
  assert() {
    throw createNotImplementedError("process.assert");
  }
  binding() {
    throw createNotImplementedError("process.binding");
  }
  // --- attached interfaces ---
  permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
  report = {
    directory: "",
    filename: "",
    signal: "SIGUSR2",
    compact: false,
    reportOnFatalError: false,
    reportOnSignal: false,
    reportOnUncaughtException: false,
    getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
    writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
  };
  finalization = {
    register: /* @__PURE__ */ notImplemented("process.finalization.register"),
    unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
    registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
  };
  memoryUsage = Object.assign(() => ({
    arrayBuffers: 0,
    rss: 0,
    external: 0,
    heapTotal: 0,
    heapUsed: 0
  }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
  // --- undefined props ---
  mainModule = void 0;
  domain = void 0;
  // optional
  send = void 0;
  exitCode = void 0;
  channel = void 0;
  getegid = void 0;
  geteuid = void 0;
  getgid = void 0;
  getgroups = void 0;
  getuid = void 0;
  setegid = void 0;
  seteuid = void 0;
  setgid = void 0;
  setgroups = void 0;
  setuid = void 0;
  // internals
  _events = void 0;
  _eventsCount = void 0;
  _exiting = void 0;
  _maxListeners = void 0;
  _debugEnd = void 0;
  _debugProcess = void 0;
  _fatalException = void 0;
  _getActiveHandles = void 0;
  _getActiveRequests = void 0;
  _kill = void 0;
  _preload_modules = void 0;
  _rawDebug = void 0;
  _startProfilerIdleNotifier = void 0;
  _stopProfilerIdleNotifier = void 0;
  _tickCallback = void 0;
  _disconnect = void 0;
  _handleQueue = void 0;
  _pendingMessage = void 0;
  _channel = void 0;
  _send = void 0;
  _linkedBinding = void 0;
};

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.7_unenv@2.0.0-rc.21_workerd@1.20251008.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess = globalThis["process"];
var getBuiltinModule = globalProcess.getBuiltinModule;
var workerdProcess = getBuiltinModule("node:process");
var isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
var unenvProcess = new Process({
  env: globalProcess.env,
  // `hrtime` is only available from workerd process v2
  hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
  // `nextTick` is available from workerd process v1
  nextTick: workerdProcess.nextTick
});
var { exit, features, platform } = workerdProcess;
var {
  // Always implemented by workerd
  env,
  // Only implemented in workerd v2
  hrtime: hrtime3,
  // Always implemented by workerd
  nextTick
} = unenvProcess;
var {
  _channel,
  _disconnect,
  _events,
  _eventsCount,
  _handleQueue,
  _maxListeners,
  _pendingMessage,
  _send,
  assert: assert2,
  disconnect,
  mainModule
} = unenvProcess;
var {
  // @ts-expect-error `_debugEnd` is missing typings
  _debugEnd,
  // @ts-expect-error `_debugProcess` is missing typings
  _debugProcess,
  // @ts-expect-error `_exiting` is missing typings
  _exiting,
  // @ts-expect-error `_fatalException` is missing typings
  _fatalException,
  // @ts-expect-error `_getActiveHandles` is missing typings
  _getActiveHandles,
  // @ts-expect-error `_getActiveRequests` is missing typings
  _getActiveRequests,
  // @ts-expect-error `_kill` is missing typings
  _kill,
  // @ts-expect-error `_linkedBinding` is missing typings
  _linkedBinding,
  // @ts-expect-error `_preload_modules` is missing typings
  _preload_modules,
  // @ts-expect-error `_rawDebug` is missing typings
  _rawDebug,
  // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
  _startProfilerIdleNotifier,
  // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
  _stopProfilerIdleNotifier,
  // @ts-expect-error `_tickCallback` is missing typings
  _tickCallback,
  abort,
  addListener,
  allowedNodeEnvironmentFlags,
  arch,
  argv,
  argv0,
  availableMemory,
  // @ts-expect-error `binding` is missing typings
  binding,
  channel,
  chdir,
  config,
  connected,
  constrainedMemory,
  cpuUsage,
  cwd,
  debugPort,
  dlopen,
  // @ts-expect-error `domain` is missing typings
  domain,
  emit,
  emitWarning,
  eventNames,
  execArgv,
  execPath,
  exitCode,
  finalization,
  getActiveResourcesInfo,
  getegid,
  geteuid,
  getgid,
  getgroups,
  getMaxListeners,
  getuid,
  hasUncaughtExceptionCaptureCallback,
  // @ts-expect-error `initgroups` is missing typings
  initgroups,
  kill,
  listenerCount,
  listeners,
  loadEnvFile,
  memoryUsage,
  // @ts-expect-error `moduleLoadList` is missing typings
  moduleLoadList,
  off,
  on,
  once,
  // @ts-expect-error `openStdin` is missing typings
  openStdin,
  permission,
  pid,
  ppid,
  prependListener,
  prependOnceListener,
  rawListeners,
  // @ts-expect-error `reallyExit` is missing typings
  reallyExit,
  ref,
  release,
  removeAllListeners,
  removeListener,
  report,
  resourceUsage,
  send,
  setegid,
  seteuid,
  setgid,
  setgroups,
  setMaxListeners,
  setSourceMapsEnabled,
  setuid,
  setUncaughtExceptionCaptureCallback,
  sourceMapsEnabled,
  stderr,
  stdin,
  stdout,
  throwDeprecation,
  title,
  traceDeprecation,
  umask,
  unref,
  uptime,
  version,
  versions
} = isWorkerdProcessV2 ? workerdProcess : unenvProcess;
var _process = {
  abort,
  addListener,
  allowedNodeEnvironmentFlags,
  hasUncaughtExceptionCaptureCallback,
  setUncaughtExceptionCaptureCallback,
  loadEnvFile,
  sourceMapsEnabled,
  arch,
  argv,
  argv0,
  chdir,
  config,
  connected,
  constrainedMemory,
  availableMemory,
  cpuUsage,
  cwd,
  debugPort,
  dlopen,
  disconnect,
  emit,
  emitWarning,
  env,
  eventNames,
  execArgv,
  execPath,
  exit,
  finalization,
  features,
  getBuiltinModule,
  getActiveResourcesInfo,
  getMaxListeners,
  hrtime: hrtime3,
  kill,
  listeners,
  listenerCount,
  memoryUsage,
  nextTick,
  on,
  off,
  once,
  pid,
  platform,
  ppid,
  prependListener,
  prependOnceListener,
  rawListeners,
  release,
  removeAllListeners,
  removeListener,
  report,
  resourceUsage,
  setMaxListeners,
  setSourceMapsEnabled,
  stderr,
  stdin,
  stdout,
  title,
  throwDeprecation,
  traceDeprecation,
  umask,
  uptime,
  version,
  versions,
  // @ts-expect-error old API
  domain,
  initgroups,
  moduleLoadList,
  reallyExit,
  openStdin,
  assert: assert2,
  binding,
  send,
  exitCode,
  channel,
  getegid,
  geteuid,
  getgid,
  getgroups,
  getuid,
  setegid,
  seteuid,
  setgid,
  setgroups,
  setuid,
  permission,
  mainModule,
  _events,
  _eventsCount,
  _exiting,
  _maxListeners,
  _debugEnd,
  _debugProcess,
  _fatalException,
  _getActiveHandles,
  _getActiveRequests,
  _kill,
  _preload_modules,
  _rawDebug,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  _tickCallback,
  _disconnect,
  _handleQueue,
  _pendingMessage,
  _channel,
  _send,
  _linkedBinding
};
var process_default = _process;

// node_modules/.pnpm/wrangler@4.42.2_@cloudflare+workers-types@4.20251008.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
globalThis.process = process_default;

// .svelte-kit/cloudflare/_worker.js
var __defProp2 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __export = /* @__PURE__ */ __name((target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
}, "__export");
var init_remote_functions = __esm({
  "node_modules/.pnpm/@sveltejs+kit@2.46.4_@sveltejs+vite-plugin-svelte@4.0.4_svelte@5.39.11_vite@5.4.20_@typ_9b1fa9597efbdcd21e9f473a7b772c8e/node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js"() {
  }
});
var HttpError;
var Redirect;
var SvelteKitError;
var ActionFailure;
var init_internal = __esm({
  "node_modules/.pnpm/@sveltejs+kit@2.46.4_@sveltejs+vite-plugin-svelte@4.0.4_svelte@5.39.11_vite@5.4.20_@typ_9b1fa9597efbdcd21e9f473a7b772c8e/node_modules/@sveltejs/kit/src/exports/internal/index.js"() {
    init_remote_functions();
    HttpError = class {
      static {
        __name(this, "HttpError");
      }
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      static {
        __name(this, "Redirect");
      }
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      static {
        __name(this, "SvelteKitError");
      }
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      static {
        __name(this, "ActionFailure");
      }
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
  }
});
var IN_WEBCONTAINER;
var init_constants = __esm({
  "node_modules/.pnpm/@sveltejs+kit@2.46.4_@sveltejs+vite-plugin-svelte@4.0.4_svelte@5.39.11_vite@5.4.20_@typ_9b1fa9597efbdcd21e9f473a7b772c8e/node_modules/@sveltejs/kit/src/runtime/server/constants.js"() {
    IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;
  }
});
function with_request_store(store, fn) {
  try {
    sync_store = store;
    return als ? als.run(store, fn) : fn();
  } finally {
    if (!IN_WEBCONTAINER) {
      sync_store = null;
    }
  }
}
__name(with_request_store, "with_request_store");
var sync_store;
var als;
var init_event = __esm({
  "node_modules/.pnpm/@sveltejs+kit@2.46.4_@sveltejs+vite-plugin-svelte@4.0.4_svelte@5.39.11_vite@5.4.20_@typ_9b1fa9597efbdcd21e9f473a7b772c8e/node_modules/@sveltejs/kit/src/exports/internal/event.js"() {
    init_constants();
    sync_store = null;
    import("node:async_hooks").then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
    });
  }
});
function merge_tracing(event_like, current2) {
  return {
    ...event_like,
    tracing: {
      ...event_like.tracing,
      current: current2
    }
  };
}
__name(merge_tracing, "merge_tracing");
var init_server = __esm({
  "node_modules/.pnpm/@sveltejs+kit@2.46.4_@sveltejs+vite-plugin-svelte@4.0.4_svelte@5.39.11_vite@5.4.20_@typ_9b1fa9597efbdcd21e9f473a7b772c8e/node_modules/@sveltejs/kit/src/exports/internal/server.js"() {
    init_event();
  }
});
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  let i = from_parts.length;
  while (i--) from_parts[i] = "..";
  return from_parts.concat(to_parts).join("/");
}
__name(get_relative_path, "get_relative_path");
function base64_encode(bytes) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(bytes).toString("base64");
  }
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
__name(base64_encode, "base64_encode");
function base64_decode(encoded) {
  if (globalThis.Buffer) {
    const buffer = globalThis.Buffer.from(encoded, "base64");
    return new Uint8Array(buffer);
  }
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
__name(base64_decode, "base64_decode");
var text_encoder2;
var text_decoder2;
var init_utils = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    text_encoder2 = new TextEncoder();
    text_decoder2 = new TextDecoder();
  }
});
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
__name(run_all, "run_all");
function deferred() {
  var resolve2;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
__name(deferred, "deferred");
var is_array;
var index_of;
var array_from;
var define_property;
var get_descriptor;
var object_prototype;
var array_prototype;
var get_prototype_of;
var is_extensible;
var noop;
var init_utils2 = __esm({
  ".svelte-kit/output/server/chunks/utils2.js"() {
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
  }
});
function equals(value) {
  return value === this.v;
}
__name(equals, "equals");
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
__name(safe_not_equal, "safe_not_equal");
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
__name(safe_equals, "safe_equals");
var init_equality = __esm({
  ".svelte-kit/output/server/chunks/equality.js"() {
  }
});
function resolve(base2, path) {
  if (path[0] === "/" && path[1] === "/") return path;
  let url = new URL(base2, internal);
  url = new URL(path, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
__name(resolve, "resolve");
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore") return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
__name(normalize_path, "normalize_path");
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
__name(decode_pathname, "decode_pathname");
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
__name(decode_params, "decode_params");
function make_trackable(url, callback, search_params_callback, allow_hash = false) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  const tracked_url_properties = ["href", "pathname", "search", "toString", "toJSON"];
  if (allow_hash) tracked_url_properties.push("hash");
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
    tracked.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url.searchParams, opts);
    };
  }
  if (!allow_hash) {
    disable_hash(tracked);
  }
  return tracked;
}
__name(make_trackable, "make_trackable");
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead"
      );
    }
  });
}
__name(disable_hash, "disable_hash");
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
__name(disable_search, "disable_search");
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
__name(allow_nodejs_console_log, "allow_nodejs_console_log");
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
__name(readable, "readable");
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set2, "set2");
  function update(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  __name(update, "update");
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update) || noop;
    }
    run(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set2, update, subscribe };
}
__name(writable, "writable");
function validator(expected) {
  function validate(module, file) {
    if (!module) return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2)) continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  __name(validate, "validate");
  return validate;
}
__name(validator, "validator");
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
__name(hint_for_supported_files, "hint_for_supported_files");
var internal;
var subscriber_queue;
var valid_layout_exports;
var valid_page_exports;
var valid_layout_server_exports;
var valid_page_server_exports;
var valid_server_exports;
var validate_layout_exports;
var validate_page_exports;
var validate_layout_server_exports;
var validate_page_server_exports;
var validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    init_utils2();
    init_equality();
    internal = new URL("sveltekit-internal://");
    subscriber_queue = [];
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});
function lifecycle_outside_component(name) {
  {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
__name(lifecycle_outside_component, "lifecycle_outside_component");
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern2.test(str)) {
    const i = pattern2.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
__name(escape_html, "escape_html");
function set_ssr_context(v2) {
  ssr_context = v2;
}
__name(set_ssr_context, "set_ssr_context");
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
__name(getContext, "getContext");
function setContext(key2, context22) {
  get_or_init_context_map().set(key2, context22);
  return context22;
}
__name(setContext, "setContext");
function get_or_init_context_map(name) {
  if (ssr_context === null) {
    lifecycle_outside_component();
  }
  return ssr_context.c ??= new Map(get_parent_context(ssr_context) || void 0);
}
__name(get_or_init_context_map, "get_or_init_context_map");
function push(fn) {
  ssr_context = { p: ssr_context, c: null, r: null };
}
__name(push, "push");
function pop() {
  ssr_context = /** @type {SSRContext} */
  ssr_context.p;
}
__name(pop, "pop");
function get_parent_context(ssr_context2) {
  let parent = ssr_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
__name(get_parent_context, "get_parent_context");
var ATTR_REGEX;
var CONTENT_REGEX;
var ssr_context;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    ssr_context = null;
  }
});
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
__name(is_boolean_attribute, "is_boolean_attribute");
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
__name(is_passive_event, "is_passive_event");
function r(e3) {
  var t2, f, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o2 = e3.length;
    for (t2 = 0; t2 < o2; t2++) e3[t2] && (f = r(e3[t2])) && (n2 && (n2 += " "), n2 += f);
  } else for (f in e3) e3[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
__name(r, "r");
function clsx$1() {
  for (var e3, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++) (e3 = arguments[f]) && (t2 = r(e3)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(clsx$1, "clsx$1");
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
__name(attr, "attr");
function clsx(value) {
  if (typeof value === "object") {
    return clsx$1(value);
  } else {
    return value ?? "";
  }
}
__name(clsx, "clsx");
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
__name(to_class, "to_class");
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
__name(append_styles, "append_styles");
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
__name(to_css_name, "to_css_name");
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c2 = value[i];
        if (in_comment) {
          if (c2 === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c2) {
            in_str = false;
          }
        } else if (c2 === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c2 === '"' || c2 === "'") {
          in_str = c2;
        } else if (c2 === "(") {
          in_apo++;
        } else if (c2 === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c2 === ":" && name_index === -1) {
            name_index = i;
          } else if (c2 === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c2 !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
__name(to_style, "to_style");
function abort2() {
  controller?.abort(STALE_REACTION);
  controller = null;
}
__name(abort2, "abort");
function await_invalid() {
  const error22 = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  error22.name = "Svelte error";
  throw error22;
}
__name(await_invalid, "await_invalid");
function experimental_async_ssr() {
  {
    console.warn(`https://svelte.dev/e/experimental_async_ssr`);
  }
}
__name(experimental_async_ssr, "experimental_async_ssr");
function render(component4, options2 = {}) {
  return Renderer.render(
    /** @type {Component<Props>} */
    component4,
    options2
  );
}
__name(render, "render");
function attributes(attrs, css_hash, classes, styles, flags2 = 0) {
  if (styles) {
    attrs.style = to_style(attrs.style, styles);
  }
  if (attrs.class) {
    attrs.class = clsx(attrs.class);
  }
  if (css_hash || classes) {
    attrs.class = to_class(attrs.class, css_hash, classes);
  }
  let attr_str = "";
  let name;
  const is_html = (flags2 & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags2 & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  const is_input = (flags2 & ELEMENT_IS_INPUT) !== 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    var value = attrs[name];
    if (lowercase) {
      name = name.toLowerCase();
    }
    if (is_input) {
      if (name === "defaultvalue" || name === "defaultchecked") {
        name = name === "defaultvalue" ? "value" : "checked";
        if (attrs[name]) continue;
      }
    }
    attr_str += attr(name, value, is_html && is_boolean_attribute(name));
  }
  return attr_str;
}
__name(attributes, "attributes");
function attr_class(value, hash2, directives) {
  var result = to_class(value, hash2, directives);
  return result ? ` class="${escape_html(result, true)}"` : "";
}
__name(attr_class, "attr_class");
function slot(renderer, $$props, name, slot_props, fallback_fn) {
  var slot_fn = $$props.$$slots?.[name];
  if (slot_fn === true) {
    slot_fn = $$props["children"];
  }
  if (slot_fn !== void 0) {
    slot_fn(renderer, slot_props);
  }
}
__name(slot, "slot");
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
__name(ensure_array_like, "ensure_array_like");
var DERIVED;
var EFFECT;
var RENDER_EFFECT;
var BLOCK_EFFECT;
var BRANCH_EFFECT;
var ROOT_EFFECT;
var BOUNDARY_EFFECT;
var UNOWNED;
var DISCONNECTED;
var CLEAN;
var DIRTY;
var MAYBE_DIRTY;
var INERT;
var DESTROYED;
var EFFECT_RAN;
var EFFECT_TRANSPARENT;
var INSPECT_EFFECT;
var HEAD_EFFECT;
var EFFECT_PRESERVED;
var USER_EFFECT;
var REACTION_IS_UPDATING;
var ASYNC;
var ERROR_VALUE;
var STATE_SYMBOL;
var LEGACY_PROPS;
var STALE_REACTION;
var COMMENT_NODE;
var HYDRATION_START;
var HYDRATION_START_ELSE;
var HYDRATION_END;
var HYDRATION_ERROR;
var ELEMENT_IS_NAMESPACED;
var ELEMENT_PRESERVE_ATTRIBUTE_CASE;
var ELEMENT_IS_INPUT;
var UNINITIALIZED;
var DOM_BOOLEAN_ATTRIBUTES;
var PASSIVE_EVENTS;
var replacements;
var whitespace;
var BLOCK_OPEN;
var BLOCK_CLOSE;
var controller;
var Renderer;
var SSRState;
var INVALID_ATTR_NAME_CHAR_REGEX;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_context();
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    UNOWNED = 1 << 8;
    DISCONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    INSPECT_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol("$state");
    LEGACY_PROPS = Symbol("legacy props");
    STALE_REACTION = new class StaleReactionError extends Error {
      static {
        __name(this, "StaleReactionError");
      }
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    COMMENT_NODE = 8;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    controller = null;
    Renderer = class _Renderer {
      static {
        __name(this, "_Renderer");
      }
      /**
       * The contents of the renderer.
       * @type {RendererItem[]}
       */
      #out = [];
      /**
       * Any `onDestroy` callbacks registered during execution of this renderer.
       * @type {(() => void)[] | undefined}
       */
      #on_destroy = void 0;
      /**
       * Whether this renderer is a component body.
       * @type {boolean}
       */
      #is_component_body = false;
      /**
       * The type of string content that this renderer is accumulating.
       * @type {RendererType}
       */
      type;
      /** @type {Renderer | undefined} */
      #parent;
      /**
       * Asynchronous work associated with this renderer
       * @type {Promise<void> | undefined}
       */
      promise = void 0;
      /**
       * State which is associated with the content tree as a whole.
       * It will be re-exposed, uncopied, on all children.
       * @type {SSRState}
       * @readonly
       */
      global;
      /**
       * State that is local to the branch it is declared in.
       * It will be shallow-copied to all children.
       *
       * @type {{ select_value: string | undefined }}
       */
      local;
      /**
       * @param {SSRState} global
       * @param {Renderer | undefined} [parent]
       */
      constructor(global2, parent) {
        this.#parent = parent;
        this.global = global2;
        this.local = parent ? { ...parent.local } : { select_value: void 0 };
        this.type = parent ? parent.type : "body";
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      head(fn) {
        const head = new _Renderer(this.global, this);
        head.type = "head";
        this.#out.push(head);
        head.child(fn);
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      async(fn) {
        this.#out.push(BLOCK_OPEN);
        this.child(fn);
        this.#out.push(BLOCK_CLOSE);
      }
      /**
       * Create a child renderer. The child renderer inherits the state from the parent,
       * but has its own content.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       */
      child(fn) {
        const child = new _Renderer(this.global, this);
        this.#out.push(child);
        const parent = ssr_context;
        set_ssr_context({
          ...ssr_context,
          p: parent,
          c: null,
          r: child
        });
        const result = fn(child);
        set_ssr_context(parent);
        if (result instanceof Promise) {
          if (child.global.mode === "sync") {
            await_invalid();
          }
          result.catch(() => {
          });
          child.promise = result;
        }
        return child;
      }
      /**
       * Create a component renderer. The component renderer inherits the state from the parent,
       * but has its own content. It is treated as an ordering boundary for ondestroy callbacks.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       * @param {Function} [component_fn]
       * @returns {void}
       */
      component(fn, component_fn) {
        push();
        const child = this.child(fn);
        child.#is_component_body = true;
        pop();
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {(renderer: Renderer) => void} fn
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       * @returns {void}
       */
      select(attrs, fn, css_hash, classes, styles, flags2) {
        const { value, ...select_attrs } = attrs;
        this.push(`<select${attributes(select_attrs, css_hash, classes, styles, flags2)}>`);
        this.child((renderer) => {
          renderer.local.select_value = value;
          fn(renderer);
        });
        this.push("</select>");
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {string | number | boolean | ((renderer: Renderer) => void)} body
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       */
      option(attrs, body2, css_hash, classes, styles, flags2) {
        this.#out.push(`<option${attributes(attrs, css_hash, classes, styles, flags2)}`);
        const close = /* @__PURE__ */ __name((renderer, value, { head, body: body22 }) => {
          if ("value" in attrs) {
            value = attrs.value;
          }
          if (value === this.local.select_value) {
            renderer.#out.push(" selected");
          }
          renderer.#out.push(`>${body22}</option>`);
          if (head) {
            renderer.head((child) => child.push(head));
          }
        }, "close");
        if (typeof body2 === "function") {
          this.child((renderer) => {
            const r23 = new _Renderer(this.global, this);
            body2(r23);
            if (this.global.mode === "async") {
              return r23.#collect_content_async().then((content) => {
                close(renderer, content.body.replaceAll("<!---->", ""), content);
              });
            } else {
              const content = r23.#collect_content();
              close(renderer, content.body.replaceAll("<!---->", ""), content);
            }
          });
        } else {
          close(this, body2, { body: body2 });
        }
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      title(fn) {
        const path = this.get_path();
        const close = /* @__PURE__ */ __name((head) => {
          this.global.set_title(head, path);
        }, "close");
        this.child((renderer) => {
          const r23 = new _Renderer(renderer.global, renderer);
          fn(r23);
          if (renderer.global.mode === "async") {
            return r23.#collect_content_async().then((content) => {
              close(content.head);
            });
          } else {
            const content = r23.#collect_content();
            close(content.head);
          }
        });
      }
      /**
       * @param {string | (() => Promise<string>)} content
       */
      push(content) {
        if (typeof content === "function") {
          this.child(async (renderer) => renderer.push(await content()));
        } else {
          this.#out.push(content);
        }
      }
      /**
       * @param {() => void} fn
       */
      on_destroy(fn) {
        (this.#on_destroy ??= []).push(fn);
      }
      /**
       * @returns {number[]}
       */
      get_path() {
        return this.#parent ? [...this.#parent.get_path(), this.#parent.#out.indexOf(this)] : [];
      }
      /**
       * @deprecated this is needed for legacy component bindings
       */
      copy() {
        const copy = new _Renderer(this.global, this.#parent);
        copy.#out = this.#out.map((item) => item instanceof _Renderer ? item.copy() : item);
        copy.promise = this.promise;
        return copy;
      }
      /**
       * @param {Renderer} other
       * @deprecated this is needed for legacy component bindings
       */
      subsume(other) {
        if (this.global.mode !== other.global.mode) {
          throw new Error(
            "invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!"
          );
        }
        this.local = other.local;
        this.#out = other.#out.map((item) => {
          if (item instanceof _Renderer) {
            item.subsume(item);
          }
          return item;
        });
        this.promise = other.promise;
        this.type = other.type;
      }
      get length() {
        return this.#out.length;
      }
      /**
       * Only available on the server and when compiling with the `server` option.
       * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]
       * @returns {RenderOutput}
       */
      static render(component4, options2 = {}) {
        let sync;
        const result = (
          /** @type {RenderOutput} */
          {}
        );
        Object.defineProperties(result, {
          html: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component4, options2)).body;
            }, "get")
          },
          head: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component4, options2)).head;
            }, "get")
          },
          body: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component4, options2)).body;
            }, "get")
          },
          then: {
            value: (
              /**
               * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
               *
               * @template TResult1
               * @template [TResult2=never]
               * @param { (value: SyncRenderOutput) => TResult1 } onfulfilled
               * @param { (reason: unknown) => TResult2 } onrejected
               */
              /* @__PURE__ */ __name((onfulfilled, onrejected) => {
                {
                  experimental_async_ssr();
                  const result2 = sync ??= _Renderer.#render(component4, options2);
                  const user_result = onfulfilled({
                    head: result2.head,
                    body: result2.body,
                    html: result2.body
                  });
                  return Promise.resolve(user_result);
                }
              }, "value")
            )
          }
        });
        return result;
      }
      /**
       * Collect all of the `onDestroy` callbacks regsitered during rendering. In an async context, this is only safe to call
       * after awaiting `collect_async`.
       *
       * Child renderers are "porous" and don't affect execution order, but component body renderers
       * create ordering boundaries. Within a renderer, callbacks run in order until hitting a component boundary.
       * @returns {Iterable<() => void>}
       */
      *#collect_on_destroy() {
        for (const component4 of this.#traverse_components()) {
          yield* component4.#collect_ondestroy();
        }
      }
      /**
       * Performs a depth-first search of renderers, yielding the deepest components first, then additional components as we backtrack up the tree.
       * @returns {Iterable<Renderer>}
       */
      *#traverse_components() {
        for (const child of this.#out) {
          if (typeof child !== "string") {
            yield* child.#traverse_components();
          }
        }
        if (this.#is_component_body) {
          yield this;
        }
      }
      /**
       * @returns {Iterable<() => void>}
       */
      *#collect_ondestroy() {
        if (this.#on_destroy) {
          for (const fn of this.#on_destroy) {
            yield fn;
          }
        }
        for (const child of this.#out) {
          if (child instanceof _Renderer && !child.#is_component_body) {
            yield* child.#collect_ondestroy();
          }
        }
      }
      /**
       * Render a component. Throws if any of the children are performing asynchronous work.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {AccumulatedContent}
       */
      static #render(component4, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("sync", component4, options2);
          const content = renderer.#collect_content();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort2();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Render a component.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Promise<AccumulatedContent>}
       */
      static async #render_async(component4, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("async", component4, options2);
          const content = await renderer.#collect_content_async();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort2();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Collect all of the code from the `out` array and return it as a string, or a promise resolving to a string.
       * @param {AccumulatedContent} content
       * @returns {AccumulatedContent}
       */
      #collect_content(content = { head: "", body: "" }) {
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            item.#collect_content(content);
          }
        }
        return content;
      }
      /**
       * Collect all of the code from the `out` array and return it as a string.
       * @param {AccumulatedContent} content
       * @returns {Promise<AccumulatedContent>}
       */
      async #collect_content_async(content = { head: "", body: "" }) {
        await this.promise;
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            await item.#collect_content_async(content);
          }
        }
        return content;
      }
      /**
       * @template {Record<string, any>} Props
       * @param {'sync' | 'async'} mode
       * @param {import('svelte').Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Renderer}
       */
      static #open_render(mode, component4, options2) {
        const renderer = new _Renderer(
          new SSRState(mode, options2.idPrefix ? options2.idPrefix + "-" : "")
        );
        renderer.push(BLOCK_OPEN);
        if (options2.context) {
          push();
          ssr_context.c = options2.context;
          ssr_context.r = renderer;
        }
        component4(renderer, options2.props ?? {});
        if (options2.context) {
          pop();
        }
        renderer.push(BLOCK_CLOSE);
        return renderer;
      }
      /**
       * @param {AccumulatedContent} content
       * @param {Renderer} renderer
       */
      static #close_render(content, renderer) {
        for (const cleanup of renderer.#collect_on_destroy()) {
          cleanup();
        }
        let head = content.head + renderer.global.get_title();
        let body2 = content.body;
        for (const { hash: hash2, code } of renderer.global.css) {
          head += `<style id="${hash2}">${code}</style>`;
        }
        return {
          head,
          body: body2
        };
      }
    };
    SSRState = class {
      static {
        __name(this, "SSRState");
      }
      /** @readonly @type {'sync' | 'async'} */
      mode;
      /** @readonly @type {() => string} */
      uid;
      /** @readonly @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      /** @type {{ path: number[], value: string }} */
      #title = { path: [], value: "" };
      /**
       * @param {'sync' | 'async'} mode
       * @param {string} [id_prefix]
       */
      constructor(mode, id_prefix = "") {
        this.mode = mode;
        let uid = 1;
        this.uid = () => `${id_prefix}s${uid++}`;
      }
      get_title() {
        return this.#title.value;
      }
      /**
       * Performs a depth-first (lexicographic) comparison using the path. Rejects sets
       * from earlier than or equal to the current value.
       * @param {string} value
       * @param {number[]} path
       */
      set_title(value, path) {
        const current2 = this.#title.path;
        let i = 0;
        let l = Math.min(path.length, current2.length);
        while (i < l && path[i] === current2[i]) i += 1;
        if (path[i] === void 0) return;
        if (current2[i] === void 0 || path[i] > current2[i]) {
          this.#title.path = path;
          this.#title.value = value;
        }
      }
    };
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: /* @__PURE__ */ __name(() => handle, "handle")
});
var SECURITY_HEADERS;
var SECURITY_HEADER_ENTRIES;
var applySecurityHeaders;
var rewrapResponse;
var handle;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    SECURITY_HEADERS = {
      "Cross-Origin-Opener-Policy": "same-origin",
      "Cross-Origin-Embedder-Policy": "require-corp",
      "Cross-Origin-Resource-Policy": "same-origin",
      "Origin-Agent-Cluster": "?1"
    };
    SECURITY_HEADER_ENTRIES = Object.entries(SECURITY_HEADERS);
    applySecurityHeaders = /* @__PURE__ */ __name((headers2) => {
      for (const [header, value] of SECURITY_HEADER_ENTRIES) {
        headers2.set(header, value);
      }
    }, "applySecurityHeaders");
    rewrapResponse = /* @__PURE__ */ __name((response) => {
      const cloned = response.clone();
      const headers2 = new Headers(cloned.headers);
      applySecurityHeaders(headers2);
      return new Response(cloned.body, {
        status: cloned.status,
        statusText: cloned.statusText,
        headers: headers2
      });
    }, "rewrapResponse");
    handle = /* @__PURE__ */ __name(async ({ event, resolve: resolve2 }) => {
      const response = await resolve2(event, {
        filterSerializedResponseHeaders: /* @__PURE__ */ __name((name) => name === "content-type", "filterSerializedResponseHeaders")
      });
      return rewrapResponse(response);
    }, "handle");
  }
});
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: /* @__PURE__ */ __name(() => _layout, "default")
});
function _layout($$renderer, $$props) {
  $$renderer.push(`<!--[-->`);
  slot($$renderer, $$props, "default", {});
  $$renderer.push(`<!--]-->`);
}
__name(_layout, "_layout");
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_chunks();
  }
});
var __exports = {};
__export(__exports, {
  component: /* @__PURE__ */ __name(() => component, "component"),
  fonts: /* @__PURE__ */ __name(() => fonts, "fonts"),
  imports: /* @__PURE__ */ __name(() => imports, "imports"),
  index: /* @__PURE__ */ __name(() => index, "index"),
  stylesheets: /* @__PURE__ */ __name(() => stylesheets, "stylesheets")
});
var index;
var component_cache;
var component;
var imports;
var stylesheets;
var fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    index = 0;
    component = /* @__PURE__ */ __name(async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default, "component");
    imports = ["_app/immutable/nodes/0.BWtM9yRt.js", "_app/immutable/chunks/NZTpNUN0.js", "_app/immutable/chunks/J393zdJQ.js", "_app/immutable/chunks/D4DQbwrw.js"];
    stylesheets = ["_app/immutable/assets/0.CnyRlqf4.css"];
    fonts = [];
  }
});
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: /* @__PURE__ */ __name(() => Error$1, "default")
});
function create_updated_store() {
  const { set: set2, subscribe } = writable(false);
  {
    return {
      subscribe,
      // eslint-disable-next-line @typescript-eslint/require-await
      check: /* @__PURE__ */ __name(async () => false, "check")
    };
  }
}
__name(create_updated_store, "create_updated_store");
function context2() {
  return getContext("__request__");
}
__name(context2, "context");
function Error$1($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    $$renderer2.push(`<h1>${escape_html(page.status)}</h1> <p>${escape_html(page.error?.message)}</p>`);
  });
}
__name(Error$1, "Error$1");
var is_legacy;
var stores;
var page$1;
var page;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_context();
    init_utils2();
    init_server();
    init_internal();
    init_exports();
    init_utils();
    is_legacy = noop.toString().includes("$$") || /function \w+\(\) \{\}/.test(noop.toString());
    if (is_legacy) {
      ({
        data: {},
        form: null,
        error: null,
        params: {},
        route: { id: null },
        state: {},
        status: -1,
        url: new URL("https://example.com")
      });
    }
    stores = {
      updated: /* @__PURE__ */ create_updated_store()
    };
    ({
      check: stores.updated.check
    });
    page$1 = {
      get error() {
        return context2().page.error;
      },
      get status() {
        return context2().page.status;
      }
    };
    page = page$1;
  }
});
var __exports2 = {};
__export(__exports2, {
  component: /* @__PURE__ */ __name(() => component2, "component"),
  fonts: /* @__PURE__ */ __name(() => fonts2, "fonts"),
  imports: /* @__PURE__ */ __name(() => imports2, "imports"),
  index: /* @__PURE__ */ __name(() => index2, "index"),
  stylesheets: /* @__PURE__ */ __name(() => stylesheets2, "stylesheets")
});
var index2;
var component_cache2;
var component2;
var imports2;
var stylesheets2;
var fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = /* @__PURE__ */ __name(async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default, "component2");
    imports2 = ["_app/immutable/nodes/1.DdKoi16C.js", "_app/immutable/chunks/NZTpNUN0.js", "_app/immutable/chunks/J393zdJQ.js", "_app/immutable/chunks/D4DQbwrw.js", "_app/immutable/chunks/BuNyUiBZ.js", "_app/immutable/chunks/BnGH0CUP.js", "_app/immutable/chunks/C222IYg3.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});
function typeForRpc(value) {
  switch (typeof value) {
    case "boolean":
    case "number":
    case "string":
      return "primitive";
    case "undefined":
      return "undefined";
    case "object":
    case "function":
      break;
    case "bigint":
      return "bigint";
    default:
      return "unsupported";
  }
  if (value === null) {
    return "primitive";
  }
  let prototype = Object.getPrototypeOf(value);
  switch (prototype) {
    case Object.prototype:
      return "object";
    case Function.prototype:
      return "function";
    case Array.prototype:
      return "array";
    case Date.prototype:
      return "date";
    case Uint8Array.prototype:
      return "bytes";
    // TODO: All other structured clone types.
    case RpcStub.prototype:
      return "stub";
    case RpcPromise.prototype:
      return "rpc-promise";
    // TODO: Promise<T> or thenable
    default:
      if (workersModule) {
        if (prototype == workersModule.RpcStub.prototype || value instanceof workersModule.ServiceStub) {
          return "rpc-target";
        } else if (prototype == workersModule.RpcPromise.prototype || prototype == workersModule.RpcProperty.prototype) {
          return "rpc-thenable";
        }
      }
      if (value instanceof RpcTarget) {
        return "rpc-target";
      }
      if (value instanceof Error) {
        return "error";
      }
      return "unsupported";
  }
}
__name(typeForRpc, "typeForRpc");
function mapNotLoaded() {
  throw new Error("RPC map() implementation was not loaded.");
}
__name(mapNotLoaded, "mapNotLoaded");
function withCallInterceptor(interceptor, callback) {
  let oldValue = doCall;
  doCall = interceptor;
  try {
    return callback();
  } finally {
    doCall = oldValue;
  }
}
__name(withCallInterceptor, "withCallInterceptor");
function unwrapStubTakingOwnership(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB];
  if (pathIfPromise && pathIfPromise.length > 0) {
    return hook.get(pathIfPromise);
  } else {
    return hook;
  }
}
__name(unwrapStubTakingOwnership, "unwrapStubTakingOwnership");
function unwrapStubAndDup(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB];
  if (pathIfPromise) {
    return hook.get(pathIfPromise);
  } else {
    return hook.dup();
  }
}
__name(unwrapStubAndDup, "unwrapStubAndDup");
function unwrapStubNoProperties(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB];
  if (pathIfPromise && pathIfPromise.length > 0) {
    return void 0;
  }
  return hook;
}
__name(unwrapStubNoProperties, "unwrapStubNoProperties");
function unwrapStubOrParent(stub) {
  return stub[RAW_STUB].hook;
}
__name(unwrapStubOrParent, "unwrapStubOrParent");
function unwrapStubAndPath(stub) {
  return stub[RAW_STUB];
}
__name(unwrapStubAndPath, "unwrapStubAndPath");
async function pullPromise(promise) {
  let { hook, pathIfPromise } = promise[RAW_STUB];
  if (pathIfPromise.length > 0) {
    hook = hook.get(pathIfPromise);
  }
  let payload = await hook.pull();
  return payload.deliverResolve();
}
__name(pullPromise, "pullPromise");
function followPath(value, parent, path, owner) {
  for (let i = 0; i < path.length; i++) {
    parent = value;
    let part = path[i];
    if (part in Object.prototype) {
      value = void 0;
      continue;
    }
    let kind = typeForRpc(value);
    switch (kind) {
      case "object":
      case "function":
        if (Object.hasOwn(value, part)) {
          value = value[part];
        } else {
          value = void 0;
        }
        break;
      case "array":
        if (Number.isInteger(part) && part >= 0) {
          value = value[part];
        } else {
          value = void 0;
        }
        break;
      case "rpc-target":
      case "rpc-thenable": {
        if (Object.hasOwn(value, part)) {
          value = void 0;
        } else {
          value = value[part];
        }
        owner = null;
        break;
      }
      case "stub":
      case "rpc-promise": {
        let { hook, pathIfPromise } = unwrapStubAndPath(value);
        return { hook, remainingPath: pathIfPromise ? pathIfPromise.concat(path.slice(i)) : path.slice(i) };
      }
      case "primitive":
      case "bigint":
      case "bytes":
      case "date":
      case "error":
        value = void 0;
        break;
      case "undefined":
        value = value[part];
        break;
      case "unsupported": {
        if (i === 0) {
          throw new TypeError(`RPC stub points at a non-serializable type.`);
        } else {
          let prefix = path.slice(0, i).join(".");
          let remainder = path.slice(0, i).join(".");
          throw new TypeError(
            `'${prefix}' is not a serializable type, so property ${remainder} cannot be accessed.`
          );
        }
      }
      default:
        throw new TypeError("unreachable");
    }
  }
  if (value instanceof RpcPromise) {
    let { hook, pathIfPromise } = unwrapStubAndPath(value);
    return { hook, remainingPath: pathIfPromise || [] };
  }
  return {
    value,
    parent,
    owner
  };
}
__name(followPath, "followPath");
function disposeRpcTarget(target) {
  if (Symbol.dispose in target) {
    try {
      target[Symbol.dispose]();
    } catch (err) {
      Promise.reject(err);
    }
  }
}
__name(disposeRpcTarget, "disposeRpcTarget");
function throwMapperBuilderUseError() {
  throw new Error(
    "Attempted to use an abstract placeholder from a mapper function. Please make sure your map function has no side effects."
  );
}
__name(throwMapperBuilderUseError, "throwMapperBuilderUseError");
function applyMapToElement(input, parent, owner, captures, instructions) {
  let inputHook = new PayloadStubHook(RpcPayload.deepCopyFrom(input, parent, owner));
  let mapper = new MapApplicator(captures, inputHook);
  try {
    return mapper.apply(instructions);
  } finally {
    mapper.dispose();
  }
}
__name(applyMapToElement, "applyMapToElement");
var workersModuleName;
var workersModule;
var RpcTarget;
var mapImpl;
var StubHook;
var ErrorStubHook;
var DISPOSED_HOOK;
var doCall;
var RAW_STUB;
var PROXY_HANDLERS;
var RpcStub;
var RpcPromise;
var RpcPayload;
var ValueStubHook;
var PayloadStubHook;
var TargetStubHook;
var PromiseStubHook;
var NullExporter;
var NULL_EXPORTER;
var ERROR_TYPES;
var Devaluator;
var NullImporter;
var NULL_IMPORTER;
var Evaluator;
var currentMapBuilder;
var MapBuilder;
var MapVariableHook;
var MapApplicator;
var init_dist = __esm({
  async "node_modules/.pnpm/capnweb@0.1.0/node_modules/capnweb/dist/index.js"() {
    if (!Symbol.dispose) {
      Symbol.dispose = Symbol.for("dispose");
    }
    if (!Symbol.asyncDispose) {
      Symbol.asyncDispose = Symbol.for("asyncDispose");
    }
    workersModuleName = true ? "cloudflare:workers" : null;
    if (workersModuleName) {
      workersModule = await import(
        /* @vite-ignore */
        workersModuleName
      );
    }
    RpcTarget = workersModule ? workersModule.RpcTarget : class {
    };
    mapImpl = { applyMap: mapNotLoaded, sendMap: mapNotLoaded };
    StubHook = class {
      static {
        __name(this, "StubHook");
      }
    };
    ErrorStubHook = class extends StubHook {
      static {
        __name(this, "ErrorStubHook");
      }
      constructor(error22) {
        super();
        this.error = error22;
      }
      call(path, args) {
        return this;
      }
      map(path, captures, instructions) {
        return this;
      }
      get(path) {
        return this;
      }
      dup() {
        return this;
      }
      pull() {
        return Promise.reject(this.error);
      }
      ignoreUnhandledRejections() {
      }
      dispose() {
      }
      onBroken(callback) {
        try {
          callback(this.error);
        } catch (err) {
          Promise.resolve(err);
        }
      }
    };
    DISPOSED_HOOK = new ErrorStubHook(
      new Error("Attempted to use RPC stub after it has been disposed.")
    );
    doCall = /* @__PURE__ */ __name((hook, path, params) => {
      return hook.call(path, params);
    }, "doCall");
    RAW_STUB = Symbol("realStub");
    PROXY_HANDLERS = {
      apply(target, thisArg, argumentsList) {
        let stub = target.raw;
        return new RpcPromise(doCall(
          stub.hook,
          stub.pathIfPromise || [],
          RpcPayload.fromAppParams(argumentsList)
        ), []);
      },
      get(target, prop, receiver) {
        let stub = target.raw;
        if (prop === RAW_STUB) {
          return stub;
        } else if (prop in RpcPromise.prototype) {
          return stub[prop];
        } else if (typeof prop === "string") {
          return new RpcPromise(
            stub.hook,
            stub.pathIfPromise ? [...stub.pathIfPromise, prop] : [prop]
          );
        } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {
          return () => {
            stub.hook.dispose();
            stub.hook = DISPOSED_HOOK;
          };
        } else {
          return void 0;
        }
      },
      has(target, prop) {
        let stub = target.raw;
        if (prop === RAW_STUB) {
          return true;
        } else if (prop in RpcPromise.prototype) {
          return prop in stub;
        } else if (typeof prop === "string") {
          return true;
        } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {
          return true;
        } else {
          return false;
        }
      },
      construct(target, args) {
        throw new Error("An RPC stub cannot be used as a constructor.");
      },
      defineProperty(target, property, attributes2) {
        throw new Error("Can't define properties on RPC stubs.");
      },
      deleteProperty(target, p) {
        throw new Error("Can't delete properties on RPC stubs.");
      },
      getOwnPropertyDescriptor(target, p) {
        return void 0;
      },
      getPrototypeOf(target) {
        return Object.getPrototypeOf(target.raw);
      },
      isExtensible(target) {
        return false;
      },
      ownKeys(target) {
        return [];
      },
      preventExtensions(target) {
        return true;
      },
      set(target, p, newValue, receiver) {
        throw new Error("Can't assign properties on RPC stubs.");
      },
      setPrototypeOf(target, v2) {
        throw new Error("Can't override prototype of RPC stubs.");
      }
    };
    RpcStub = class _RpcStub2 extends RpcTarget {
      static {
        __name(this, "_RpcStub");
      }
      // Although `hook` and `path` are declared `public` here, they are effectively hidden by the
      // proxy.
      constructor(hook, pathIfPromise) {
        super();
        if (!(hook instanceof StubHook)) {
          let value = hook;
          if (value instanceof RpcTarget || value instanceof Function) {
            hook = TargetStubHook.create(value, void 0);
          } else {
            hook = new PayloadStubHook(RpcPayload.fromAppReturn(value));
          }
          if (pathIfPromise) {
            throw new TypeError("RpcStub constructor expected one argument, received two.");
          }
        }
        this.hook = hook;
        this.pathIfPromise = pathIfPromise;
        let func = /* @__PURE__ */ __name(() => {
        }, "func");
        func.raw = this;
        return new Proxy(func, PROXY_HANDLERS);
      }
      hook;
      pathIfPromise;
      dup() {
        let target = this[RAW_STUB];
        if (target.pathIfPromise) {
          return new _RpcStub2(target.hook.get(target.pathIfPromise));
        } else {
          return new _RpcStub2(target.hook.dup());
        }
      }
      onRpcBroken(callback) {
        this[RAW_STUB].hook.onBroken(callback);
      }
      map(func) {
        let { hook, pathIfPromise } = this[RAW_STUB];
        return mapImpl.sendMap(hook, pathIfPromise || [], func);
      }
    };
    RpcPromise = class extends RpcStub {
      static {
        __name(this, "RpcPromise");
      }
      // TODO: Support passing target value or promise to constructor.
      constructor(hook, pathIfPromise) {
        super(hook, pathIfPromise);
      }
      then(onfulfilled, onrejected) {
        return pullPromise(this).then(...arguments);
      }
      catch(onrejected) {
        return pullPromise(this).catch(...arguments);
      }
      finally(onfinally) {
        return pullPromise(this).finally(...arguments);
      }
    };
    RpcPayload = class _RpcPayload2 {
      static {
        __name(this, "_RpcPayload");
      }
      // Private constructor; use factory functions above to construct.
      constructor(value, source2, stubs, promises) {
        this.value = value;
        this.source = source2;
        this.stubs = stubs;
        this.promises = promises;
      }
      // Create a payload from a value passed as params to an RPC from the app.
      //
      // The payload does NOT take ownership of any stubs in `value`, and but promises not to modify
      // `value`. If the payload is delivered locally, `value` will be deep-copied first, so as not
      // to have the sender and recipient end up sharing the same mutable object. `value` will not be
      // touched again after the call returns synchronously (returns a promise) -- by that point,
      // the value has either been copied or serialized to the wire.
      static fromAppParams(value) {
        return new _RpcPayload2(value, "params");
      }
      // Create a payload from a value return from an RPC implementation by the app.
      //
      // Unlike fromAppParams(), in this case the payload takes ownership of all stubs in `value`, and
      // may hold onto `value` for an arbitarily long time (e.g. to serve pipelined requests). It
      // will still avoid modifying `value` and will make a deep copy if it is delivered locally.
      static fromAppReturn(value) {
        return new _RpcPayload2(value, "return");
      }
      // Combine an array of payloads into a single payload whose value is an array. Ownership of all
      // stubs is transferred from the inputs to the outputs, hence if the output is disposed, the
      // inputs should not be. (In case of exception, nothing is disposed, though.)
      static fromArray(array2) {
        let stubs = [];
        let promises = [];
        let resultArray = [];
        for (let payload of array2) {
          payload.ensureDeepCopied();
          for (let stub of payload.stubs) {
            stubs.push(stub);
          }
          for (let promise of payload.promises) {
            if (promise.parent === payload) {
              promise = {
                parent: resultArray,
                property: resultArray.length,
                promise: promise.promise
              };
            }
            promises.push(promise);
          }
          resultArray.push(payload.value);
        }
        return new _RpcPayload2(resultArray, "owned", stubs, promises);
      }
      // Create a payload from a value parsed off the wire using Evaluator.evaluate().
      //
      // A payload is constructed with a null value and the given stubs and promises arrays. The value
      // is expected to be filled in by the evaluator, and the stubs and promises arrays are expected
      // to be extended with stubs found during parsing. (This weird usage model is necessary so that
      // if the root value turns out to be a promise, its `parent` in `promises` can be the payload
      // object itself.)
      //
      // When done, the payload takes ownership of the final value and all the stubs within. It may
      // modify the value in preparation for delivery, and may deliver the value directly to the app
      // without copying.
      static forEvaluate(stubs, promises) {
        return new _RpcPayload2(null, "owned", stubs, promises);
      }
      // Deep-copy the given value, including dup()ing all stubs.
      //
      // If `value` is a function, it should be bound to `oldParent` as its `this`.
      //
      // If deep-copying from a branch of some other RpcPayload, it must be provided, to make sure
      // RpcTargets found within don't get duplicate stubs.
      static deepCopyFrom(value, oldParent, owner) {
        let result = new _RpcPayload2(null, "owned", [], []);
        result.value = result.deepCopy(
          value,
          oldParent,
          "value",
          result,
          /*dupStubs=*/
          true,
          owner
        );
        return result;
      }
      // For `soruce === "return"` payloads only, this tracks any StubHooks created around RpcTargets
      // found in the payload at the time that it is serialized (or deep-copied) for return, so that we
      // can make sure they are not disposed before the pipeline ends.
      //
      // This is initialized on first use.
      rpcTargets;
      // Get the StubHook representing the given RpcTarget found inside this payload.
      getHookForRpcTarget(target, parent, dupStubs = true) {
        if (this.source === "params") {
          return TargetStubHook.create(target, parent);
        } else if (this.source === "return") {
          let hook = this.rpcTargets?.get(target);
          if (hook) {
            if (dupStubs) {
              return hook.dup();
            } else {
              this.rpcTargets?.delete(target);
              return hook;
            }
          } else {
            hook = TargetStubHook.create(target, parent);
            if (dupStubs) {
              if (!this.rpcTargets) {
                this.rpcTargets = /* @__PURE__ */ new Map();
              }
              this.rpcTargets.set(target, hook);
              return hook.dup();
            } else {
              return hook;
            }
          }
        } else {
          throw new Error("owned payload shouldn't contain raw RpcTargets");
        }
      }
      deepCopy(value, oldParent, property, parent, dupStubs, owner) {
        let kind = typeForRpc(value);
        switch (kind) {
          case "unsupported":
            return value;
          case "primitive":
          case "bigint":
          case "date":
          case "bytes":
          case "error":
          case "undefined":
            return value;
          case "array": {
            let array2 = value;
            let len = array2.length;
            let result = new Array(len);
            for (let i = 0; i < len; i++) {
              result[i] = this.deepCopy(array2[i], array2, i, result, dupStubs, owner);
            }
            return result;
          }
          case "object": {
            let result = {};
            let object = value;
            for (let i in object) {
              result[i] = this.deepCopy(object[i], object, i, result, dupStubs, owner);
            }
            return result;
          }
          case "stub":
          case "rpc-promise": {
            let stub = value;
            let hook;
            if (dupStubs) {
              hook = unwrapStubAndDup(stub);
            } else {
              hook = unwrapStubTakingOwnership(stub);
            }
            if (stub instanceof RpcPromise) {
              let promise = new RpcPromise(hook, []);
              this.promises.push({ parent, property, promise });
              return promise;
            } else {
              let newStub = new RpcStub(hook);
              this.stubs.push(newStub);
              return newStub;
            }
          }
          case "function":
          case "rpc-target": {
            let target = value;
            let stub;
            if (owner) {
              stub = new RpcStub(owner.getHookForRpcTarget(target, oldParent, dupStubs));
            } else {
              stub = new RpcStub(TargetStubHook.create(target, oldParent));
            }
            this.stubs.push(stub);
            return stub;
          }
          case "rpc-thenable": {
            let target = value;
            let promise;
            if (owner) {
              promise = new RpcPromise(owner.getHookForRpcTarget(target, oldParent, dupStubs), []);
            } else {
              promise = new RpcPromise(TargetStubHook.create(target, oldParent), []);
            }
            this.promises.push({ parent, property, promise });
            return promise;
          }
          default:
            throw new Error("unreachable");
        }
      }
      // Ensures that if the value originally came from an unowned source, we have replaced it with a
      // deep copy.
      ensureDeepCopied() {
        if (this.source !== "owned") {
          let dupStubs = this.source === "params";
          this.stubs = [];
          this.promises = [];
          try {
            this.value = this.deepCopy(this.value, void 0, "value", this, dupStubs, this);
          } catch (err) {
            this.stubs = void 0;
            this.promises = void 0;
            throw err;
          }
          this.source = "owned";
          if (this.rpcTargets && this.rpcTargets.size > 0) {
            throw new Error("Not all rpcTargets were accounted for in deep-copy?");
          }
          this.rpcTargets = void 0;
        }
      }
      // Resolve all promises in this payload and then assign the final value into `parent[property]`.
      deliverTo(parent, property, promises) {
        this.ensureDeepCopied();
        if (this.value instanceof RpcPromise) {
          _RpcPayload2.deliverRpcPromiseTo(this.value, parent, property, promises);
        } else {
          parent[property] = this.value;
          for (let record of this.promises) {
            _RpcPayload2.deliverRpcPromiseTo(record.promise, record.parent, record.property, promises);
          }
        }
      }
      static deliverRpcPromiseTo(promise, parent, property, promises) {
        let hook = unwrapStubNoProperties(promise);
        if (!hook) {
          throw new Error("property promises should have been resolved earlier");
        }
        let inner = hook.pull();
        if (inner instanceof _RpcPayload2) {
          inner.deliverTo(parent, property, promises);
        } else {
          promises.push(inner.then((payload) => {
            let subPromises = [];
            payload.deliverTo(parent, property, subPromises);
            if (subPromises.length > 0) {
              return Promise.all(subPromises);
            }
          }));
        }
      }
      // Call the given function with the payload as an argument. The call is made synchronously if
      // possible, in order to maintain e-order. However, if any RpcPromises exist in the payload,
      // they are awaited and substituted before calling the function. The result of the call is
      // wrapped into another payload.
      //
      // The payload is automatically disposed after the call completes. The caller should not call
      // dispose().
      async deliverCall(func, thisArg) {
        try {
          let promises = [];
          this.deliverTo(this, "value", promises);
          if (promises.length > 0) {
            await Promise.all(promises);
          }
          let result = Function.prototype.apply.call(func, thisArg, this.value);
          if (result instanceof RpcPromise) {
            return _RpcPayload2.fromAppReturn(result);
          } else {
            return _RpcPayload2.fromAppReturn(await result);
          }
        } finally {
          this.dispose();
        }
      }
      // Produce a promise for this payload for return to the application. Any RpcPromises in the
      // payload are awaited and substituted with their results first.
      //
      // The returned object will have a disposer which disposes the payload. The caller should not
      // separately dispose it.
      async deliverResolve() {
        try {
          let promises = [];
          this.deliverTo(this, "value", promises);
          if (promises.length > 0) {
            await Promise.all(promises);
          }
          let result = this.value;
          if (result instanceof Object) {
            if (!(Symbol.dispose in result)) {
              Object.defineProperty(result, Symbol.dispose, {
                // NOTE: Using `this.dispose.bind(this)` here causes Playwright's build of
                //   Chromium 140.0.7339.16 to fail when the object is assigned to a `using` variable,
                //   with the error:
                //       TypeError: Symbol(Symbol.dispose) is not a function
                //   I cannot reproduce this problem in Chrome 140.0.7339.127 nor in Node or workerd,
                //   so maybe it was a short-lived V8 bug or something. To be safe, though, we use
                //   `() => this.dispose()`, which seems to always work.
                value: /* @__PURE__ */ __name(() => this.dispose(), "value"),
                writable: true,
                enumerable: false,
                configurable: true
              });
            }
          }
          return result;
        } catch (err) {
          this.dispose();
          throw err;
        }
      }
      dispose() {
        if (this.source === "owned") {
          this.stubs.forEach((stub) => stub[Symbol.dispose]());
          this.promises.forEach((promise) => promise.promise[Symbol.dispose]());
        } else if (this.source === "return") {
          this.disposeImpl(this.value, void 0);
          if (this.rpcTargets && this.rpcTargets.size > 0) {
            throw new Error("Not all rpcTargets were accounted for in disposeImpl()?");
          }
        } else ;
        this.source = "owned";
        this.stubs = [];
        this.promises = [];
      }
      // Recursive dispose, called only when `source` is "return".
      disposeImpl(value, parent) {
        let kind = typeForRpc(value);
        switch (kind) {
          case "unsupported":
          case "primitive":
          case "bigint":
          case "bytes":
          case "date":
          case "error":
          case "undefined":
            return;
          case "array": {
            let array2 = value;
            let len = array2.length;
            for (let i = 0; i < len; i++) {
              this.disposeImpl(array2[i], array2);
            }
            return;
          }
          case "object": {
            let object = value;
            for (let i in object) {
              this.disposeImpl(object[i], object);
            }
            return;
          }
          case "stub":
          case "rpc-promise": {
            let stub = value;
            let hook = unwrapStubNoProperties(stub);
            if (hook) {
              hook.dispose();
            }
            return;
          }
          case "function":
          case "rpc-target": {
            let target = value;
            let hook = this.rpcTargets?.get(target);
            if (hook) {
              hook.dispose();
              this.rpcTargets.delete(target);
            } else {
              disposeRpcTarget(target);
            }
            return;
          }
          case "rpc-thenable":
            return;
          default:
            return;
        }
      }
      // Ignore unhandled rejections in all promises in this payload -- that is, all promises that
      // *would* be awaited if this payload were to be delivered. See the similarly-named method of
      // StubHook for explanation.
      ignoreUnhandledRejections() {
        if (this.stubs) {
          this.stubs.forEach((stub) => {
            unwrapStubOrParent(stub).ignoreUnhandledRejections();
          });
          this.promises.forEach(
            (promise) => unwrapStubOrParent(promise.promise).ignoreUnhandledRejections()
          );
        } else {
          this.ignoreUnhandledRejectionsImpl(this.value);
        }
      }
      ignoreUnhandledRejectionsImpl(value) {
        let kind = typeForRpc(value);
        switch (kind) {
          case "unsupported":
          case "primitive":
          case "bigint":
          case "bytes":
          case "date":
          case "error":
          case "undefined":
          case "function":
          case "rpc-target":
            return;
          case "array": {
            let array2 = value;
            let len = array2.length;
            for (let i = 0; i < len; i++) {
              this.ignoreUnhandledRejectionsImpl(array2[i]);
            }
            return;
          }
          case "object": {
            let object = value;
            for (let i in object) {
              this.ignoreUnhandledRejectionsImpl(object[i]);
            }
            return;
          }
          case "stub":
          case "rpc-promise":
            unwrapStubOrParent(value).ignoreUnhandledRejections();
            return;
          case "rpc-thenable":
            value.then((_) => {
            }, (_) => {
            });
            return;
          default:
            return;
        }
      }
    };
    ValueStubHook = class extends StubHook {
      static {
        __name(this, "ValueStubHook");
      }
      call(path, args) {
        try {
          let { value, owner } = this.getValue();
          let followResult = followPath(value, void 0, path, owner);
          if (followResult.hook) {
            return followResult.hook.call(followResult.remainingPath, args);
          }
          if (typeof followResult.value != "function") {
            throw new TypeError(`'${path.join(".")}' is not a function.`);
          }
          let promise = args.deliverCall(followResult.value, followResult.parent);
          return new PromiseStubHook(promise.then((payload) => {
            return new PayloadStubHook(payload);
          }));
        } catch (err) {
          return new ErrorStubHook(err);
        }
      }
      map(path, captures, instructions) {
        try {
          let followResult;
          try {
            let { value, owner } = this.getValue();
            followResult = followPath(value, void 0, path, owner);
            ;
          } catch (err) {
            for (let cap of captures) {
              cap.dispose();
            }
            throw err;
          }
          if (followResult.hook) {
            return followResult.hook.map(followResult.remainingPath, captures, instructions);
          }
          return mapImpl.applyMap(
            followResult.value,
            followResult.parent,
            followResult.owner,
            captures,
            instructions
          );
        } catch (err) {
          return new ErrorStubHook(err);
        }
      }
      get(path) {
        try {
          let { value, owner } = this.getValue();
          if (path.length === 0 && owner === null) {
            throw new Error("Can't dup an RpcTarget stub as a promise.");
          }
          let followResult = followPath(value, void 0, path, owner);
          if (followResult.hook) {
            return followResult.hook.get(followResult.remainingPath);
          }
          return new PayloadStubHook(RpcPayload.deepCopyFrom(
            followResult.value,
            followResult.parent,
            followResult.owner
          ));
        } catch (err) {
          return new ErrorStubHook(err);
        }
      }
    };
    PayloadStubHook = class _PayloadStubHook2 extends ValueStubHook {
      static {
        __name(this, "_PayloadStubHook");
      }
      constructor(payload) {
        super();
        this.payload = payload;
      }
      payload;
      // cleared when disposed
      getPayload() {
        if (this.payload) {
          return this.payload;
        } else {
          throw new Error("Attempted to use an RPC StubHook after it was disposed.");
        }
      }
      getValue() {
        let payload = this.getPayload();
        return { value: payload.value, owner: payload };
      }
      dup() {
        let thisPayload = this.getPayload();
        return new _PayloadStubHook2(RpcPayload.deepCopyFrom(
          thisPayload.value,
          void 0,
          thisPayload
        ));
      }
      pull() {
        return this.getPayload();
      }
      ignoreUnhandledRejections() {
        if (this.payload) {
          this.payload.ignoreUnhandledRejections();
        }
      }
      dispose() {
        if (this.payload) {
          this.payload.dispose();
          this.payload = void 0;
        }
      }
      onBroken(callback) {
        if (this.payload) {
          if (this.payload.value instanceof RpcStub) {
            this.payload.value.onRpcBroken(callback);
          }
        }
      }
    };
    TargetStubHook = class _TargetStubHook2 extends ValueStubHook {
      static {
        __name(this, "_TargetStubHook");
      }
      // Constructs a TargetStubHook that is not duplicated from an existing hook.
      //
      // If `value` is a function, `parent` is bound as its "this".
      static create(value, parent) {
        if (typeof value !== "function") {
          parent = void 0;
        }
        return new _TargetStubHook2(value, parent);
      }
      constructor(target, parent, dupFrom) {
        super();
        this.target = target;
        this.parent = parent;
        if (dupFrom) {
          if (dupFrom.refcount) {
            this.refcount = dupFrom.refcount;
            ++this.refcount.count;
          }
        } else if (Symbol.dispose in target) {
          this.refcount = { count: 1 };
        }
      }
      target;
      // cleared when disposed
      parent;
      // `this` parameter when calling `target`
      refcount;
      // undefined if not needed (because target has no disposer)
      getTarget() {
        if (this.target) {
          return this.target;
        } else {
          throw new Error("Attempted to use an RPC StubHook after it was disposed.");
        }
      }
      getValue() {
        return { value: this.getTarget(), owner: null };
      }
      dup() {
        return new _TargetStubHook2(this.getTarget(), this.parent, this);
      }
      pull() {
        let target = this.getTarget();
        if ("then" in target) {
          return Promise.resolve(target).then((resolution) => {
            return RpcPayload.fromAppReturn(resolution);
          });
        } else {
          return Promise.reject(new Error("Tried to resolve a non-promise stub."));
        }
      }
      ignoreUnhandledRejections() {
      }
      dispose() {
        if (this.target) {
          if (this.refcount) {
            if (--this.refcount.count == 0) {
              disposeRpcTarget(this.target);
            }
          }
          this.target = void 0;
        }
      }
      onBroken(callback) {
      }
    };
    PromiseStubHook = class _PromiseStubHook2 extends StubHook {
      static {
        __name(this, "_PromiseStubHook");
      }
      promise;
      resolution;
      constructor(promise) {
        super();
        this.promise = promise.then((res) => {
          this.resolution = res;
          return res;
        });
      }
      call(path, args) {
        args.ensureDeepCopied();
        return new _PromiseStubHook2(this.promise.then((hook) => hook.call(path, args)));
      }
      map(path, captures, instructions) {
        return new _PromiseStubHook2(this.promise.then(
          (hook) => hook.map(path, captures, instructions),
          (err) => {
            for (let cap of captures) {
              cap.dispose();
            }
            throw err;
          }
        ));
      }
      get(path) {
        return new _PromiseStubHook2(this.promise.then((hook) => hook.get(path)));
      }
      dup() {
        if (this.resolution) {
          return this.resolution.dup();
        } else {
          return new _PromiseStubHook2(this.promise.then((hook) => hook.dup()));
        }
      }
      pull() {
        if (this.resolution) {
          return this.resolution.pull();
        } else {
          return this.promise.then((hook) => hook.pull());
        }
      }
      ignoreUnhandledRejections() {
        if (this.resolution) {
          this.resolution.ignoreUnhandledRejections();
        } else {
          this.promise.then((res) => {
            res.ignoreUnhandledRejections();
          }, (err) => {
          });
        }
      }
      dispose() {
        if (this.resolution) {
          this.resolution.dispose();
        } else {
          this.promise.then((hook) => {
            hook.dispose();
          }, (err) => {
          });
        }
      }
      onBroken(callback) {
        if (this.resolution) {
          this.resolution.onBroken(callback);
        } else {
          this.promise.then((hook) => {
            hook.onBroken(callback);
          }, callback);
        }
      }
    };
    NullExporter = class {
      static {
        __name(this, "NullExporter");
      }
      exportStub(stub) {
        throw new Error("Cannot serialize RPC stubs without an RPC session.");
      }
      exportPromise(stub) {
        throw new Error("Cannot serialize RPC stubs without an RPC session.");
      }
      getImport(hook) {
        return void 0;
      }
      unexport(ids) {
      }
      onSendError(error22) {
      }
    };
    NULL_EXPORTER = new NullExporter();
    ERROR_TYPES = {
      Error,
      EvalError,
      RangeError,
      ReferenceError,
      SyntaxError,
      TypeError,
      URIError,
      AggregateError
      // TODO: DOMError? Others?
    };
    Devaluator = class _Devaluator2 {
      static {
        __name(this, "_Devaluator");
      }
      constructor(exporter, source2) {
        this.exporter = exporter;
        this.source = source2;
      }
      // Devaluate the given value.
      // * value: The value to devaluate.
      // * parent: The value's parent object, which would be used as `this` if the value were called
      //     as a function.
      // * exporter: Callbacks to the RPC session for exporting capabilities found in this message.
      // * source: The RpcPayload which contains the value, and therefore owns stubs within.
      //
      // Returns: The devaluated value, ready to be JSON-serialized.
      static devaluate(value, parent, exporter = NULL_EXPORTER, source2) {
        let devaluator = new _Devaluator2(exporter, source2);
        try {
          return devaluator.devaluateImpl(value, parent, 0);
        } catch (err) {
          if (devaluator.exports) {
            try {
              exporter.unexport(devaluator.exports);
            } catch (err2) {
            }
          }
          throw err;
        }
      }
      exports;
      devaluateImpl(value, parent, depth) {
        if (depth >= 64) {
          throw new Error(
            "Serialization exceeded maximum allowed depth. (Does the message contain cycles?)"
          );
        }
        let kind = typeForRpc(value);
        switch (kind) {
          case "unsupported": {
            let msg;
            try {
              msg = `Cannot serialize value: ${value}`;
            } catch (err) {
              msg = "Cannot serialize value: (couldn't stringify value)";
            }
            throw new TypeError(msg);
          }
          case "primitive":
            return value;
          case "object": {
            let object = value;
            let result = {};
            for (let key2 in object) {
              result[key2] = this.devaluateImpl(object[key2], object, depth + 1);
            }
            return result;
          }
          case "array": {
            let array2 = value;
            let len = array2.length;
            let result = new Array(len);
            for (let i = 0; i < len; i++) {
              result[i] = this.devaluateImpl(array2[i], array2, depth + 1);
            }
            return [result];
          }
          case "bigint":
            return ["bigint", value.toString()];
          case "date":
            return ["date", value.getTime()];
          case "bytes": {
            let bytes = value;
            if (bytes.toBase64) {
              return ["bytes", bytes.toBase64({ omitPadding: true })];
            } else {
              return [
                "bytes",
                btoa(String.fromCharCode.apply(null, bytes).replace(/=*$/, ""))
              ];
            }
          }
          case "error": {
            let e3 = value;
            let rewritten = this.exporter.onSendError(e3);
            if (rewritten) {
              e3 = rewritten;
            }
            let result = ["error", e3.name, e3.message];
            if (rewritten && rewritten.stack) {
              result.push(rewritten.stack);
            }
            return result;
          }
          case "undefined":
            return ["undefined"];
          case "stub":
          case "rpc-promise": {
            if (!this.source) {
              throw new Error("Can't serialize RPC stubs in this context.");
            }
            let { hook, pathIfPromise } = unwrapStubAndPath(value);
            let importId = this.exporter.getImport(hook);
            if (importId !== void 0) {
              if (pathIfPromise) {
                if (pathIfPromise.length > 0) {
                  return ["pipeline", importId, pathIfPromise];
                } else {
                  return ["pipeline", importId];
                }
              } else {
                return ["import", importId];
              }
            }
            if (pathIfPromise) {
              hook = hook.get(pathIfPromise);
            } else {
              hook = hook.dup();
            }
            return this.devaluateHook(pathIfPromise ? "promise" : "export", hook);
          }
          case "function":
          case "rpc-target": {
            if (!this.source) {
              throw new Error("Can't serialize RPC stubs in this context.");
            }
            let hook = this.source.getHookForRpcTarget(value, parent);
            return this.devaluateHook("export", hook);
          }
          case "rpc-thenable": {
            if (!this.source) {
              throw new Error("Can't serialize RPC stubs in this context.");
            }
            let hook = this.source.getHookForRpcTarget(value, parent);
            return this.devaluateHook("promise", hook);
          }
          default:
            throw new Error("unreachable");
        }
      }
      devaluateHook(type, hook) {
        if (!this.exports) this.exports = [];
        let exportId = type === "promise" ? this.exporter.exportPromise(hook) : this.exporter.exportStub(hook);
        this.exports.push(exportId);
        return [type, exportId];
      }
    };
    NullImporter = class {
      static {
        __name(this, "NullImporter");
      }
      importStub(idx) {
        throw new Error("Cannot deserialize RPC stubs without an RPC session.");
      }
      importPromise(idx) {
        throw new Error("Cannot deserialize RPC stubs without an RPC session.");
      }
      getExport(idx) {
        return void 0;
      }
    };
    NULL_IMPORTER = new NullImporter();
    Evaluator = class _Evaluator2 {
      static {
        __name(this, "_Evaluator");
      }
      constructor(importer) {
        this.importer = importer;
      }
      stubs = [];
      promises = [];
      evaluate(value) {
        let payload = RpcPayload.forEvaluate(this.stubs, this.promises);
        try {
          payload.value = this.evaluateImpl(value, payload, "value");
          return payload;
        } catch (err) {
          payload.dispose();
          throw err;
        }
      }
      // Evaluate the value without destroying it.
      evaluateCopy(value) {
        return this.evaluate(structuredClone(value));
      }
      evaluateImpl(value, parent, property) {
        if (value instanceof Array) {
          if (value.length == 1 && value[0] instanceof Array) {
            let result = value[0];
            for (let i = 0; i < result.length; i++) {
              result[i] = this.evaluateImpl(result[i], result, i);
            }
            return result;
          } else switch (value[0]) {
            case "bigint":
              if (typeof value[1] == "string") {
                return BigInt(value[1]);
              }
              break;
            case "date":
              if (typeof value[1] == "number") {
                return new Date(value[1]);
              }
              break;
            case "bytes": {
              let b64 = Uint8Array;
              if (typeof value[1] == "string") {
                if (b64.fromBase64) {
                  return b64.fromBase64(value[1]);
                } else {
                  let bs = atob(value[1]);
                  let len = bs.length;
                  let bytes = new Uint8Array(len);
                  for (let i = 0; i < len; i++) {
                    bytes[i] = bs.charCodeAt(i);
                  }
                  return bytes;
                }
              }
              break;
            }
            case "error":
              if (value.length >= 3 && typeof value[1] === "string" && typeof value[2] === "string") {
                let cls = ERROR_TYPES[value[1]] || Error;
                let result = new cls(value[2]);
                if (typeof value[3] === "string") {
                  result.stack = value[3];
                }
                return result;
              }
              break;
            case "undefined":
              if (value.length === 1) {
                return void 0;
              }
              break;
            case "import":
            case "pipeline": {
              if (value.length < 2 || value.length > 4) {
                break;
              }
              if (typeof value[1] != "number") {
                break;
              }
              let hook = this.importer.getExport(value[1]);
              if (!hook) {
                throw new Error(`no such entry on exports table: ${value[1]}`);
              }
              let isPromise = value[0] == "pipeline";
              let addStub = /* @__PURE__ */ __name((hook2) => {
                if (isPromise) {
                  let promise = new RpcPromise(hook2, []);
                  this.promises.push({ promise, parent, property });
                  return promise;
                } else {
                  let stub = new RpcPromise(hook2, []);
                  this.stubs.push(stub);
                  return stub;
                }
              }, "addStub");
              if (value.length == 2) {
                if (isPromise) {
                  return addStub(hook.get([]));
                } else {
                  return addStub(hook.dup());
                }
              }
              let path = value[2];
              if (!(path instanceof Array)) {
                break;
              }
              if (!path.every(
                (part) => {
                  return typeof part == "string" || typeof part == "number";
                }
              )) {
                break;
              }
              if (value.length == 3) {
                return addStub(hook.get(path));
              }
              let args = value[3];
              if (!(args instanceof Array)) {
                break;
              }
              let subEval = new _Evaluator2(this.importer);
              args = subEval.evaluate([args]);
              return addStub(hook.call(path, args));
            }
            case "remap": {
              if (value.length !== 5 || typeof value[1] !== "number" || !(value[2] instanceof Array) || !(value[3] instanceof Array) || !(value[4] instanceof Array)) {
                break;
              }
              let hook = this.importer.getExport(value[1]);
              if (!hook) {
                throw new Error(`no such entry on exports table: ${value[1]}`);
              }
              let path = value[2];
              if (!path.every(
                (part) => {
                  return typeof part == "string" || typeof part == "number";
                }
              )) {
                break;
              }
              let captures = value[3].map((cap) => {
                if (!(cap instanceof Array) || cap.length !== 2 || cap[0] !== "import" && cap[0] !== "export" || typeof cap[1] !== "number") {
                  throw new TypeError(`unknown map capture: ${JSON.stringify(cap)}`);
                }
                if (cap[0] === "export") {
                  return this.importer.importStub(cap[1]);
                } else {
                  let exp = this.importer.getExport(cap[1]);
                  if (!exp) {
                    throw new Error(`no such entry on exports table: ${cap[1]}`);
                  }
                  return exp.dup();
                }
              });
              let instructions = value[4];
              let resultHook = hook.map(path, captures, instructions);
              let promise = new RpcPromise(resultHook, []);
              this.promises.push({ promise, parent, property });
              return promise;
            }
            case "export":
            case "promise":
              if (typeof value[1] == "number") {
                if (value[0] == "promise") {
                  let hook = this.importer.importPromise(value[1]);
                  let promise = new RpcPromise(hook, []);
                  this.promises.push({ parent, property, promise });
                  return promise;
                } else {
                  let hook = this.importer.importStub(value[1]);
                  let stub = new RpcStub(hook);
                  this.stubs.push(stub);
                  return stub;
                }
              }
              break;
          }
          throw new TypeError(`unknown special value: ${JSON.stringify(value)}`);
        } else if (value instanceof Object) {
          let result = value;
          for (let key2 in result) {
            if (key2 in Object.prototype || key2 === "toJSON") {
              this.evaluateImpl(result[key2], result, key2);
              delete result[key2];
            } else {
              result[key2] = this.evaluateImpl(result[key2], result, key2);
            }
          }
          return result;
        } else {
          return value;
        }
      }
    };
    MapBuilder = class {
      static {
        __name(this, "MapBuilder");
      }
      context;
      captureMap = /* @__PURE__ */ new Map();
      instructions = [];
      constructor(subject, path) {
        if (currentMapBuilder) {
          this.context = {
            parent: currentMapBuilder,
            captures: [],
            subject: currentMapBuilder.capture(subject),
            path
          };
        } else {
          this.context = {
            parent: void 0,
            captures: [],
            subject,
            path
          };
        }
        currentMapBuilder = this;
      }
      unregister() {
        currentMapBuilder = this.context.parent;
      }
      makeInput() {
        return new MapVariableHook(this, 0);
      }
      makeOutput(result) {
        let devalued;
        try {
          devalued = Devaluator.devaluate(result.value, void 0, this, result);
        } finally {
          result.dispose();
        }
        this.instructions.push(devalued);
        if (this.context.parent) {
          this.context.parent.instructions.push(
            [
              "remap",
              this.context.subject,
              this.context.path,
              this.context.captures.map((cap) => ["import", cap]),
              this.instructions
            ]
          );
          return new MapVariableHook(this.context.parent, this.context.parent.instructions.length);
        } else {
          return this.context.subject.map(this.context.path, this.context.captures, this.instructions);
        }
      }
      pushCall(hook, path, params) {
        let devalued = Devaluator.devaluate(params.value, void 0, this, params);
        devalued = devalued[0];
        let subject = this.capture(hook.dup());
        this.instructions.push(["pipeline", subject, path, devalued]);
        return new MapVariableHook(this, this.instructions.length);
      }
      pushGet(hook, path) {
        let subject = this.capture(hook.dup());
        this.instructions.push(["pipeline", subject, path]);
        return new MapVariableHook(this, this.instructions.length);
      }
      capture(hook) {
        if (hook instanceof MapVariableHook && hook.mapper === this) {
          return hook.idx;
        }
        let result = this.captureMap.get(hook);
        if (result === void 0) {
          if (this.context.parent) {
            let parentIdx = this.context.parent.capture(hook);
            this.context.captures.push(parentIdx);
          } else {
            this.context.captures.push(hook);
          }
          result = -this.context.captures.length;
          this.captureMap.set(hook, result);
        }
        return result;
      }
      // ---------------------------------------------------------------------------
      // implements Exporter
      exportStub(hook) {
        throw new Error(
          "Can't construct an RpcTarget or RPC callback inside a mapper function. Try creating a new RpcStub outside the callback first, then using it inside the callback."
        );
      }
      exportPromise(hook) {
        return this.exportStub(hook);
      }
      getImport(hook) {
        return this.capture(hook);
      }
      unexport(ids) {
      }
      onSendError(error22) {
      }
    };
    mapImpl.sendMap = (hook, path, func) => {
      let builder = new MapBuilder(hook, path);
      let result;
      try {
        result = RpcPayload.fromAppReturn(withCallInterceptor(builder.pushCall.bind(builder), () => {
          return func(new RpcPromise(builder.makeInput(), []));
        }));
      } finally {
        builder.unregister();
      }
      if (result instanceof Promise) {
        result.catch((err) => {
        });
        throw new Error("RPC map() callbacks cannot be async.");
      }
      return new RpcPromise(builder.makeOutput(result), []);
    };
    MapVariableHook = class extends StubHook {
      static {
        __name(this, "MapVariableHook");
      }
      constructor(mapper, idx) {
        super();
        this.mapper = mapper;
        this.idx = idx;
      }
      // We don't have anything we actually need to dispose, so dup() can just return the same hook.
      dup() {
        return this;
      }
      dispose() {
      }
      get(path) {
        if (path.length == 0) {
          return this;
        } else if (currentMapBuilder) {
          return currentMapBuilder.pushGet(this, path);
        } else {
          throwMapperBuilderUseError();
        }
      }
      // Other methods should never be called.
      call(path, args) {
        throwMapperBuilderUseError();
      }
      map(path, captures, instructions) {
        throwMapperBuilderUseError();
      }
      pull() {
        throwMapperBuilderUseError();
      }
      ignoreUnhandledRejections() {
      }
      onBroken(callback) {
        throwMapperBuilderUseError();
      }
    };
    MapApplicator = class {
      static {
        __name(this, "MapApplicator");
      }
      constructor(captures, input) {
        this.captures = captures;
        this.variables = [input];
      }
      variables;
      dispose() {
        for (let variable of this.variables) {
          variable.dispose();
        }
      }
      apply(instructions) {
        try {
          if (instructions.length < 1) {
            throw new Error("Invalid empty mapper function.");
          }
          for (let instruction of instructions.slice(0, -1)) {
            let payload = new Evaluator(this).evaluateCopy(instruction);
            if (payload.value instanceof RpcStub) {
              let hook = unwrapStubNoProperties(payload.value);
              if (hook) {
                this.variables.push(hook);
                continue;
              }
            }
            this.variables.push(new PayloadStubHook(payload));
          }
          return new Evaluator(this).evaluateCopy(instructions[instructions.length - 1]);
        } finally {
          for (let variable of this.variables) {
            variable.dispose();
          }
        }
      }
      importStub(idx) {
        throw new Error("A mapper function cannot refer to exports.");
      }
      importPromise(idx) {
        return this.importStub(idx);
      }
      getExport(idx) {
        if (idx < 0) {
          return this.captures[-idx - 1];
        } else {
          return this.variables[idx];
        }
      }
    };
    mapImpl.applyMap = (input, parent, owner, captures, instructions) => {
      try {
        let result;
        if (input instanceof RpcPromise) {
          throw new Error("applyMap() can't be called on RpcPromise");
        } else if (input instanceof Array) {
          let payloads = [];
          try {
            for (let elem of input) {
              payloads.push(applyMapToElement(elem, input, owner, captures, instructions));
            }
          } catch (err) {
            for (let payload of payloads) {
              payload.dispose();
            }
            throw err;
          }
          result = RpcPayload.fromArray(payloads);
        } else if (input === null || input === void 0) {
          result = RpcPayload.fromAppReturn(input);
        } else {
          result = applyMapToElement(input, parent, owner, captures, instructions);
        }
        return new PayloadStubHook(result);
      } finally {
        for (let cap of captures) {
          cap.dispose();
        }
      }
    };
  }
});
var sqlite3InitModule;
var toExportForESM;
var init_sqlite3_bundler_friendly = __esm({
  "node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.50.4-build1/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs"() {
    sqlite3InitModule = (() => {
      var _scriptName = import.meta.url;
      return function(moduleArg = {}) {
        var moduleRtn;
        var Module = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        var readyPromise = new Promise((resolve2, reject) => {
          readyPromiseResolve = resolve2;
          readyPromiseReject = reject;
        });
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
        var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        const sqlite3InitModuleState = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {
          debugModule: /* @__PURE__ */ __name(() => {
          }, "debugModule")
        });
        delete globalThis.sqlite3InitModuleState;
        sqlite3InitModuleState.debugModule(
          "globalThis.location =",
          globalThis.location
        );
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = /* @__PURE__ */ __name((status, toThrow) => {
          throw toThrow;
        }, "quit_");
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        __name(locateFile, "locateFile");
        var readAsync, readBinary;
        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptName) {
            scriptDirectory = _scriptName;
          }
          if (scriptDirectory.startsWith("blob:")) {
            scriptDirectory = "";
          } else {
            scriptDirectory = scriptDirectory.substr(
              0,
              scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
            );
          }
          {
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = /* @__PURE__ */ __name((url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              }, "readBinary");
            }
            readAsync = /* @__PURE__ */ __name((url) => {
              return fetch(url, { credentials: "same-origin" }).then((response) => {
                if (response.ok) {
                  return response.arrayBuffer();
                }
                return Promise.reject(
                  new Error(response.status + " : " + response.url)
                );
              });
            }, "readAsync");
          }
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.error.bind(console);
        Object.assign(Module, moduleOverrides);
        moduleOverrides = null;
        if (Module["arguments"]) arguments_ = Module["arguments"];
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        var wasmBinary = Module["wasmBinary"];
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert3(condition, text2) {
          if (!condition) {
            abort22(text2);
          }
        }
        __name(assert3, "assert");
        var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module["HEAP8"] = HEAP8 = new Int8Array(b);
          Module["HEAP16"] = HEAP16 = new Int16Array(b);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
          Module["HEAP32"] = HEAP32 = new Int32Array(b);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
          Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
          Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
        }
        __name(updateMemoryViews, "updateMemoryViews");
        if (Module["wasmMemory"]) {
          wasmMemory = Module["wasmMemory"];
        } else {
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          wasmMemory = new WebAssembly.Memory({
            initial: INITIAL_MEMORY / 65536,
            maximum: 32768
          });
        }
        updateMemoryViews();
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        function preRun() {
          var preRuns = Module["preRun"];
          if (preRuns) {
            if (typeof preRuns == "function") preRuns = [preRuns];
            preRuns.forEach(addOnPreRun);
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        __name(preRun, "preRun");
        function initRuntime() {
          runtimeInitialized = true;
          if (!Module["noFSInit"] && !FS.initialized) FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          callRuntimeCallbacks(__ATINIT__);
        }
        __name(initRuntime, "initRuntime");
        function postRun() {
          var postRuns = Module["postRun"];
          if (postRuns) {
            if (typeof postRuns == "function") postRuns = [postRuns];
            postRuns.forEach(addOnPostRun);
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        __name(postRun, "postRun");
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        __name(addOnPreRun, "addOnPreRun");
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        __name(addOnInit, "addOnInit");
        function addOnExit(cb) {
        }
        __name(addOnExit, "addOnExit");
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        __name(addOnPostRun, "addOnPostRun");
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        __name(getUniqueRunDependency, "getUniqueRunDependency");
        function addRunDependency(id) {
          runDependencies++;
          Module["monitorRunDependencies"]?.(runDependencies);
        }
        __name(addRunDependency, "addRunDependency");
        function removeRunDependency(id) {
          runDependencies--;
          Module["monitorRunDependencies"]?.(runDependencies);
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        __name(removeRunDependency, "removeRunDependency");
        function abort22(what) {
          Module["onAbort"]?.(what);
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          what += ". Build with -sASSERTIONS for more info.";
          var e3 = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e3);
          throw e3;
        }
        __name(abort22, "abort2");
        var dataURIPrefix = "data:application/octet-stream;base64,";
        var isDataURI = /* @__PURE__ */ __name((filename) => filename.startsWith(dataURIPrefix), "isDataURI");
        var isFileURI = /* @__PURE__ */ __name((filename) => filename.startsWith("file://"), "isFileURI");
        function findWasmBinary() {
          if (Module["locateFile"]) {
            var f = "sqlite3.wasm";
            if (!isDataURI(f)) {
              return locateFile(f);
            }
            return f;
          }
          return new URL("sqlite3.wasm", import.meta.url).href;
        }
        __name(findWasmBinary, "findWasmBinary");
        var wasmBinaryFile;
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        __name(getBinarySync, "getBinarySync");
        function getBinaryPromise(binaryFile) {
          if (!wasmBinary) {
            return readAsync(binaryFile).then(
              (response) => new Uint8Array(response),
              () => getBinarySync(binaryFile)
            );
          }
          return Promise.resolve().then(() => getBinarySync(binaryFile));
        }
        __name(getBinaryPromise, "getBinaryPromise");
        function instantiateArrayBuffer(binaryFile, imports4, receiver) {
          return getBinaryPromise(binaryFile).then((binary) => {
            return WebAssembly.instantiate(binary, imports4);
          }).then(receiver, (reason) => {
            err(`failed to asynchronously prepare wasm: ${reason}`);
            abort22(reason);
          });
        }
        __name(instantiateArrayBuffer, "instantiateArrayBuffer");
        function instantiateAsync(binary, binaryFile, imports4, callback) {
          if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
            return fetch(binaryFile, { credentials: "same-origin" }).then(
              (response) => {
                var result = WebAssembly.instantiateStreaming(response, imports4);
                return result.then(callback, function(reason) {
                  err(`wasm streaming compile failed: ${reason}`);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports4, callback);
                });
              }
            );
          }
          return instantiateArrayBuffer(binaryFile, imports4, callback);
        }
        __name(instantiateAsync, "instantiateAsync");
        function getWasmImports() {
          return {
            env: wasmImports,
            wasi_snapshot_preview1: wasmImports
          };
        }
        __name(getWasmImports, "getWasmImports");
        function createWasm() {
          var info3 = getWasmImports();
          function receiveInstance(instance, module) {
            wasmExports = instance.exports;
            addOnInit(wasmExports["__wasm_call_ctors"]);
            removeRunDependency("wasm-instantiate");
            return wasmExports;
          }
          __name(receiveInstance, "receiveInstance");
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          __name(receiveInstantiationResult, "receiveInstantiationResult");
          if (Module["instantiateWasm"]) {
            try {
              return Module["instantiateWasm"](info3, receiveInstance);
            } catch (e3) {
              err(`Module.instantiateWasm callback failed with error: ${e3}`);
              readyPromiseReject(e3);
            }
          }
          wasmBinaryFile ??= findWasmBinary();
          instantiateAsync(
            wasmBinary,
            wasmBinaryFile,
            info3,
            receiveInstantiationResult
          ).catch(readyPromiseReject);
          return {};
        }
        __name(createWasm, "createWasm");
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
        __name(ExitStatus, "ExitStatus");
        var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {
          callbacks.forEach((f) => f(Module));
        }, "callRuntimeCallbacks");
        function getValue(ptr, type = "i8") {
          if (type.endsWith("*")) type = "*";
          switch (type) {
            case "i1":
              return HEAP8[ptr];
            case "i8":
              return HEAP8[ptr];
            case "i16":
              return HEAP16[ptr >> 1];
            case "i32":
              return HEAP32[ptr >> 2];
            case "i64":
              return HEAP64[ptr >> 3];
            case "float":
              return HEAPF32[ptr >> 2];
            case "double":
              return HEAPF64[ptr >> 3];
            case "*":
              return HEAPU32[ptr >> 2];
            default:
              abort22(`invalid type for getValue: ${type}`);
          }
        }
        __name(getValue, "getValue");
        var noExitRuntime = Module["noExitRuntime"] || true;
        function setValue(ptr, value, type = "i8") {
          if (type.endsWith("*")) type = "*";
          switch (type) {
            case "i1":
              HEAP8[ptr] = value;
              break;
            case "i8":
              HEAP8[ptr] = value;
              break;
            case "i16":
              HEAP16[ptr >> 1] = value;
              break;
            case "i32":
              HEAP32[ptr >> 2] = value;
              break;
            case "i64":
              HEAP64[ptr >> 3] = BigInt(value);
              break;
            case "float":
              HEAPF32[ptr >> 2] = value;
              break;
            case "double":
              HEAPF64[ptr >> 3] = value;
              break;
            case "*":
              HEAPU32[ptr >> 2] = value;
              break;
            default:
              abort22(`invalid type for setValue: ${type}`);
          }
        }
        __name(setValue, "setValue");
        var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), "stackRestore");
        var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), "stackSave");
        var PATH = {
          isAbs: /* @__PURE__ */ __name((path) => path.charAt(0) === "/", "isAbs"),
          splitPath: /* @__PURE__ */ __name((filename) => {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, "splitPath"),
          normalizeArray: /* @__PURE__ */ __name((parts, allowAboveRoot) => {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, "normalizeArray"),
          normalize: /* @__PURE__ */ __name((path) => {
            var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(
              path.split("/").filter((p) => !!p),
              !isAbsolute
            ).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, "normalize"),
          dirname: /* @__PURE__ */ __name((path) => {
            var result = PATH.splitPath(path), root2 = result[0], dir3 = result[1];
            if (!root2 && !dir3) {
              return ".";
            }
            if (dir3) {
              dir3 = dir3.substr(0, dir3.length - 1);
            }
            return root2 + dir3;
          }, "dirname"),
          basename: /* @__PURE__ */ __name((path) => {
            if (path === "/") return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1) return path;
            return path.substr(lastSlash + 1);
          }, "basename"),
          join: /* @__PURE__ */ __name((...paths) => PATH.normalize(paths.join("/")), "join"),
          join2: /* @__PURE__ */ __name((l, r3) => PATH.normalize(l + "/" + r3), "join2")
        };
        var initRandomFill = /* @__PURE__ */ __name(() => {
          if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
            return (view) => crypto.getRandomValues(view);
          } else abort22("initRandomDevice");
        }, "initRandomFill");
        var randomFill = /* @__PURE__ */ __name((view) => {
          return (randomFill = initRandomFill())(view);
        }, "randomFill");
        var PATH_FS = {
          resolve: /* @__PURE__ */ __name((...args) => {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? args[i] : FS.cwd();
              if (typeof path != "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path);
            }
            resolvedPath = PATH.normalizeArray(
              resolvedPath.split("/").filter((p) => !!p),
              !resolvedAbsolute
            ).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, "resolve"),
          relative: /* @__PURE__ */ __name((from, to) => {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            __name(trim, "trim");
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          }, "relative")
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
        var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(
                55296 | ch >> 10,
                56320 | ch & 1023
              );
            }
          }
          return str;
        }, "UTF8ArrayToString");
        var FS_stdin_getChar_buffer = [];
        var lengthBytesUTF8 = /* @__PURE__ */ __name((str) => {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var c2 = str.charCodeAt(i);
            if (c2 <= 127) {
              len++;
            } else if (c2 <= 2047) {
              len += 2;
            } else if (c2 >= 55296 && c2 <= 57343) {
              len += 4;
              ++i;
            } else {
              len += 3;
            }
          }
          return len;
        }, "lengthBytesUTF8");
        var stringToUTF8Array = /* @__PURE__ */ __name((str, heap, outIdx, maxBytesToWrite) => {
          if (!(maxBytesToWrite > 0)) return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) break;
              heap[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++] = 192 | u >> 6;
              heap[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++] = 224 | u >> 12;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++] = 240 | u >> 18;
              heap[outIdx++] = 128 | u >> 12 & 63;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }, "stringToUTF8Array");
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(
            stringy,
            u8array,
            0,
            u8array.length
          );
          if (dontAddNull) u8array.length = numBytesWritten;
          return u8array;
        }
        __name(intArrayFromString, "intArrayFromString");
        var FS_stdin_getChar = /* @__PURE__ */ __name(() => {
          if (!FS_stdin_getChar_buffer.length) {
            var result = null;
            if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else {
            }
            if (!result) {
              return null;
            }
            FS_stdin_getChar_buffer = intArrayFromString(result, true);
          }
          return FS_stdin_getChar_buffer.shift();
        }, "FS_stdin_getChar");
        var TTY = {
          ttys: [],
          init() {
          },
          shutdown() {
          },
          register(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          },
          stream_ops: {
            open(stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            },
            close(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            fsync(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            read(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = stream.tty.ops.get_char(stream.tty);
                } catch (e3) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0) break;
                bytesRead++;
                buffer[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            },
            write(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i = 0; i < length; i++) {
                  stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                }
              } catch (e3) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            }
          },
          default_tty_ops: {
            get_char(tty) {
              return FS_stdin_getChar();
            },
            put_char(tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                out(UTF8ArrayToString(tty.output));
                tty.output = [];
              }
            },
            ioctl_tcgets(tty) {
              return {
                c_iflag: 25856,
                c_oflag: 5,
                c_cflag: 191,
                c_lflag: 35387,
                c_cc: [
                  3,
                  28,
                  127,
                  21,
                  4,
                  0,
                  1,
                  0,
                  17,
                  19,
                  26,
                  0,
                  18,
                  15,
                  23,
                  22,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                ]
              };
            },
            ioctl_tcsets(tty, optional_actions, data) {
              return 0;
            },
            ioctl_tiocgwinsz(tty) {
              return [24, 80];
            }
          },
          default_tty1_ops: {
            put_char(tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            },
            fsync(tty) {
              if (tty.output && tty.output.length > 0) {
                err(UTF8ArrayToString(tty.output));
                tty.output = [];
              }
            }
          }
        };
        var zeroMemory = /* @__PURE__ */ __name((address, size) => {
          HEAPU8.fill(0, address, address + size);
        }, "zeroMemory");
        var alignMemory = /* @__PURE__ */ __name((size, alignment) => {
          return Math.ceil(size / alignment) * alignment;
        }, "alignMemory");
        var mmapAlloc = /* @__PURE__ */ __name((size) => {
          size = alignMemory(size, 65536);
          var ptr = _emscripten_builtin_memalign(65536, size);
          if (ptr) zeroMemory(ptr, size);
          return ptr;
        }, "mmapAlloc");
        var MEMFS = {
          ops_table: null,
          mount(mount2) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          },
          createNode(parent, name, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            MEMFS.ops_table ||= {
              dir: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  lookup: MEMFS.node_ops.lookup,
                  mknod: MEMFS.node_ops.mknod,
                  rename: MEMFS.node_ops.rename,
                  unlink: MEMFS.node_ops.unlink,
                  rmdir: MEMFS.node_ops.rmdir,
                  readdir: MEMFS.node_ops.readdir,
                  symlink: MEMFS.node_ops.symlink
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek
                }
              },
              file: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek,
                  read: MEMFS.stream_ops.read,
                  write: MEMFS.stream_ops.write,
                  allocate: MEMFS.stream_ops.allocate,
                  mmap: MEMFS.stream_ops.mmap,
                  msync: MEMFS.stream_ops.msync
                }
              },
              link: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  readlink: MEMFS.node_ops.readlink
                },
                stream: {}
              },
              chrdev: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: FS.chrdev_stream_ops
              }
            };
            var node = FS.createNode(parent, name, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          },
          getFileDataAsTypedArray(node) {
            if (!node.contents) return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          },
          expandFileStorage(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(
              newCapacity,
              prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
            );
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          },
          resizeFileStorage(node, newSize) {
            if (node.usedBytes == newSize) return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(
                  oldContents.subarray(0, Math.min(newSize, node.usedBytes))
                );
              }
              node.usedBytes = newSize;
            }
          },
          node_ops: {
            getattr(node) {
              var attr2 = {};
              attr2.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr2.ino = node.id;
              attr2.mode = node.mode;
              attr2.nlink = 1;
              attr2.uid = 0;
              attr2.gid = 0;
              attr2.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr2.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr2.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr2.size = node.link.length;
              } else {
                attr2.size = 0;
              }
              attr2.atime = new Date(node.timestamp);
              attr2.mtime = new Date(node.timestamp);
              attr2.ctime = new Date(node.timestamp);
              attr2.blksize = 4096;
              attr2.blocks = Math.ceil(attr2.size / attr2.blksize);
              return attr2;
            },
            setattr(node, attr2) {
              if (attr2.mode !== void 0) {
                node.mode = attr2.mode;
              }
              if (attr2.timestamp !== void 0) {
                node.timestamp = attr2.timestamp;
              }
              if (attr2.size !== void 0) {
                MEMFS.resizeFileStorage(node, attr2.size);
              }
            },
            lookup(parent, name) {
              throw FS.genericErrors[44];
            },
            mknod(parent, name, mode, dev) {
              return MEMFS.createNode(parent, name, mode, dev);
            },
            rename(old_node, new_dir, new_name) {
              if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                  new_node = FS.lookupNode(new_dir, new_name);
                } catch (e3) {
                }
                if (new_node) {
                  for (var i in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
              }
              delete old_node.parent.contents[old_node.name];
              old_node.parent.timestamp = Date.now();
              old_node.name = new_name;
              new_dir.contents[new_name] = old_node;
              new_dir.timestamp = old_node.parent.timestamp;
            },
            unlink(parent, name) {
              delete parent.contents[name];
              parent.timestamp = Date.now();
            },
            rmdir(parent, name) {
              var node = FS.lookupNode(parent, name);
              for (var i in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name];
              parent.timestamp = Date.now();
            },
            readdir(node) {
              var entries = [".", ".."];
              for (var key2 of Object.keys(node.contents)) {
                entries.push(key2);
              }
              return entries;
            },
            symlink(parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            },
            readlink(node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            }
          },
          stream_ops: {
            read(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes) return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i = 0; i < size; i++)
                  buffer[offset + i] = contents[position + i];
              }
              return size;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              if (buffer.buffer === HEAP8.buffer) {
                canOwn = false;
              }
              if (!length) return 0;
              var node = stream.node;
              node.timestamp = Date.now();
              if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  node.contents = buffer.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(
                    buffer.subarray(offset, offset + length),
                    position
                  );
                  return length;
                }
              }
              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer.subarray) {
                node.contents.set(
                  buffer.subarray(offset, offset + length),
                  position
                );
              } else {
                for (var i = 0; i < length; i++) {
                  node.contents[position + i] = buffer[offset + i];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            },
            llseek(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            },
            allocate(stream, offset, length) {
              MEMFS.expandFileStorage(stream.node, offset + length);
              stream.node.usedBytes = Math.max(
                stream.node.usedBytes,
                offset + length
              );
            },
            mmap(stream, length, position, prot, flags2) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr;
              var allocated;
              var contents = stream.node.contents;
              if (!(flags2 & 2) && contents && contents.buffer === HEAP8.buffer) {
                allocated = false;
                ptr = contents.byteOffset;
              } else {
                allocated = true;
                ptr = mmapAlloc(length);
                if (!ptr) {
                  throw new FS.ErrnoError(48);
                }
                if (contents) {
                  if (position > 0 || position + length < contents.length) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length);
                    } else {
                      contents = Array.prototype.slice.call(
                        contents,
                        position,
                        position + length
                      );
                    }
                  }
                  HEAP8.set(contents, ptr);
                }
              }
              return { ptr, allocated };
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
              return 0;
            }
          }
        };
        var asyncLoad = /* @__PURE__ */ __name((url, onload, onerror, noRunDep) => {
          var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
          readAsync(url).then(
            (arrayBuffer) => {
              onload(new Uint8Array(arrayBuffer));
              if (dep) removeRunDependency(dep);
            },
            (err2) => {
              if (onerror) {
                onerror();
              } else {
                throw `Loading data file "${url}" failed.`;
              }
            }
          );
          if (dep) addRunDependency(dep);
        }, "asyncLoad");
        var FS_createDataFile = /* @__PURE__ */ __name((parent, name, fileData, canRead, canWrite, canOwn) => {
          FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
        }, "FS_createDataFile");
        var preloadPlugins = Module["preloadPlugins"] || [];
        var FS_handledByPreloadPlugin = /* @__PURE__ */ __name((byteArray, fullname, finish, onerror) => {
          if (typeof Browser != "undefined") Browser.init();
          var handled = false;
          preloadPlugins.forEach((plugin) => {
            if (handled) return;
            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, onerror);
              handled = true;
            }
          });
          return handled;
        }, "FS_handledByPreloadPlugin");
        var FS_createPreloadedFile = /* @__PURE__ */ __name((parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
          var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
          var dep = getUniqueRunDependency(`cp ${fullname}`);
          function processData(byteArray) {
            function finish(byteArray2) {
              preFinish?.();
              if (!dontCreateFile) {
                FS_createDataFile(
                  parent,
                  name,
                  byteArray2,
                  canRead,
                  canWrite,
                  canOwn
                );
              }
              onload?.();
              removeRunDependency(dep);
            }
            __name(finish, "finish");
            if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
              onerror?.();
              removeRunDependency(dep);
            })) {
              return;
            }
            finish(byteArray);
          }
          __name(processData, "processData");
          addRunDependency(dep);
          if (typeof url == "string") {
            asyncLoad(url, processData, onerror);
          } else {
            processData(url);
          }
        }, "FS_createPreloadedFile");
        var FS_modeStringToFlags = /* @__PURE__ */ __name((str) => {
          var flagModes = {
            r: 0,
            "r+": 2,
            w: 512 | 64 | 1,
            "w+": 512 | 64 | 2,
            a: 1024 | 64 | 1,
            "a+": 1024 | 64 | 2
          };
          var flags2 = flagModes[str];
          if (typeof flags2 == "undefined") {
            throw new Error(`Unknown file open mode: ${str}`);
          }
          return flags2;
        }, "FS_modeStringToFlags");
        var FS_getMode = /* @__PURE__ */ __name((canRead, canWrite) => {
          var mode = 0;
          if (canRead) mode |= 292 | 73;
          if (canWrite) mode |= 146;
          return mode;
        }, "FS_getMode");
        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: "/",
          initialized: false,
          ignorePermissions: true,
          ErrnoError: class {
            static {
              __name(this, "ErrnoError");
            }
            constructor(errno) {
              this.name = "ErrnoError";
              this.errno = errno;
            }
          },
          genericErrors: {},
          filesystems: null,
          syncFSRequests: 0,
          readFiles: {},
          FSStream: class {
            static {
              __name(this, "FSStream");
            }
            constructor() {
              this.shared = {};
            }
            get object() {
              return this.node;
            }
            set object(val) {
              this.node = val;
            }
            get isRead() {
              return (this.flags & 2097155) !== 1;
            }
            get isWrite() {
              return (this.flags & 2097155) !== 0;
            }
            get isAppend() {
              return this.flags & 1024;
            }
            get flags() {
              return this.shared.flags;
            }
            set flags(val) {
              this.shared.flags = val;
            }
            get position() {
              return this.shared.position;
            }
            set position(val) {
              this.shared.position = val;
            }
          },
          FSNode: class {
            static {
              __name(this, "FSNode");
            }
            constructor(parent, name, mode, rdev) {
              if (!parent) {
                parent = this;
              }
              this.parent = parent;
              this.mount = parent.mount;
              this.mounted = null;
              this.id = FS.nextInode++;
              this.name = name;
              this.mode = mode;
              this.node_ops = {};
              this.stream_ops = {};
              this.rdev = rdev;
              this.readMode = 292 | 73;
              this.writeMode = 146;
            }
            get read() {
              return (this.mode & this.readMode) === this.readMode;
            }
            set read(val) {
              val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
            }
            get write() {
              return (this.mode & this.writeMode) === this.writeMode;
            }
            set write(val) {
              val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
            }
            get isFolder() {
              return FS.isDir(this.mode);
            }
            get isDevice() {
              return FS.isChrdev(this.mode);
            }
          },
          lookupPath(path, opts = {}) {
            path = PATH_FS.resolve(path);
            if (!path) return { path: "", node: null };
            var defaults = {
              follow_mount: true,
              recurse_count: 0
            };
            opts = Object.assign(defaults, opts);
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = path.split("/").filter((p) => !!p);
            var current2 = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current2 = FS.lookupNode(current2, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current2)) {
                if (!islast || islast && opts.follow_mount) {
                  current2 = current2.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count3 = 0;
                while (FS.isLink(current2.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, {
                    recurse_count: opts.recurse_count + 1
                  });
                  current2 = lookup.node;
                  if (count3++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current2 };
          },
          getPath(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount2 = node.mount.mountpoint;
                if (!path) return mount2;
                return mount2[mount2.length - 1] !== "/" ? `${mount2}/${path}` : mount2 + path;
              }
              path = path ? `${node.name}/${path}` : node.name;
              node = node.parent;
            }
          },
          hashName(parentid, name) {
            var hash2 = 0;
            for (var i = 0; i < name.length; i++) {
              hash2 = (hash2 << 5) - hash2 + name.charCodeAt(i) | 0;
            }
            return (parentid + hash2 >>> 0) % FS.nameTable.length;
          },
          hashAddNode(node) {
            var hash2 = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash2];
            FS.nameTable[hash2] = node;
          },
          hashRemoveNode(node) {
            var hash2 = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash2] === node) {
              FS.nameTable[hash2] = node.name_next;
            } else {
              var current2 = FS.nameTable[hash2];
              while (current2) {
                if (current2.name_next === node) {
                  current2.name_next = node.name_next;
                  break;
                }
                current2 = current2.name_next;
              }
            }
          },
          lookupNode(parent, name) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            var hash2 = FS.hashName(parent.id, name);
            for (var node = FS.nameTable[hash2]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name) {
                return node;
              }
            }
            return FS.lookup(parent, name);
          },
          createNode(parent, name, mode, rdev) {
            var node = new FS.FSNode(parent, name, mode, rdev);
            FS.hashAddNode(node);
            return node;
          },
          destroyNode(node) {
            FS.hashRemoveNode(node);
          },
          isRoot(node) {
            return node === node.parent;
          },
          isMountpoint(node) {
            return !!node.mounted;
          },
          isFile(mode) {
            return (mode & 61440) === 32768;
          },
          isDir(mode) {
            return (mode & 61440) === 16384;
          },
          isLink(mode) {
            return (mode & 61440) === 40960;
          },
          isChrdev(mode) {
            return (mode & 61440) === 8192;
          },
          isBlkdev(mode) {
            return (mode & 61440) === 24576;
          },
          isFIFO(mode) {
            return (mode & 61440) === 4096;
          },
          isSocket(mode) {
            return (mode & 49152) === 49152;
          },
          flagsToPermissionString(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          },
          nodePermissions(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          },
          mayLookup(dir3) {
            if (!FS.isDir(dir3.mode)) return 54;
            var errCode = FS.nodePermissions(dir3, "x");
            if (errCode) return errCode;
            if (!dir3.node_ops.lookup) return 2;
            return 0;
          },
          mayCreate(dir3, name) {
            try {
              var node = FS.lookupNode(dir3, name);
              return 20;
            } catch (e3) {
            }
            return FS.nodePermissions(dir3, "wx");
          },
          mayDelete(dir3, name, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir3, name);
            } catch (e3) {
              return e3.errno;
            }
            var errCode = FS.nodePermissions(dir3, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          },
          mayOpen(node, flags2) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags2) !== "r" || flags2 & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags2));
          },
          MAX_OPEN_FDS: 4096,
          nextfd() {
            for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          },
          getStreamChecked(fd) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            return stream;
          },
          getStream: /* @__PURE__ */ __name((fd) => FS.streams[fd], "getStream"),
          createStream(stream, fd = -1) {
            stream = Object.assign(new FS.FSStream(), stream);
            if (fd == -1) {
              fd = FS.nextfd();
            }
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          },
          closeStream(fd) {
            FS.streams[fd] = null;
          },
          dupStream(origStream, fd = -1) {
            var stream = FS.createStream(origStream, fd);
            stream.stream_ops?.dup?.(stream);
            return stream;
          },
          chrdev_stream_ops: {
            open(stream) {
              var device = FS.getDevice(stream.node.rdev);
              stream.stream_ops = device.stream_ops;
              stream.stream_ops.open?.(stream);
            },
            llseek() {
              throw new FS.ErrnoError(70);
            }
          },
          major: /* @__PURE__ */ __name((dev) => dev >> 8, "major"),
          minor: /* @__PURE__ */ __name((dev) => dev & 255, "minor"),
          makedev: /* @__PURE__ */ __name((ma, mi) => ma << 8 | mi, "makedev"),
          registerDevice(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          },
          getDevice: /* @__PURE__ */ __name((dev) => FS.devices[dev], "getDevice"),
          getMounts(mount2) {
            var mounts = [];
            var check = [mount2];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push(...m.mounts);
            }
            return mounts;
          },
          syncfs(populate, callback) {
            if (typeof populate == "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err(
                `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
              );
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            __name(doCallback, "doCallback");
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            __name(done, "done");
            mounts.forEach((mount2) => {
              if (!mount2.type.syncfs) {
                return done(null);
              }
              mount2.type.syncfs(mount2, populate, done);
            });
          },
          mount(type, opts, mountpoint) {
            var root2 = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root2 && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root2 && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount2 = {
              type,
              opts,
              mountpoint,
              mounts: []
            };
            var mountRoot = type.mount(mount2);
            mountRoot.mount = mount2;
            mount2.root = mountRoot;
            if (root2) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount2;
              if (node.mount) {
                node.mount.mounts.push(mount2);
              }
            }
            return mountRoot;
          },
          unmount(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount2 = node.mounted;
            var mounts = FS.getMounts(mount2);
            Object.keys(FS.nameTable).forEach((hash2) => {
              var current2 = FS.nameTable[hash2];
              while (current2) {
                var next2 = current2.name_next;
                if (mounts.includes(current2.mount)) {
                  FS.destroyNode(current2);
                }
                current2 = next2;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount2);
            node.mount.mounts.splice(idx, 1);
          },
          lookup(parent, name) {
            return parent.node_ops.lookup(parent, name);
          },
          mknod(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            if (!name || name === "." || name === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name, mode, dev);
          },
          create(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          },
          mkdir(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          },
          mkdirTree(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i]) continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e3) {
                if (e3.errno != 20) throw e3;
              }
            }
          },
          mkdev(path, mode, dev) {
            if (typeof dev == "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          },
          symlink(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          },
          rename(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative2 = PATH_FS.relative(old_path, new_dirname);
            if (relative2.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative2 = PATH_FS.relative(new_path, old_dirname);
            if (relative2.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e3) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
              old_node.parent = new_dir;
            } catch (e3) {
              throw e3;
            } finally {
              FS.hashAddNode(old_node);
            }
          },
          rmdir(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name);
            FS.destroyNode(node);
          },
          readdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          },
          unlink(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name);
            FS.destroyNode(node);
          },
          readlink(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(
              FS.getPath(link.parent),
              link.node_ops.readlink(link)
            );
          },
          stat(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          },
          lstat(path) {
            return FS.stat(path, true);
          },
          chmod(path, mode, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              mode: mode & 4095 | node.mode & ~4095,
              timestamp: Date.now()
            });
          },
          lchmod(path, mode) {
            FS.chmod(path, mode, true);
          },
          fchmod(fd, mode) {
            var stream = FS.getStreamChecked(fd);
            FS.chmod(stream.node, mode);
          },
          chown(path, uid, gid, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              timestamp: Date.now()
            });
          },
          lchown(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          },
          fchown(fd, uid, gid) {
            var stream = FS.getStreamChecked(fd);
            FS.chown(stream.node, uid, gid);
          },
          truncate(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, {
              size: len,
              timestamp: Date.now()
            });
          },
          ftruncate(fd, len) {
            var stream = FS.getStreamChecked(fd);
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          },
          utime(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, {
              timestamp: Math.max(atime, mtime)
            });
          },
          open(path, flags2, mode) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags2 = typeof flags2 == "string" ? FS_modeStringToFlags(flags2) : flags2;
            if (flags2 & 64) {
              mode = typeof mode == "undefined" ? 438 : mode;
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path == "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, {
                  follow: !(flags2 & 131072)
                });
                node = lookup.node;
              } catch (e3) {
              }
            }
            var created = false;
            if (flags2 & 64) {
              if (node) {
                if (flags2 & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags2 &= ~512;
            }
            if (flags2 & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags2);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags2 & 512 && !created) {
              FS.truncate(node, 0);
            }
            flags2 &= ~(128 | 512 | 131072);
            var stream = FS.createStream({
              node,
              path: FS.getPath(node),
              flags: flags2,
              seekable: true,
              position: 0,
              stream_ops: node.stream_ops,
              ungotten: [],
              error: false
            });
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags2 & 1)) {
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
              }
            }
            return stream;
          },
          close(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents) stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e3) {
              throw e3;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          },
          isClosed(stream) {
            return stream.fd === null;
          },
          llseek(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          },
          read(stream, buffer, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(
              stream,
              buffer,
              offset,
              length,
              position
            );
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          },
          write(stream, buffer, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(
              stream,
              buffer,
              offset,
              length,
              position,
              canOwn
            );
            if (!seeking) stream.position += bytesWritten;
            return bytesWritten;
          },
          allocate(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          },
          mmap(stream, length, position, prot, flags2) {
            if ((prot & 2) !== 0 && (flags2 & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            if (!length) {
              throw new FS.ErrnoError(28);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags2);
          },
          msync(stream, buffer, offset, length, mmapFlags) {
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(
              stream,
              buffer,
              offset,
              length,
              mmapFlags
            );
          },
          ioctl(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          },
          readFile(path, opts = {}) {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error(`Invalid encoding type "${opts.encoding}"`);
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          },
          writeFile(path, data, opts = {}) {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data == "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          },
          cwd: /* @__PURE__ */ __name(() => FS.currentPath, "cwd"),
          chdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          },
          createDefaultDirectories() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          },
          createDefaultDevices() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), {
              read: /* @__PURE__ */ __name(() => 0, "read"),
              write: /* @__PURE__ */ __name((stream, buffer, offset, length, pos) => length, "write")
            });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var randomBuffer = new Uint8Array(1024), randomLeft = 0;
            var randomByte = /* @__PURE__ */ __name(() => {
              if (randomLeft === 0) {
                randomLeft = randomFill(randomBuffer).byteLength;
              }
              return randomBuffer[--randomLeft];
            }, "randomByte");
            FS.createDevice("/dev", "random", randomByte);
            FS.createDevice("/dev", "urandom", randomByte);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          },
          createSpecialDirectories() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount(
              {
                mount() {
                  var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
                  node.node_ops = {
                    lookup(parent, name) {
                      var fd = +name;
                      var stream = FS.getStreamChecked(fd);
                      var ret = {
                        parent: null,
                        mount: { mountpoint: "fake" },
                        node_ops: { readlink: /* @__PURE__ */ __name(() => stream.path, "readlink") }
                      };
                      ret.parent = ret;
                      return ret;
                    }
                  };
                  return node;
                }
              },
              {},
              "/proc/self/fd"
            );
          },
          createStandardStreams(input, output, error22) {
            if (input) {
              FS.createDevice("/dev", "stdin", input);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (output) {
              FS.createDevice("/dev", "stdout", null, output);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (error22) {
              FS.createDevice("/dev", "stderr", null, error22);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin2 = FS.open("/dev/stdin", 0);
            var stdout2 = FS.open("/dev/stdout", 1);
            var stderr2 = FS.open("/dev/stderr", 1);
          },
          staticInit() {
            [44].forEach((code) => {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = {
              MEMFS
            };
          },
          init(input, output, error22) {
            FS.initialized = true;
            input ??= Module["stdin"];
            output ??= Module["stdout"];
            error22 ??= Module["stderr"];
            FS.createStandardStreams(input, output, error22);
          },
          quit() {
            FS.initialized = false;
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          },
          findObject(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          },
          analyzePath(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e3) {
            }
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null
            };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e3) {
              ret.error = e3.errno;
            }
            return ret;
          },
          createPath(parent, path, canRead, canWrite) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part) continue;
              var current2 = PATH.join2(parent, part);
              try {
                FS.mkdir(current2);
              } catch (e3) {
              }
              parent = current2;
            }
            return current2;
          },
          createFile(parent, name, properties, canRead, canWrite) {
            var path = PATH.join2(
              typeof parent == "string" ? parent : FS.getPath(parent),
              name
            );
            var mode = FS_getMode(canRead, canWrite);
            return FS.create(path, mode);
          },
          createDataFile(parent, name, data, canRead, canWrite, canOwn) {
            var path = name;
            if (parent) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              path = name ? PATH.join2(parent, name) : parent;
            }
            var mode = FS_getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data == "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
          },
          createDevice(parent, name, input, output) {
            var path = PATH.join2(
              typeof parent == "string" ? parent : FS.getPath(parent),
              name
            );
            var mode = FS_getMode(!!input, !!output);
            FS.createDevice.major ??= 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, {
              open(stream) {
                stream.seekable = false;
              },
              close(stream) {
                if (output?.buffer?.length) {
                  output(10);
                }
              },
              read(stream, buffer, offset, length, pos) {
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result;
                  try {
                    result = input();
                  } catch (e3) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === void 0) break;
                  bytesRead++;
                  buffer[offset + i] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                for (var i = 0; i < length; i++) {
                  try {
                    output(buffer[offset + i]);
                  } catch (e3) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i;
              }
            });
            return FS.mkdev(path, mode, dev);
          },
          forceLoadFile(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest != "undefined") {
              throw new Error(
                "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
              );
            } else {
              try {
                obj.contents = readBinary(obj.url);
                obj.usedBytes = obj.contents.length;
              } catch (e3) {
                throw new FS.ErrnoError(29);
              }
            }
          },
          createLazyFile(parent, name, url, canRead, canWrite) {
            class LazyUint8Array {
              static {
                __name(this, "LazyUint8Array");
              }
              constructor() {
                this.lengthKnown = false;
                this.chunks = [];
              }
              get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return void 0;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset];
              }
              setDataGetter(getter) {
                this.getter = getter;
              }
              cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", url, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                  throw new Error(
                    "Couldn't load " + url + ". Status: " + xhr.status
                  );
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing) chunkSize = datalength;
                var doXHR = /* @__PURE__ */ __name((from, to) => {
                  if (from > to)
                    throw new Error(
                      "invalid range (" + from + ", " + to + ") or no bytes requested!"
                    );
                  if (to > datalength - 1)
                    throw new Error(
                      "only " + datalength + " bytes available! programmer error!"
                    );
                  var xhr2 = new XMLHttpRequest();
                  xhr2.open("GET", url, false);
                  if (datalength !== chunkSize)
                    xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  xhr2.responseType = "arraybuffer";
                  if (xhr2.overrideMimeType) {
                    xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                  }
                  xhr2.send(null);
                  if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                    throw new Error(
                      "Couldn't load " + url + ". Status: " + xhr2.status
                    );
                  if (xhr2.response !== void 0) {
                    return new Uint8Array(xhr2.response || []);
                  }
                  return intArrayFromString(xhr2.responseText || "", true);
                }, "doXHR");
                var lazyArray2 = this;
                lazyArray2.setDataGetter((chunkNum) => {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                    lazyArray2.chunks[chunkNum] = doXHR(start, end);
                  }
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                    throw new Error("doXHR failed!");
                  return lazyArray2.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out(
                    "LazyFiles on gzip forces download of the whole file when length is accessed"
                  );
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              }
              get length() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
              get chunkSize() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
            if (typeof XMLHttpRequest != "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, {
              usedBytes: {
                get: /* @__PURE__ */ __name(function() {
                  return this.contents.length;
                }, "get")
              }
            });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key2) => {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = (...args) => {
                FS.forceLoadFile(node);
                return fn(...args);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length) return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents.get(position + i);
                }
              }
              return size;
            }
            __name(writeChunks, "writeChunks");
            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };
            stream_ops.mmap = (stream, length, position, prot, flags2) => {
              FS.forceLoadFile(node);
              var ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr, length, position);
              return { ptr, allocated: true };
            };
            node.stream_ops = stream_ops;
            return node;
          }
        };
        var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }, "UTF8ToString");
        var SYSCALLS = {
          DEFAULT_POLLMASK: 5,
          calculateAt(dirfd, path, allowEmpty) {
            if (PATH.isAbs(path)) {
              return path;
            }
            var dir3;
            if (dirfd === -100) {
              dir3 = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir3 = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir3;
            }
            return PATH.join2(dir3, path);
          },
          doStat(func, path, buf) {
            var stat = func(path);
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[buf + 4 >> 2] = stat.mode;
            HEAPU32[buf + 8 >> 2] = stat.nlink;
            HEAP32[buf + 12 >> 2] = stat.uid;
            HEAP32[buf + 16 >> 2] = stat.gid;
            HEAP32[buf + 20 >> 2] = stat.rdev;
            HEAP64[buf + 24 >> 3] = BigInt(stat.size);
            HEAP32[buf + 32 >> 2] = 4096;
            HEAP32[buf + 36 >> 2] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
            HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
            HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
            HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
            return 0;
          },
          doMsync(addr, stream, len, flags2, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags2 & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer, offset, len, flags2);
          },
          getStreamFromFD(fd) {
            var stream = FS.getStreamChecked(fd);
            return stream;
          },
          varargs: void 0,
          getStr(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }
        };
        function ___syscall_chmod(path, mode) {
          try {
            path = SYSCALLS.getStr(path);
            FS.chmod(path, mode);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_chmod, "___syscall_chmod");
        function ___syscall_faccessat(dirfd, path, amode, flags2) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (amode & ~7) {
              return -28;
            }
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4) perms += "r";
            if (amode & 2) perms += "w";
            if (amode & 1) perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_faccessat, "___syscall_faccessat");
        function ___syscall_fchmod(fd, mode) {
          try {
            FS.fchmod(fd, mode);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_fchmod, "___syscall_fchmod");
        function ___syscall_fchown32(fd, owner, group3) {
          try {
            FS.fchown(fd, owner, group3);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_fchown32, "___syscall_fchown32");
        function syscallGetVarargI() {
          var ret = HEAP32[+SYSCALLS.varargs >> 2];
          SYSCALLS.varargs += 4;
          return ret;
        }
        __name(syscallGetVarargI, "syscallGetVarargI");
        var syscallGetVarargP = syscallGetVarargI;
        function ___syscall_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = syscallGetVarargI();
                if (arg < 0) {
                  return -28;
                }
                while (FS.streams[arg]) {
                  arg++;
                }
                var newStream;
                newStream = FS.dupStream(stream, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = syscallGetVarargI();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = syscallGetVarargP();
                var offset = 0;
                HEAP16[arg + offset >> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_fcntl64, "___syscall_fcntl64");
        function ___syscall_fstat64(fd, buf) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_fstat64, "___syscall_fstat64");
        var INT53_MAX = 9007199254740992;
        var INT53_MIN = -9007199254740992;
        var bigintToI53Checked = /* @__PURE__ */ __name((num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), "bigintToI53Checked");
        function ___syscall_ftruncate64(fd, length) {
          length = bigintToI53Checked(length);
          try {
            if (isNaN(length)) return 61;
            FS.ftruncate(fd, length);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_ftruncate64, "___syscall_ftruncate64");
        var stringToUTF8 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }, "stringToUTF8");
        function ___syscall_getcwd(buf, size) {
          try {
            if (size === 0) return -28;
            var cwd2 = FS.cwd();
            var cwdLengthInBytes = lengthBytesUTF8(cwd2) + 1;
            if (size < cwdLengthInBytes) return -68;
            stringToUTF8(cwd2, buf, size);
            return cwdLengthInBytes;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_getcwd, "___syscall_getcwd");
        function ___syscall_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21505: {
                if (!stream.tty) return -59;
                if (stream.tty.ops.ioctl_tcgets) {
                  var termios = stream.tty.ops.ioctl_tcgets(stream);
                  var argp = syscallGetVarargP();
                  HEAP32[argp >> 2] = termios.c_iflag || 0;
                  HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
                  HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
                  HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
                  for (var i = 0; i < 32; i++) {
                    HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
                  }
                  return 0;
                }
                return 0;
              }
              case 21510:
              case 21511:
              case 21512: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty) return -59;
                if (stream.tty.ops.ioctl_tcsets) {
                  var argp = syscallGetVarargP();
                  var c_iflag = HEAP32[argp >> 2];
                  var c_oflag = HEAP32[argp + 4 >> 2];
                  var c_cflag = HEAP32[argp + 8 >> 2];
                  var c_lflag = HEAP32[argp + 12 >> 2];
                  var c_cc = [];
                  for (var i = 0; i < 32; i++) {
                    c_cc.push(HEAP8[argp + i + 17]);
                  }
                  return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                    c_iflag,
                    c_oflag,
                    c_cflag,
                    c_lflag,
                    c_cc
                  });
                }
                return 0;
              }
              case 21519: {
                if (!stream.tty) return -59;
                var argp = syscallGetVarargP();
                HEAP32[argp >> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty) return -59;
                return -28;
              }
              case 21531: {
                var argp = syscallGetVarargP();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty) return -59;
                if (stream.tty.ops.ioctl_tiocgwinsz) {
                  var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                  var argp = syscallGetVarargP();
                  HEAP16[argp >> 1] = winsize[0];
                  HEAP16[argp + 2 >> 1] = winsize[1];
                }
                return 0;
              }
              case 21524: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21515: {
                if (!stream.tty) return -59;
                return 0;
              }
              default:
                return -28;
            }
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_ioctl, "___syscall_ioctl");
        function ___syscall_lstat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.lstat, path, buf);
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_lstat64, "___syscall_lstat64");
        function ___syscall_mkdirat(dirfd, path, mode) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_mkdirat, "___syscall_mkdirat");
        function ___syscall_newfstatat(dirfd, path, buf, flags2) {
          try {
            path = SYSCALLS.getStr(path);
            var nofollow = flags2 & 256;
            var allowEmpty = flags2 & 4096;
            flags2 = flags2 & ~6400;
            path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
            return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_newfstatat, "___syscall_newfstatat");
        function ___syscall_openat(dirfd, path, flags2, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            var mode = varargs ? syscallGetVarargI() : 0;
            return FS.open(path, flags2, mode).fd;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_openat, "___syscall_openat");
        function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (bufsize <= 0) return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len] = endChar;
            return len;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_readlinkat, "___syscall_readlinkat");
        function ___syscall_rmdir(path) {
          try {
            path = SYSCALLS.getStr(path);
            FS.rmdir(path);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_rmdir, "___syscall_rmdir");
        function ___syscall_stat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.stat, path, buf);
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_stat64, "___syscall_stat64");
        function ___syscall_unlinkat(dirfd, path, flags2) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (flags2 === 0) {
              FS.unlink(path);
            } else if (flags2 === 512) {
              FS.rmdir(path);
            } else {
              abort22("Invalid flags passed to unlinkat");
            }
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_unlinkat, "___syscall_unlinkat");
        var readI53FromI64 = /* @__PURE__ */ __name((ptr) => {
          return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
        }, "readI53FromI64");
        function ___syscall_utimensat(dirfd, path, times, flags2) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path, true);
            var now = Date.now(), atime, mtime;
            if (!times) {
              atime = now;
              mtime = now;
            } else {
              var seconds = readI53FromI64(times);
              var nanoseconds = HEAP32[times + 8 >> 2];
              if (nanoseconds == 1073741823) {
                atime = now;
              } else if (nanoseconds == 1073741822) {
                atime = -1;
              } else {
                atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              }
              times += 16;
              seconds = readI53FromI64(times);
              nanoseconds = HEAP32[times + 8 >> 2];
              if (nanoseconds == 1073741823) {
                mtime = now;
              } else if (nanoseconds == 1073741822) {
                mtime = -1;
              } else {
                mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
              }
            }
            if (mtime != -1 || atime != -1) {
              FS.utime(path, atime, mtime);
            }
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(___syscall_utimensat, "___syscall_utimensat");
        var nowIsMonotonic = 1;
        var __emscripten_get_now_is_monotonic = /* @__PURE__ */ __name(() => nowIsMonotonic, "__emscripten_get_now_is_monotonic");
        var isLeapYear = /* @__PURE__ */ __name((year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0), "isLeapYear");
        var MONTH_DAYS_LEAP_CUMULATIVE = [
          0,
          31,
          60,
          91,
          121,
          152,
          182,
          213,
          244,
          274,
          305,
          335
        ];
        var MONTH_DAYS_REGULAR_CUMULATIVE = [
          0,
          31,
          59,
          90,
          120,
          151,
          181,
          212,
          243,
          273,
          304,
          334
        ];
        var ydayFromDate = /* @__PURE__ */ __name((date) => {
          var leap = isLeapYear(date.getFullYear());
          var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
          var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
          return yday;
        }, "ydayFromDate");
        function __localtime_js(time3, tmPtr) {
          time3 = bigintToI53Checked(time3);
          var date = new Date(time3 * 1e3);
          HEAP32[tmPtr >> 2] = date.getSeconds();
          HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
          HEAP32[tmPtr + 8 >> 2] = date.getHours();
          HEAP32[tmPtr + 12 >> 2] = date.getDate();
          HEAP32[tmPtr + 16 >> 2] = date.getMonth();
          HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
          HEAP32[tmPtr + 24 >> 2] = date.getDay();
          var yday = ydayFromDate(date) | 0;
          HEAP32[tmPtr + 28 >> 2] = yday;
          HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
          var start = new Date(date.getFullYear(), 0, 1);
          var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
          var winterOffset = start.getTimezoneOffset();
          var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
          HEAP32[tmPtr + 32 >> 2] = dst;
        }
        __name(__localtime_js, "__localtime_js");
        function __mmap_js(len, prot, flags2, fd, offset, allocated, addr) {
          offset = bigintToI53Checked(offset);
          try {
            if (isNaN(offset)) return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            var res = FS.mmap(stream, len, offset, prot, flags2);
            var ptr = res.ptr;
            HEAP32[allocated >> 2] = res.allocated;
            HEAPU32[addr >> 2] = ptr;
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(__mmap_js, "__mmap_js");
        function __munmap_js(addr, len, prot, flags2, fd, offset) {
          offset = bigintToI53Checked(offset);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (prot & 2) {
              SYSCALLS.doMsync(addr, stream, len, flags2, offset);
            }
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return -e3.errno;
          }
        }
        __name(__munmap_js, "__munmap_js");
        var __tzset_js = /* @__PURE__ */ __name((timezone, daylight, std_name, dst_name) => {
          var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();
          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
          HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
          HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
          var extractZone = /* @__PURE__ */ __name((timezoneOffset) => {
            var sign = timezoneOffset >= 0 ? "-" : "+";
            var absOffset = Math.abs(timezoneOffset);
            var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
            var minutes = String(absOffset % 60).padStart(2, "0");
            return `UTC${sign}${hours}${minutes}`;
          }, "extractZone");
          var winterName = extractZone(winterOffset);
          var summerName = extractZone(summerOffset);
          if (summerOffset < winterOffset) {
            stringToUTF8(winterName, std_name, 17);
            stringToUTF8(summerName, dst_name, 17);
          } else {
            stringToUTF8(winterName, dst_name, 17);
            stringToUTF8(summerName, std_name, 17);
          }
        }, "__tzset_js");
        var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), "_emscripten_date_now");
        var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), "_emscripten_get_now");
        var getHeapMax = /* @__PURE__ */ __name(() => 2147483648, "getHeapMax");
        var growMemory = /* @__PURE__ */ __name((size) => {
          var b = wasmMemory.buffer;
          var pages = (size - b.byteLength + 65535) / 65536 | 0;
          try {
            wasmMemory.grow(pages);
            updateMemoryViews();
            return 1;
          } catch (e3) {
          }
        }, "growMemory");
        var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {
          var oldSize = HEAPU8.length;
          requestedSize >>>= 0;
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(
              overGrownHeapSize,
              requestedSize + 100663296
            );
            var newSize = Math.min(
              maxHeapSize,
              alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
            );
            var replacement = growMemory(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }, "_emscripten_resize_heap");
        var ENV = {};
        var getExecutableName = /* @__PURE__ */ __name(() => {
          return thisProgram || "./this.program";
        }, "getExecutableName");
        var getEnvStrings = /* @__PURE__ */ __name(() => {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env2 = {
              USER: "web_user",
              LOGNAME: "web_user",
              PATH: "/",
              PWD: "/",
              HOME: "/home/web_user",
              LANG: lang,
              _: getExecutableName()
            };
            for (var x in ENV) {
              if (ENV[x] === void 0) delete env2[x];
              else env2[x] = ENV[x];
            }
            var strings = [];
            for (var x in env2) {
              strings.push(`${x}=${env2[x]}`);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }, "getEnvStrings");
        var stringToAscii = /* @__PURE__ */ __name((str, buffer) => {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer++] = str.charCodeAt(i);
          }
          HEAP8[buffer] = 0;
        }, "stringToAscii");
        var _environ_get = /* @__PURE__ */ __name((__environ, environ_buf) => {
          var bufSize = 0;
          getEnvStrings().forEach((string, i) => {
            var ptr = environ_buf + bufSize;
            HEAPU32[__environ + i * 4 >> 2] = ptr;
            stringToAscii(string, ptr);
            bufSize += string.length + 1;
          });
          return 0;
        }, "_environ_get");
        var _environ_sizes_get = /* @__PURE__ */ __name((penviron_count, penviron_buf_size) => {
          var strings = getEnvStrings();
          HEAPU32[penviron_count >> 2] = strings.length;
          var bufSize = 0;
          strings.forEach((string) => bufSize += string.length + 1);
          HEAPU32[penviron_buf_size >> 2] = bufSize;
          return 0;
        }, "_environ_sizes_get");
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_close, "_fd_close");
        function _fd_fdstat_get(fd, pbuf) {
          try {
            var rightsBase = 0;
            var rightsInheriting = 0;
            var flags2 = 0;
            {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
            }
            HEAP8[pbuf] = type;
            HEAP16[pbuf + 2 >> 1] = flags2;
            HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
            HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_fdstat_get, "_fd_fdstat_get");
        var doReadv = /* @__PURE__ */ __name((stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (curr < len) break;
            if (typeof offset != "undefined") {
              offset += curr;
            }
          }
          return ret;
        }, "doReadv");
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_read, "_fd_read");
        function _fd_seek(fd, offset, whence, newOffset) {
          offset = bigintToI53Checked(offset);
          try {
            if (isNaN(offset)) return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            HEAP64[newOffset >> 3] = BigInt(stream.position);
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_seek, "_fd_seek");
        function _fd_sync(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (stream.stream_ops?.fsync) {
              return stream.stream_ops.fsync(stream);
            }
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_sync, "_fd_sync");
        var doWritev = /* @__PURE__ */ __name((stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (curr < len) {
              break;
            }
            if (typeof offset != "undefined") {
              offset += curr;
            }
          }
          return ret;
        }, "doWritev");
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e3) {
            if (typeof FS == "undefined" || !(e3.name === "ErrnoError")) throw e3;
            return e3.errno;
          }
        }
        __name(_fd_write, "_fd_write");
        FS.createPreloadedFile = FS_createPreloadedFile;
        FS.staticInit();
        var wasmImports = {
          __syscall_chmod: ___syscall_chmod,
          __syscall_faccessat: ___syscall_faccessat,
          __syscall_fchmod: ___syscall_fchmod,
          __syscall_fchown32: ___syscall_fchown32,
          __syscall_fcntl64: ___syscall_fcntl64,
          __syscall_fstat64: ___syscall_fstat64,
          __syscall_ftruncate64: ___syscall_ftruncate64,
          __syscall_getcwd: ___syscall_getcwd,
          __syscall_ioctl: ___syscall_ioctl,
          __syscall_lstat64: ___syscall_lstat64,
          __syscall_mkdirat: ___syscall_mkdirat,
          __syscall_newfstatat: ___syscall_newfstatat,
          __syscall_openat: ___syscall_openat,
          __syscall_readlinkat: ___syscall_readlinkat,
          __syscall_rmdir: ___syscall_rmdir,
          __syscall_stat64: ___syscall_stat64,
          __syscall_unlinkat: ___syscall_unlinkat,
          __syscall_utimensat: ___syscall_utimensat,
          _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
          _localtime_js: __localtime_js,
          _mmap_js: __mmap_js,
          _munmap_js: __munmap_js,
          _tzset_js: __tzset_js,
          emscripten_date_now: _emscripten_date_now,
          emscripten_get_now: _emscripten_get_now,
          emscripten_resize_heap: _emscripten_resize_heap,
          environ_get: _environ_get,
          environ_sizes_get: _environ_sizes_get,
          fd_close: _fd_close,
          fd_fdstat_get: _fd_fdstat_get,
          fd_read: _fd_read,
          fd_seek: _fd_seek,
          fd_sync: _fd_sync,
          fd_write: _fd_write,
          memory: wasmMemory
        };
        var wasmExports = createWasm();
        var ___wasm_call_ctors = /* @__PURE__ */ __name(() => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])(), "___wasm_call_ctors");
        var _sqlite3_status64 = Module["_sqlite3_status64"] = (a0, a1, a2, a3) => (_sqlite3_status64 = Module["_sqlite3_status64"] = wasmExports["sqlite3_status64"])(a0, a1, a2, a3);
        var _sqlite3_status = Module["_sqlite3_status"] = (a0, a1, a2, a3) => (_sqlite3_status = Module["_sqlite3_status"] = wasmExports["sqlite3_status"])(a0, a1, a2, a3);
        var _sqlite3_db_status = Module["_sqlite3_db_status"] = (a0, a1, a2, a3, a4) => (_sqlite3_db_status = Module["_sqlite3_db_status"] = wasmExports["sqlite3_db_status"])(a0, a1, a2, a3, a4);
        var _sqlite3_msize = Module["_sqlite3_msize"] = (a0) => (_sqlite3_msize = Module["_sqlite3_msize"] = wasmExports["sqlite3_msize"])(a0);
        var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = (a0) => (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = wasmExports["sqlite3_vfs_find"])(a0);
        var _sqlite3_initialize = Module["_sqlite3_initialize"] = () => (_sqlite3_initialize = Module["_sqlite3_initialize"] = wasmExports["sqlite3_initialize"])();
        var _sqlite3_malloc = Module["_sqlite3_malloc"] = (a0) => (_sqlite3_malloc = Module["_sqlite3_malloc"] = wasmExports["sqlite3_malloc"])(a0);
        var _sqlite3_free = Module["_sqlite3_free"] = (a0) => (_sqlite3_free = Module["_sqlite3_free"] = wasmExports["sqlite3_free"])(
          a0
        );
        var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = (a0, a1) => (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = wasmExports["sqlite3_vfs_register"])(a0, a1);
        var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = (a0) => (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = wasmExports["sqlite3_vfs_unregister"])(a0);
        var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = (a0) => (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = wasmExports["sqlite3_malloc64"])(a0);
        var _sqlite3_realloc = Module["_sqlite3_realloc"] = (a0, a1) => (_sqlite3_realloc = Module["_sqlite3_realloc"] = wasmExports["sqlite3_realloc"])(a0, a1);
        var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = (a0, a1) => (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = wasmExports["sqlite3_realloc64"])(a0, a1);
        var _sqlite3_value_text = Module["_sqlite3_value_text"] = (a0) => (_sqlite3_value_text = Module["_sqlite3_value_text"] = wasmExports["sqlite3_value_text"])(a0);
        var _sqlite3_randomness = Module["_sqlite3_randomness"] = (a0, a1) => (_sqlite3_randomness = Module["_sqlite3_randomness"] = wasmExports["sqlite3_randomness"])(a0, a1);
        var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = (a0, a1) => (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = wasmExports["sqlite3_stricmp"])(a0, a1);
        var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = (a0, a1, a2) => (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = wasmExports["sqlite3_strnicmp"])(a0, a1, a2);
        var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = (a0, a1) => (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = wasmExports["sqlite3_uri_parameter"])(a0, a1);
        var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = (a0, a1, a2) => (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = wasmExports["sqlite3_uri_boolean"])(a0, a1, a2);
        var _sqlite3_serialize = Module["_sqlite3_serialize"] = (a0, a1, a2, a3) => (_sqlite3_serialize = Module["_sqlite3_serialize"] = wasmExports["sqlite3_serialize"])(a0, a1, a2, a3);
        var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = wasmExports["sqlite3_prepare_v2"])(a0, a1, a2, a3, a4);
        var _sqlite3_step = Module["_sqlite3_step"] = (a0) => (_sqlite3_step = Module["_sqlite3_step"] = wasmExports["sqlite3_step"])(
          a0
        );
        var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = (a0, a1) => (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = wasmExports["sqlite3_column_int64"])(a0, a1);
        var _sqlite3_reset = Module["_sqlite3_reset"] = (a0) => (_sqlite3_reset = Module["_sqlite3_reset"] = wasmExports["sqlite3_reset"])(a0);
        var _sqlite3_exec = Module["_sqlite3_exec"] = (a0, a1, a2, a3, a4) => (_sqlite3_exec = Module["_sqlite3_exec"] = wasmExports["sqlite3_exec"])(
          a0,
          a1,
          a2,
          a3,
          a4
        );
        var _sqlite3_column_int = Module["_sqlite3_column_int"] = (a0, a1) => (_sqlite3_column_int = Module["_sqlite3_column_int"] = wasmExports["sqlite3_column_int"])(a0, a1);
        var _sqlite3_finalize = Module["_sqlite3_finalize"] = (a0) => (_sqlite3_finalize = Module["_sqlite3_finalize"] = wasmExports["sqlite3_finalize"])(a0);
        var _sqlite3_file_control = Module["_sqlite3_file_control"] = (a0, a1, a2, a3) => (_sqlite3_file_control = Module["_sqlite3_file_control"] = wasmExports["sqlite3_file_control"])(a0, a1, a2, a3);
        var _sqlite3_column_name = Module["_sqlite3_column_name"] = (a0, a1) => (_sqlite3_column_name = Module["_sqlite3_column_name"] = wasmExports["sqlite3_column_name"])(a0, a1);
        var _sqlite3_column_text = Module["_sqlite3_column_text"] = (a0, a1) => (_sqlite3_column_text = Module["_sqlite3_column_text"] = wasmExports["sqlite3_column_text"])(a0, a1);
        var _sqlite3_column_type = Module["_sqlite3_column_type"] = (a0, a1) => (_sqlite3_column_type = Module["_sqlite3_column_type"] = wasmExports["sqlite3_column_type"])(a0, a1);
        var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = (a0) => (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = wasmExports["sqlite3_errmsg"])(a0);
        var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = wasmExports["sqlite3_deserialize"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = (a0) => (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = wasmExports["sqlite3_clear_bindings"])(a0);
        var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = (a0) => (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = wasmExports["sqlite3_value_blob"])(a0);
        var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = (a0) => (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = wasmExports["sqlite3_value_bytes"])(a0);
        var _sqlite3_value_double = Module["_sqlite3_value_double"] = (a0) => (_sqlite3_value_double = Module["_sqlite3_value_double"] = wasmExports["sqlite3_value_double"])(a0);
        var _sqlite3_value_int = Module["_sqlite3_value_int"] = (a0) => (_sqlite3_value_int = Module["_sqlite3_value_int"] = wasmExports["sqlite3_value_int"])(a0);
        var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = (a0) => (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = wasmExports["sqlite3_value_int64"])(a0);
        var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = (a0) => (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = wasmExports["sqlite3_value_subtype"])(a0);
        var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = (a0, a1) => (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = wasmExports["sqlite3_value_pointer"])(a0, a1);
        var _sqlite3_value_type = Module["_sqlite3_value_type"] = (a0) => (_sqlite3_value_type = Module["_sqlite3_value_type"] = wasmExports["sqlite3_value_type"])(a0);
        var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = (a0) => (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = wasmExports["sqlite3_value_nochange"])(a0);
        var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = (a0) => (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = wasmExports["sqlite3_value_frombind"])(a0);
        var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = (a0) => (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = wasmExports["sqlite3_value_dup"])(a0);
        var _sqlite3_value_free = Module["_sqlite3_value_free"] = (a0) => (_sqlite3_value_free = Module["_sqlite3_value_free"] = wasmExports["sqlite3_value_free"])(a0);
        var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = (a0, a1, a2, a3) => (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = wasmExports["sqlite3_result_blob"])(a0, a1, a2, a3);
        var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = (a0) => (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = wasmExports["sqlite3_result_error_toobig"])(a0);
        var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = (a0) => (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = wasmExports["sqlite3_result_error_nomem"])(a0);
        var _sqlite3_result_double = Module["_sqlite3_result_double"] = (a0, a1) => (_sqlite3_result_double = Module["_sqlite3_result_double"] = wasmExports["sqlite3_result_double"])(a0, a1);
        var _sqlite3_result_error = Module["_sqlite3_result_error"] = (a0, a1, a2) => (_sqlite3_result_error = Module["_sqlite3_result_error"] = wasmExports["sqlite3_result_error"])(a0, a1, a2);
        var _sqlite3_result_int = Module["_sqlite3_result_int"] = (a0, a1) => (_sqlite3_result_int = Module["_sqlite3_result_int"] = wasmExports["sqlite3_result_int"])(a0, a1);
        var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = (a0, a1) => (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = wasmExports["sqlite3_result_int64"])(a0, a1);
        var _sqlite3_result_null = Module["_sqlite3_result_null"] = (a0) => (_sqlite3_result_null = Module["_sqlite3_result_null"] = wasmExports["sqlite3_result_null"])(a0);
        var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = (a0, a1, a2, a3) => (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = wasmExports["sqlite3_result_pointer"])(a0, a1, a2, a3);
        var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = (a0, a1) => (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = wasmExports["sqlite3_result_subtype"])(a0, a1);
        var _sqlite3_result_text = Module["_sqlite3_result_text"] = (a0, a1, a2, a3) => (_sqlite3_result_text = Module["_sqlite3_result_text"] = wasmExports["sqlite3_result_text"])(a0, a1, a2, a3);
        var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = (a0, a1) => (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = wasmExports["sqlite3_result_zeroblob"])(a0, a1);
        var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = (a0, a1) => (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = wasmExports["sqlite3_result_zeroblob64"])(a0, a1);
        var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = (a0, a1) => (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = wasmExports["sqlite3_result_error_code"])(a0, a1);
        var _sqlite3_user_data = Module["_sqlite3_user_data"] = (a0) => (_sqlite3_user_data = Module["_sqlite3_user_data"] = wasmExports["sqlite3_user_data"])(a0);
        var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = (a0) => (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = wasmExports["sqlite3_context_db_handle"])(a0);
        var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = (a0) => (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = wasmExports["sqlite3_vtab_nochange"])(a0);
        var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = (a0, a1) => (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = wasmExports["sqlite3_vtab_in_first"])(a0, a1);
        var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = (a0, a1) => (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = wasmExports["sqlite3_vtab_in_next"])(a0, a1);
        var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = (a0, a1) => (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = wasmExports["sqlite3_aggregate_context"])(a0, a1);
        var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = (a0, a1) => (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = wasmExports["sqlite3_get_auxdata"])(a0, a1);
        var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = (a0, a1, a2, a3) => (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = wasmExports["sqlite3_set_auxdata"])(a0, a1, a2, a3);
        var _sqlite3_column_count = Module["_sqlite3_column_count"] = (a0) => (_sqlite3_column_count = Module["_sqlite3_column_count"] = wasmExports["sqlite3_column_count"])(a0);
        var _sqlite3_data_count = Module["_sqlite3_data_count"] = (a0) => (_sqlite3_data_count = Module["_sqlite3_data_count"] = wasmExports["sqlite3_data_count"])(a0);
        var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = (a0, a1) => (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = wasmExports["sqlite3_column_blob"])(a0, a1);
        var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = (a0, a1) => (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = wasmExports["sqlite3_column_bytes"])(a0, a1);
        var _sqlite3_column_double = Module["_sqlite3_column_double"] = (a0, a1) => (_sqlite3_column_double = Module["_sqlite3_column_double"] = wasmExports["sqlite3_column_double"])(a0, a1);
        var _sqlite3_column_value = Module["_sqlite3_column_value"] = (a0, a1) => (_sqlite3_column_value = Module["_sqlite3_column_value"] = wasmExports["sqlite3_column_value"])(a0, a1);
        var _sqlite3_column_decltype = Module["_sqlite3_column_decltype"] = (a0, a1) => (_sqlite3_column_decltype = Module["_sqlite3_column_decltype"] = wasmExports["sqlite3_column_decltype"])(a0, a1);
        var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = wasmExports["sqlite3_bind_blob"])(a0, a1, a2, a3, a4);
        var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = (a0, a1, a2) => (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = wasmExports["sqlite3_bind_double"])(a0, a1, a2);
        var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = (a0, a1, a2) => (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = wasmExports["sqlite3_bind_int"])(a0, a1, a2);
        var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = (a0, a1, a2) => (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = wasmExports["sqlite3_bind_int64"])(a0, a1, a2);
        var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = (a0, a1) => (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = wasmExports["sqlite3_bind_null"])(a0, a1);
        var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = wasmExports["sqlite3_bind_pointer"])(a0, a1, a2, a3, a4);
        var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = wasmExports["sqlite3_bind_text"])(a0, a1, a2, a3, a4);
        var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = (a0) => (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = wasmExports["sqlite3_bind_parameter_count"])(a0);
        var _sqlite3_bind_parameter_name = Module["_sqlite3_bind_parameter_name"] = (a0, a1) => (_sqlite3_bind_parameter_name = Module["_sqlite3_bind_parameter_name"] = wasmExports["sqlite3_bind_parameter_name"])(a0, a1);
        var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = (a0, a1) => (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = wasmExports["sqlite3_bind_parameter_index"])(a0, a1);
        var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = (a0) => (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = wasmExports["sqlite3_db_handle"])(a0);
        var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = (a0) => (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = wasmExports["sqlite3_stmt_readonly"])(a0);
        var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = (a0) => (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = wasmExports["sqlite3_stmt_isexplain"])(a0);
        var _sqlite3_stmt_explain = Module["_sqlite3_stmt_explain"] = (a0, a1) => (_sqlite3_stmt_explain = Module["_sqlite3_stmt_explain"] = wasmExports["sqlite3_stmt_explain"])(a0, a1);
        var _sqlite3_stmt_busy = Module["_sqlite3_stmt_busy"] = (a0) => (_sqlite3_stmt_busy = Module["_sqlite3_stmt_busy"] = wasmExports["sqlite3_stmt_busy"])(a0);
        var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = (a0, a1, a2) => (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = wasmExports["sqlite3_stmt_status"])(a0, a1, a2);
        var _sqlite3_sql = Module["_sqlite3_sql"] = (a0) => (_sqlite3_sql = Module["_sqlite3_sql"] = wasmExports["sqlite3_sql"])(a0);
        var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = (a0) => (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = wasmExports["sqlite3_expanded_sql"])(a0);
        var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = (a0, a1, a2) => (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = wasmExports["sqlite3_preupdate_old"])(a0, a1, a2);
        var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = (a0) => (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = wasmExports["sqlite3_preupdate_count"])(a0);
        var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = (a0) => (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = wasmExports["sqlite3_preupdate_depth"])(a0);
        var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = (a0) => (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = wasmExports["sqlite3_preupdate_blobwrite"])(a0);
        var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = (a0, a1, a2) => (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = wasmExports["sqlite3_preupdate_new"])(a0, a1, a2);
        var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = (a0) => (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = wasmExports["sqlite3_value_numeric_type"])(a0);
        var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = (a0, a1, a2) => (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = wasmExports["sqlite3_set_authorizer"])(a0, a1, a2);
        var _sqlite3_strglob = Module["_sqlite3_strglob"] = (a0, a1) => (_sqlite3_strglob = Module["_sqlite3_strglob"] = wasmExports["sqlite3_strglob"])(a0, a1);
        var _sqlite3_strlike = Module["_sqlite3_strlike"] = (a0, a1, a2) => (_sqlite3_strlike = Module["_sqlite3_strlike"] = wasmExports["sqlite3_strlike"])(a0, a1, a2);
        var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = (a0) => (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = wasmExports["sqlite3_auto_extension"])(a0);
        var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = (a0) => (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = wasmExports["sqlite3_cancel_auto_extension"])(a0);
        var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = () => (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = wasmExports["sqlite3_reset_auto_extension"])();
        var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = wasmExports["sqlite3_prepare_v3"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3_create_module = Module["_sqlite3_create_module"] = (a0, a1, a2, a3) => (_sqlite3_create_module = Module["_sqlite3_create_module"] = wasmExports["sqlite3_create_module"])(a0, a1, a2, a3);
        var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = wasmExports["sqlite3_create_module_v2"])(a0, a1, a2, a3, a4);
        var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = (a0, a1) => (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = wasmExports["sqlite3_drop_modules"])(a0, a1);
        var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = (a0, a1) => (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = wasmExports["sqlite3_declare_vtab"])(a0, a1);
        var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = (a0) => (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = wasmExports["sqlite3_vtab_on_conflict"])(a0);
        var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = (a0, a1) => (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = wasmExports["sqlite3_vtab_collation"])(a0, a1);
        var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = (a0, a1, a2) => (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = wasmExports["sqlite3_vtab_in"])(a0, a1, a2);
        var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = (a0, a1, a2) => (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = wasmExports["sqlite3_vtab_rhs_value"])(a0, a1, a2);
        var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = (a0) => (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = wasmExports["sqlite3_vtab_distinct"])(a0);
        var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = (a0, a1, a2) => (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = wasmExports["sqlite3_keyword_name"])(a0, a1, a2);
        var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = () => (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = wasmExports["sqlite3_keyword_count"])();
        var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = (a0, a1) => (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = wasmExports["sqlite3_keyword_check"])(a0, a1);
        var _sqlite3_complete = Module["_sqlite3_complete"] = (a0) => (_sqlite3_complete = Module["_sqlite3_complete"] = wasmExports["sqlite3_complete"])(a0);
        var _sqlite3_libversion = Module["_sqlite3_libversion"] = () => (_sqlite3_libversion = Module["_sqlite3_libversion"] = wasmExports["sqlite3_libversion"])();
        var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = () => (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = wasmExports["sqlite3_libversion_number"])();
        var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = () => (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = wasmExports["sqlite3_shutdown"])();
        var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = (a0) => (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = wasmExports["sqlite3_last_insert_rowid"])(a0);
        var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = (a0, a1) => (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = wasmExports["sqlite3_set_last_insert_rowid"])(a0, a1);
        var _sqlite3_changes64 = Module["_sqlite3_changes64"] = (a0) => (_sqlite3_changes64 = Module["_sqlite3_changes64"] = wasmExports["sqlite3_changes64"])(a0);
        var _sqlite3_changes = Module["_sqlite3_changes"] = (a0) => (_sqlite3_changes = Module["_sqlite3_changes"] = wasmExports["sqlite3_changes"])(a0);
        var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = (a0) => (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = wasmExports["sqlite3_total_changes64"])(a0);
        var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = (a0) => (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = wasmExports["sqlite3_total_changes"])(a0);
        var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = (a0, a1) => (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = wasmExports["sqlite3_txn_state"])(a0, a1);
        var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = (a0) => (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = wasmExports["sqlite3_close_v2"])(a0);
        var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = (a0, a1, a2) => (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = wasmExports["sqlite3_busy_handler"])(a0, a1, a2);
        var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = (a0, a1, a2, a3) => (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = wasmExports["sqlite3_progress_handler"])(a0, a1, a2, a3);
        var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = (a0, a1) => (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = wasmExports["sqlite3_busy_timeout"])(a0, a1);
        var _sqlite3_interrupt = Module["_sqlite3_interrupt"] = (a0) => (_sqlite3_interrupt = Module["_sqlite3_interrupt"] = wasmExports["sqlite3_interrupt"])(a0);
        var _sqlite3_is_interrupted = Module["_sqlite3_is_interrupted"] = (a0) => (_sqlite3_is_interrupted = Module["_sqlite3_is_interrupted"] = wasmExports["sqlite3_is_interrupted"])(a0);
        var _sqlite3_create_function = Module["_sqlite3_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_sqlite3_create_function = Module["_sqlite3_create_function"] = wasmExports["sqlite3_create_function"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7
        );
        var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = wasmExports["sqlite3_create_function_v2"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8
        );
        var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = wasmExports["sqlite3_create_window_function"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9
        );
        var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = (a0, a1, a2) => (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = wasmExports["sqlite3_overload_function"])(a0, a1, a2);
        var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = (a0, a1, a2, a3) => (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = wasmExports["sqlite3_trace_v2"])(a0, a1, a2, a3);
        var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = (a0, a1, a2) => (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = wasmExports["sqlite3_commit_hook"])(a0, a1, a2);
        var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = (a0, a1, a2) => (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = wasmExports["sqlite3_update_hook"])(a0, a1, a2);
        var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = (a0, a1, a2) => (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = wasmExports["sqlite3_rollback_hook"])(a0, a1, a2);
        var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = (a0, a1, a2) => (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = wasmExports["sqlite3_preupdate_hook"])(a0, a1, a2);
        var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = (a0) => (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = wasmExports["sqlite3_error_offset"])(a0);
        var _sqlite3_errcode = Module["_sqlite3_errcode"] = (a0) => (_sqlite3_errcode = Module["_sqlite3_errcode"] = wasmExports["sqlite3_errcode"])(a0);
        var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = (a0) => (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = wasmExports["sqlite3_extended_errcode"])(a0);
        var _sqlite3_errstr = Module["_sqlite3_errstr"] = (a0) => (_sqlite3_errstr = Module["_sqlite3_errstr"] = wasmExports["sqlite3_errstr"])(a0);
        var _sqlite3_limit = Module["_sqlite3_limit"] = (a0, a1, a2) => (_sqlite3_limit = Module["_sqlite3_limit"] = wasmExports["sqlite3_limit"])(a0, a1, a2);
        var _sqlite3_open = Module["_sqlite3_open"] = (a0, a1) => (_sqlite3_open = Module["_sqlite3_open"] = wasmExports["sqlite3_open"])(
          a0,
          a1
        );
        var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = (a0, a1, a2, a3) => (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = wasmExports["sqlite3_open_v2"])(a0, a1, a2, a3);
        var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = wasmExports["sqlite3_create_collation"])(a0, a1, a2, a3, a4);
        var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = wasmExports["sqlite3_create_collation_v2"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = (a0, a1, a2) => (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = wasmExports["sqlite3_collation_needed"])(a0, a1, a2);
        var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = (a0) => (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = wasmExports["sqlite3_get_autocommit"])(a0);
        var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = wasmExports["sqlite3_table_column_metadata"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8
        );
        var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = (a0, a1) => (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = wasmExports["sqlite3_extended_result_codes"])(a0, a1);
        var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = (a0, a1) => (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = wasmExports["sqlite3_uri_key"])(a0, a1);
        var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = (a0, a1, a2) => (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = wasmExports["sqlite3_uri_int64"])(a0, a1, a2);
        var _sqlite3_db_name = Module["_sqlite3_db_name"] = (a0, a1) => (_sqlite3_db_name = Module["_sqlite3_db_name"] = wasmExports["sqlite3_db_name"])(a0, a1);
        var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = (a0, a1) => (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = wasmExports["sqlite3_db_filename"])(a0, a1);
        var _sqlite3_db_readonly = Module["_sqlite3_db_readonly"] = (a0, a1) => (_sqlite3_db_readonly = Module["_sqlite3_db_readonly"] = wasmExports["sqlite3_db_readonly"])(a0, a1);
        var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = (a0) => (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = wasmExports["sqlite3_compileoption_used"])(a0);
        var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = (a0) => (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = wasmExports["sqlite3_compileoption_get"])(a0);
        var _sqlite3session_diff = Module["_sqlite3session_diff"] = (a0, a1, a2, a3) => (_sqlite3session_diff = Module["_sqlite3session_diff"] = wasmExports["sqlite3session_diff"])(a0, a1, a2, a3);
        var _sqlite3session_attach = Module["_sqlite3session_attach"] = (a0, a1) => (_sqlite3session_attach = Module["_sqlite3session_attach"] = wasmExports["sqlite3session_attach"])(a0, a1);
        var _sqlite3session_create = Module["_sqlite3session_create"] = (a0, a1, a2) => (_sqlite3session_create = Module["_sqlite3session_create"] = wasmExports["sqlite3session_create"])(a0, a1, a2);
        var _sqlite3session_delete = Module["_sqlite3session_delete"] = (a0) => (_sqlite3session_delete = Module["_sqlite3session_delete"] = wasmExports["sqlite3session_delete"])(a0);
        var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = (a0, a1, a2) => (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = wasmExports["sqlite3session_table_filter"])(a0, a1, a2);
        var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = (a0, a1, a2) => (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = wasmExports["sqlite3session_changeset"])(a0, a1, a2);
        var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = (a0, a1, a2) => (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = wasmExports["sqlite3session_changeset_strm"])(a0, a1, a2);
        var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = (a0, a1, a2) => (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = wasmExports["sqlite3session_patchset_strm"])(a0, a1, a2);
        var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = (a0, a1, a2) => (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = wasmExports["sqlite3session_patchset"])(a0, a1, a2);
        var _sqlite3session_enable = Module["_sqlite3session_enable"] = (a0, a1) => (_sqlite3session_enable = Module["_sqlite3session_enable"] = wasmExports["sqlite3session_enable"])(a0, a1);
        var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = (a0, a1) => (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = wasmExports["sqlite3session_indirect"])(a0, a1);
        var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = (a0) => (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = wasmExports["sqlite3session_isempty"])(a0);
        var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = (a0) => (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = wasmExports["sqlite3session_memory_used"])(a0);
        var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = (a0, a1, a2) => (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = wasmExports["sqlite3session_object_config"])(a0, a1, a2);
        var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = (a0) => (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = wasmExports["sqlite3session_changeset_size"])(a0);
        var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = (a0, a1, a2) => (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = wasmExports["sqlite3changeset_start"])(a0, a1, a2);
        var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = (a0, a1, a2, a3) => (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = wasmExports["sqlite3changeset_start_v2"])(a0, a1, a2, a3);
        var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = (a0, a1, a2) => (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = wasmExports["sqlite3changeset_start_strm"])(a0, a1, a2);
        var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = (a0, a1, a2, a3) => (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = wasmExports["sqlite3changeset_start_v2_strm"])(a0, a1, a2, a3);
        var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = (a0) => (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = wasmExports["sqlite3changeset_next"])(a0);
        var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = (a0, a1, a2, a3, a4) => (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = wasmExports["sqlite3changeset_op"])(a0, a1, a2, a3, a4);
        var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = (a0, a1, a2) => (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = wasmExports["sqlite3changeset_pk"])(a0, a1, a2);
        var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = (a0, a1, a2) => (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = wasmExports["sqlite3changeset_old"])(a0, a1, a2);
        var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = (a0, a1, a2) => (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = wasmExports["sqlite3changeset_new"])(a0, a1, a2);
        var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = (a0, a1, a2) => (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = wasmExports["sqlite3changeset_conflict"])(a0, a1, a2);
        var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = (a0, a1) => (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = wasmExports["sqlite3changeset_fk_conflicts"])(a0, a1);
        var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = (a0) => (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = wasmExports["sqlite3changeset_finalize"])(a0);
        var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = (a0, a1, a2, a3) => (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = wasmExports["sqlite3changeset_invert"])(a0, a1, a2, a3);
        var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = (a0, a1, a2, a3) => (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = wasmExports["sqlite3changeset_invert_strm"])(a0, a1, a2, a3);
        var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = wasmExports["sqlite3changeset_apply_v2"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8
        );
        var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = wasmExports["sqlite3changeset_apply"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = wasmExports["sqlite3changeset_apply_v2_strm"])(
          a0,
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8
        );
        var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = wasmExports["sqlite3changeset_apply_strm"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = (a0) => (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = wasmExports["sqlite3changegroup_new"])(a0);
        var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = (a0, a1, a2) => (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = wasmExports["sqlite3changegroup_add"])(a0, a1, a2);
        var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = (a0, a1, a2) => (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = wasmExports["sqlite3changegroup_output"])(a0, a1, a2);
        var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = (a0, a1, a2) => (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = wasmExports["sqlite3changegroup_add_strm"])(a0, a1, a2);
        var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = (a0, a1, a2) => (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = wasmExports["sqlite3changegroup_output_strm"])(a0, a1, a2);
        var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = (a0) => (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = wasmExports["sqlite3changegroup_delete"])(a0);
        var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = wasmExports["sqlite3changeset_concat"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = wasmExports["sqlite3changeset_concat_strm"])(a0, a1, a2, a3, a4, a5);
        var _sqlite3session_config = Module["_sqlite3session_config"] = (a0, a1) => (_sqlite3session_config = Module["_sqlite3session_config"] = wasmExports["sqlite3session_config"])(a0, a1);
        var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = () => (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = wasmExports["sqlite3_sourceid"])();
        var _sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = () => (_sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = wasmExports["sqlite3__wasm_pstack_ptr"])();
        var _sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = (a0) => (_sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = wasmExports["sqlite3__wasm_pstack_restore"])(a0);
        var _sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = (a0) => (_sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = wasmExports["sqlite3__wasm_pstack_alloc"])(a0);
        var _sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = () => (_sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = wasmExports["sqlite3__wasm_pstack_remaining"])();
        var _sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = () => (_sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = wasmExports["sqlite3__wasm_pstack_quota"])();
        var _sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = (a0, a1, a2) => (_sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = wasmExports["sqlite3__wasm_db_error"])(a0, a1, a2);
        var _sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = (a0) => (_sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = wasmExports["sqlite3__wasm_test_struct"])(a0);
        var _sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = () => (_sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = wasmExports["sqlite3__wasm_enum_json"])();
        var _sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = (a0, a1) => (_sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = wasmExports["sqlite3__wasm_vfs_unlink"])(a0, a1);
        var _sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = (a0, a1) => (_sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = wasmExports["sqlite3__wasm_db_vfs"])(a0, a1);
        var _sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = (a0) => (_sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = wasmExports["sqlite3__wasm_db_reset"])(a0);
        var _sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = (a0, a1) => (_sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = wasmExports["sqlite3__wasm_db_export_chunked"])(a0, a1);
        var _sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = (a0, a1, a2, a3, a4) => (_sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = wasmExports["sqlite3__wasm_db_serialize"])(a0, a1, a2, a3, a4);
        var _sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = (a0, a1, a2, a3) => (_sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = wasmExports["sqlite3__wasm_vfs_create_file"])(a0, a1, a2, a3);
        var _sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = (a0, a1, a2) => (_sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = wasmExports["sqlite3__wasm_posix_create_file"])(a0, a1, a2);
        var _sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = (a0, a1) => (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = wasmExports["sqlite3__wasm_kvvfsMakeKeyOnPstack"])(a0, a1);
        var _sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = () => (_sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = wasmExports["sqlite3__wasm_kvvfs_methods"])();
        var _sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = (a0, a1, a2) => (_sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = wasmExports["sqlite3__wasm_vtab_config"])(a0, a1, a2);
        var _sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = (a0, a1, a2, a3) => (_sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = wasmExports["sqlite3__wasm_db_config_ip"])(a0, a1, a2, a3);
        var _sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = (a0, a1, a2, a3, a4) => (_sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = wasmExports["sqlite3__wasm_db_config_pii"])(a0, a1, a2, a3, a4);
        var _sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = (a0, a1, a2) => (_sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = wasmExports["sqlite3__wasm_db_config_s"])(a0, a1, a2);
        var _sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = (a0, a1) => (_sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = wasmExports["sqlite3__wasm_config_i"])(a0, a1);
        var _sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = (a0, a1, a2) => (_sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = wasmExports["sqlite3__wasm_config_ii"])(a0, a1, a2);
        var _sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = (a0, a1) => (_sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = wasmExports["sqlite3__wasm_config_j"])(a0, a1);
        var _sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = (a0, a1) => (_sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = wasmExports["sqlite3__wasm_qfmt_token"])(a0, a1);
        var _sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = (a0) => (_sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = wasmExports["sqlite3__wasm_init_wasmfs"])(a0);
        var _sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = (a0) => (_sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = wasmExports["sqlite3__wasm_test_intptr"])(a0);
        var _sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = (a0) => (_sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = wasmExports["sqlite3__wasm_test_voidptr"])(a0);
        var _sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = () => (_sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = wasmExports["sqlite3__wasm_test_int64_max"])();
        var _sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = () => (_sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = wasmExports["sqlite3__wasm_test_int64_min"])();
        var _sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = (a0) => (_sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = wasmExports["sqlite3__wasm_test_int64_times2"])(a0);
        var _sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = (a0, a1) => (_sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = wasmExports["sqlite3__wasm_test_int64_minmax"])(a0, a1);
        var _sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = (a0) => (_sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = wasmExports["sqlite3__wasm_test_int64ptr"])(a0);
        var _sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = (a0) => (_sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = wasmExports["sqlite3__wasm_test_stack_overflow"])(a0);
        var _sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = (a0) => (_sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = wasmExports["sqlite3__wasm_test_str_hello"])(a0);
        var _sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = (a0, a1) => (_sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = wasmExports["sqlite3__wasm_SQLTester_strglob"])(a0, a1);
        var _malloc = Module["_malloc"] = (a0) => (_malloc = Module["_malloc"] = wasmExports["malloc"])(a0);
        var _free = Module["_free"] = (a0) => (_free = Module["_free"] = wasmExports["free"])(a0);
        var _realloc = Module["_realloc"] = (a0, a1) => (_realloc = Module["_realloc"] = wasmExports["realloc"])(a0, a1);
        var _emscripten_builtin_memalign = /* @__PURE__ */ __name((a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1), "_emscripten_builtin_memalign");
        var __emscripten_stack_restore = /* @__PURE__ */ __name((a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
          a0
        ), "__emscripten_stack_restore");
        var __emscripten_stack_alloc = /* @__PURE__ */ __name((a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0), "__emscripten_stack_alloc");
        var _emscripten_stack_get_current = /* @__PURE__ */ __name(() => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])(), "_emscripten_stack_get_current");
        Module["wasmMemory"] = wasmMemory;
        var calledRun;
        var calledPrerun;
        dependenciesFulfilled = /* @__PURE__ */ __name(function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        }, "runCaller");
        function run() {
          if (runDependencies > 0) {
            return;
          }
          if (!calledPrerun) {
            calledPrerun = 1;
            preRun();
            if (runDependencies > 0) {
              return;
            }
          }
          function doRun() {
            if (calledRun) return;
            calledRun = 1;
            Module["calledRun"] = 1;
            if (ABORT) return;
            initRuntime();
            readyPromiseResolve(Module);
            Module["onRuntimeInitialized"]?.();
            postRun();
          }
          __name(doRun, "doRun");
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(() => {
              setTimeout(() => Module["setStatus"](""), 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        __name(run, "run");
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        run();
        Module.runSQLite3PostLoadInit = function(EmscriptenModule) {
          "use strict";
          "use strict";
          globalThis.sqlite3ApiBootstrap = /* @__PURE__ */ __name(function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {
            if (sqlite3ApiBootstrap.sqlite3) {
              (sqlite3ApiBootstrap.sqlite3.config || console).warn(
                "sqlite3ApiBootstrap() called multiple times.",
                "Config and external initializers are ignored on calls after the first."
              );
              return sqlite3ApiBootstrap.sqlite3;
            }
            const config2 = Object.assign(
              /* @__PURE__ */ Object.create(null),
              {
                exports: void 0,
                memory: void 0,
                bigIntEnabled: (() => {
                  if ("undefined" !== typeof Module) {
                    if (!!Module.HEAPU64) return true;
                  }
                  return !!globalThis.BigInt64Array;
                })(),
                debug: console.debug.bind(console),
                warn: console.warn.bind(console),
                error: console.error.bind(console),
                log: console.log.bind(console),
                wasmfsOpfsDir: "/opfs",
                useStdAlloc: false
              },
              apiConfig || {}
            );
            Object.assign(
              config2,
              {
                allocExportName: config2.useStdAlloc ? "malloc" : "sqlite3_malloc",
                deallocExportName: config2.useStdAlloc ? "free" : "sqlite3_free",
                reallocExportName: config2.useStdAlloc ? "realloc" : "sqlite3_realloc"
              },
              config2
            );
            ["exports", "memory", "wasmfsOpfsDir"].forEach((k) => {
              if ("function" === typeof config2[k]) {
                config2[k] = config2[k]();
              }
            });
            delete globalThis.sqlite3ApiConfig;
            delete sqlite3ApiBootstrap.defaultConfig;
            const capi = /* @__PURE__ */ Object.create(null);
            const wasm2 = /* @__PURE__ */ Object.create(null);
            const __rcStr = /* @__PURE__ */ __name((rc) => {
              return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || "Unknown result code #" + rc;
            }, "__rcStr");
            const __isInt = /* @__PURE__ */ __name((n2) => "number" === typeof n2 && n2 === (n2 | 0), "__isInt");
            class SQLite3Error extends Error {
              static {
                __name(this, "SQLite3Error");
              }
              constructor(...args) {
                let rc;
                if (args.length) {
                  if (__isInt(args[0])) {
                    rc = args[0];
                    if (1 === args.length) {
                      super(__rcStr(args[0]));
                    } else {
                      const rcStr = __rcStr(rc);
                      if ("object" === typeof args[1]) {
                        super(rcStr, args[1]);
                      } else {
                        args[0] = rcStr + ":";
                        super(args.join(" "));
                      }
                    }
                  } else {
                    if (2 === args.length && "object" === typeof args[1]) {
                      super(...args);
                    } else {
                      super(args.join(" "));
                    }
                  }
                }
                this.resultCode = rc || capi.SQLITE_ERROR;
                this.name = "SQLite3Error";
              }
            }
            SQLite3Error.toss = (...args) => {
              throw new SQLite3Error(...args);
            };
            const toss3 = SQLite3Error.toss;
            if (config2.wasmfsOpfsDir && !/^\/[^/]+$/.test(config2.wasmfsOpfsDir)) {
              toss3(
                "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'."
              );
            }
            const isInt32 = /* @__PURE__ */ __name((n2) => {
              return "bigint" !== typeof n2 && !!(n2 === (n2 | 0) && n2 <= 2147483647 && n2 >= -2147483648);
            }, "isInt32");
            const bigIntFits64 = /* @__PURE__ */ __name(function f(b) {
              if (!f._max) {
                f._max = BigInt("0x7fffffffffffffff");
                f._min = ~f._max;
              }
              return b >= f._min && b <= f._max;
            }, "f");
            const bigIntFits32 = /* @__PURE__ */ __name((b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn, "bigIntFits32");
            const bigIntFitsDouble = /* @__PURE__ */ __name(function f(b) {
              if (!f._min) {
                f._min = Number.MIN_SAFE_INTEGER;
                f._max = Number.MAX_SAFE_INTEGER;
              }
              return b >= f._min && b <= f._max;
            }, "f");
            const isTypedArray = /* @__PURE__ */ __name((v2) => {
              return v2 && v2.constructor && isInt32(v2.constructor.BYTES_PER_ELEMENT) ? v2 : false;
            }, "isTypedArray");
            const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
            } : SharedArrayBuffer;
            const isSharedTypedArray = /* @__PURE__ */ __name((aTypedArray) => aTypedArray.buffer instanceof __SAB, "isSharedTypedArray");
            const typedArrayPart = /* @__PURE__ */ __name((aTypedArray, begin, end) => {
              return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);
            }, "typedArrayPart");
            const isBindableTypedArray = /* @__PURE__ */ __name((v2) => {
              return v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);
            }, "isBindableTypedArray");
            const isSQLableTypedArray = /* @__PURE__ */ __name((v2) => {
              return v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);
            }, "isSQLableTypedArray");
            const affirmBindableTypedArray = /* @__PURE__ */ __name((v2) => {
              return isBindableTypedArray(v2) || toss3("Value is not of a supported TypedArray type.");
            }, "affirmBindableTypedArray");
            const utf8Decoder = new TextDecoder("utf-8");
            const typedArrayToString = /* @__PURE__ */ __name(function(typedArray, begin, end) {
              return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
            }, "typedArrayToString");
            const flexibleString = /* @__PURE__ */ __name(function(v2) {
              if (isSQLableTypedArray(v2)) {
                return typedArrayToString(
                  v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2
                );
              } else if (Array.isArray(v2)) return v2.join("");
              else if (wasm2.isPtr(v2)) v2 = wasm2.cstrToJs(v2);
              return v2;
            }, "flexibleString");
            class WasmAllocError extends Error {
              static {
                __name(this, "WasmAllocError");
              }
              constructor(...args) {
                if (2 === args.length && "object" === typeof args[1]) {
                  super(...args);
                } else if (args.length) {
                  super(args.join(" "));
                } else {
                  super("Allocation failed.");
                }
                this.resultCode = capi.SQLITE_NOMEM;
                this.name = "WasmAllocError";
              }
            }
            WasmAllocError.toss = (...args) => {
              throw new WasmAllocError(...args);
            };
            Object.assign(capi, {
              sqlite3_bind_blob: void 0,
              sqlite3_bind_text: void 0,
              sqlite3_create_function_v2: /* @__PURE__ */ __name((pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {
              }, "sqlite3_create_function_v2"),
              sqlite3_create_function: /* @__PURE__ */ __name((pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {
              }, "sqlite3_create_function"),
              sqlite3_create_window_function: /* @__PURE__ */ __name((pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {
              }, "sqlite3_create_window_function"),
              sqlite3_prepare_v3: /* @__PURE__ */ __name((dbPtr, sql, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {
              }, "sqlite3_prepare_v3"),
              sqlite3_prepare_v2: /* @__PURE__ */ __name((dbPtr, sql, sqlByteLen, stmtPtrPtr, strPtrPtr) => {
              }, "sqlite3_prepare_v2"),
              sqlite3_exec: /* @__PURE__ */ __name((pDb2, sql, callback, pVoid, pErrMsg) => {
              }, "sqlite3_exec"),
              sqlite3_randomness: /* @__PURE__ */ __name((n2, outPtr) => {
              }, "sqlite3_randomness")
            });
            const util = {
              affirmBindableTypedArray,
              flexibleString,
              bigIntFits32,
              bigIntFits64,
              bigIntFitsDouble,
              isBindableTypedArray,
              isInt32,
              isSQLableTypedArray,
              isTypedArray,
              typedArrayToString,
              isUIThread: /* @__PURE__ */ __name(() => globalThis.window === globalThis && !!globalThis.document, "isUIThread"),
              isSharedTypedArray,
              toss: /* @__PURE__ */ __name(function(...args) {
                throw new Error(args.join(" "));
              }, "toss"),
              toss3,
              typedArrayPart,
              affirmDbHeader: /* @__PURE__ */ __name(function(bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                const header = "SQLite format 3";
                if (header.length > bytes.byteLength) {
                  toss3("Input does not contain an SQLite3 database header.");
                }
                for (let i = 0; i < header.length; ++i) {
                  if (header.charCodeAt(i) !== bytes[i]) {
                    toss3("Input does not contain an SQLite3 database header.");
                  }
                }
              }, "affirmDbHeader"),
              affirmIsDb: /* @__PURE__ */ __name(function(bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                const n2 = bytes.byteLength;
                if (n2 < 512 || n2 % 512 !== 0) {
                  toss3("Byte array size", n2, "is invalid for an SQLite3 db.");
                }
                util.affirmDbHeader(bytes);
              }, "affirmIsDb")
            };
            Object.assign(wasm2, {
              ptrSizeof: config2.wasmPtrSizeof || 4,
              ptrIR: config2.wasmPtrIR || "i32",
              bigIntEnabled: !!config2.bigIntEnabled,
              exports: config2.exports || toss3("Missing API config.exports (WASM module exports)."),
              memory: config2.memory || config2.exports["memory"] || toss3(
                "API config object requires a WebAssembly.Memory object",
                "in either config.exports.memory (exported)",
                "or config.memory (imported)."
              ),
              alloc: void 0,
              realloc: void 0,
              dealloc: void 0
            });
            wasm2.allocFromTypedArray = function(srcTypedArray) {
              if (srcTypedArray instanceof ArrayBuffer) {
                srcTypedArray = new Uint8Array(srcTypedArray);
              }
              affirmBindableTypedArray(srcTypedArray);
              const pRet = wasm2.alloc(srcTypedArray.byteLength || 1);
              wasm2.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
              return pRet;
            };
            {
              const keyAlloc = config2.allocExportName, keyDealloc = config2.deallocExportName, keyRealloc = config2.reallocExportName;
              for (const key2 of [keyAlloc, keyDealloc, keyRealloc]) {
                const f = wasm2.exports[key2];
                if (!(f instanceof Function))
                  toss3("Missing required exports[", key2, "] function.");
              }
              wasm2.alloc = /* @__PURE__ */ __name(function f(n2) {
                return f.impl(n2) || WasmAllocError.toss("Failed to allocate", n2, " bytes.");
              }, "f");
              wasm2.alloc.impl = wasm2.exports[keyAlloc];
              wasm2.realloc = /* @__PURE__ */ __name(function f(m, n2) {
                const m2 = f.impl(m, n2);
                return n2 ? m2 || WasmAllocError.toss("Failed to reallocate", n2, " bytes.") : 0;
              }, "f");
              wasm2.realloc.impl = wasm2.exports[keyRealloc];
              wasm2.dealloc = wasm2.exports[keyDealloc];
            }
            wasm2.compileOptionUsed = /* @__PURE__ */ __name(function f(optName) {
              if (!arguments.length) {
                if (f._result) return f._result;
                else if (!f._opt) {
                  f._rx = /^([^=]+)=(.+)/;
                  f._rxInt = /^-?\d+$/;
                  f._opt = function(opt, rv) {
                    const m = f._rx.exec(opt);
                    rv[0] = m ? m[1] : opt;
                    rv[1] = m ? f._rxInt.test(m[2]) ? +m[2] : m[2] : true;
                  };
                }
                const rc = {}, ov = [0, 0];
                let i = 0, k;
                while (k = capi.sqlite3_compileoption_get(i++)) {
                  f._opt(k, ov);
                  rc[ov[0]] = ov[1];
                }
                return f._result = rc;
              } else if (Array.isArray(optName)) {
                const rc = {};
                optName.forEach((v2) => {
                  rc[v2] = capi.sqlite3_compileoption_used(v2);
                });
                return rc;
              } else if ("object" === typeof optName) {
                Object.keys(optName).forEach((k) => {
                  optName[k] = capi.sqlite3_compileoption_used(k);
                });
                return optName;
              }
              return "string" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;
            }, "f");
            wasm2.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {
              restore: wasm2.exports.sqlite3__wasm_pstack_restore,
              alloc: /* @__PURE__ */ __name(function(n2) {
                if ("string" === typeof n2 && !(n2 = wasm2.sizeofIR(n2))) {
                  WasmAllocError.toss(
                    "Invalid value for pstack.alloc(",
                    arguments[0],
                    ")"
                  );
                }
                return wasm2.exports.sqlite3__wasm_pstack_alloc(n2) || WasmAllocError.toss(
                  "Could not allocate",
                  n2,
                  "bytes from the pstack."
                );
              }, "alloc"),
              allocChunks: /* @__PURE__ */ __name(function(n2, sz) {
                if ("string" === typeof sz && !(sz = wasm2.sizeofIR(sz))) {
                  WasmAllocError.toss(
                    "Invalid size value for allocChunks(",
                    arguments[1],
                    ")"
                  );
                }
                const mem = wasm2.pstack.alloc(n2 * sz);
                const rc = [];
                let i = 0, offset = 0;
                for (; i < n2; ++i, offset += sz) rc.push(mem + offset);
                return rc;
              }, "allocChunks"),
              allocPtr: /* @__PURE__ */ __name((n2 = 1, safePtrSize = true) => {
                return 1 === n2 ? wasm2.pstack.alloc(safePtrSize ? 8 : wasm2.ptrSizeof) : wasm2.pstack.allocChunks(n2, safePtrSize ? 8 : wasm2.ptrSizeof);
              }, "allocPtr"),
              call: /* @__PURE__ */ __name(function(f) {
                const stackPos = wasm2.pstack.pointer;
                try {
                  return f(sqlite3);
                } finally {
                  wasm2.pstack.restore(stackPos);
                }
              }, "call")
            });
            Object.defineProperties(wasm2.pstack, {
              pointer: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm2.exports.sqlite3__wasm_pstack_ptr
              },
              quota: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm2.exports.sqlite3__wasm_pstack_quota
              },
              remaining: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm2.exports.sqlite3__wasm_pstack_remaining
              }
            });
            capi.sqlite3_randomness = (...args) => {
              if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {
                const ta = args[0];
                if (0 === ta.byteLength) {
                  wasm2.exports.sqlite3_randomness(0, 0);
                  return ta;
                }
                const stack = wasm2.pstack.pointer;
                try {
                  let n2 = ta.byteLength, offset = 0;
                  const r3 = wasm2.exports.sqlite3_randomness;
                  const heap = wasm2.heap8u();
                  const nAlloc = n2 < 512 ? n2 : 512;
                  const ptr = wasm2.pstack.alloc(nAlloc);
                  do {
                    const j = n2 > nAlloc ? nAlloc : n2;
                    r3(j, ptr);
                    ta.set(typedArrayPart(heap, ptr, ptr + j), offset);
                    n2 -= j;
                    offset += j;
                  } while (n2 > 0);
                } catch (e3) {
                  console.error(
                    "Highly unexpected (and ignored!) exception in sqlite3_randomness():",
                    e3
                  );
                } finally {
                  wasm2.pstack.restore(stack);
                }
                return ta;
              }
              wasm2.exports.sqlite3_randomness(...args);
            };
            let __wasmfsOpfsDir = void 0;
            capi.sqlite3_wasmfs_opfs_dir = function() {
              if (void 0 !== __wasmfsOpfsDir) return __wasmfsOpfsDir;
              const pdir = config2.wasmfsOpfsDir;
              if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle) {
                return __wasmfsOpfsDir = "";
              }
              try {
                if (pdir && 0 === wasm2.xCallWrapped(
                  "sqlite3__wasm_init_wasmfs",
                  "i32",
                  ["string"],
                  pdir
                )) {
                  return __wasmfsOpfsDir = pdir;
                } else {
                  return __wasmfsOpfsDir = "";
                }
              } catch (e3) {
                return __wasmfsOpfsDir = "";
              }
            };
            capi.sqlite3_wasmfs_filename_is_persistent = function(name) {
              const p = capi.sqlite3_wasmfs_opfs_dir();
              return p && name ? name.startsWith(p + "/") : false;
            };
            capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {
              try {
                const pK = capi.sqlite3_vfs_find(vfsName);
                if (!pK) return false;
                else if (!pDb2) {
                  return pK === capi.sqlite3_vfs_find(0) ? pK : false;
                } else {
                  return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;
                }
              } catch (e3) {
                return false;
              }
            };
            capi.sqlite3_js_vfs_list = function() {
              const rc = [];
              let pVfs = capi.sqlite3_vfs_find(0);
              while (pVfs) {
                const oVfs = new capi.sqlite3_vfs(pVfs);
                rc.push(wasm2.cstrToJs(oVfs.$zName));
                pVfs = oVfs.$pNext;
                oVfs.dispose();
              }
              return rc;
            };
            capi.sqlite3_js_db_export = function(pDb2, schema = 0) {
              pDb2 = wasm2.xWrap.testConvertArg("sqlite3*", pDb2);
              if (!pDb2) toss3("Invalid sqlite3* argument.");
              if (!wasm2.bigIntEnabled) toss3("BigInt64 support is not enabled.");
              const scope = wasm2.scopedAllocPush();
              let pOut;
              try {
                const pSize = wasm2.scopedAlloc(8 + wasm2.ptrSizeof);
                const ppOut = pSize + 8;
                const zSchema = schema ? wasm2.isPtr(schema) ? schema : wasm2.scopedAllocCString("" + schema) : 0;
                let rc = wasm2.exports.sqlite3__wasm_db_serialize(
                  pDb2,
                  zSchema,
                  ppOut,
                  pSize,
                  0
                );
                if (rc) {
                  toss3(
                    "Database serialization failed with code",
                    sqlite3.capi.sqlite3_js_rc_str(rc)
                  );
                }
                pOut = wasm2.peekPtr(ppOut);
                const nOut = wasm2.peek(pSize, "i64");
                rc = nOut ? wasm2.heap8u().slice(pOut, pOut + Number(nOut)) : new Uint8Array();
                return rc;
              } finally {
                if (pOut) wasm2.exports.sqlite3_free(pOut);
                wasm2.scopedAllocPop(scope);
              }
            };
            capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);
            capi.sqlite3_js_aggregate_context = (pCtx, n2) => {
              return capi.sqlite3_aggregate_context(pCtx, n2) || (n2 ? WasmAllocError.toss(
                "Cannot allocate",
                n2,
                "bytes for sqlite3_aggregate_context()"
              ) : 0);
            };
            capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {
              let pData;
              if (data && wasm2.isPtr(data)) {
                pData = data;
              } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                pData = wasm2.allocFromTypedArray(data);
                if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
                  dataLen = data.byteLength;
                }
              } else {
                SQLite3Error.toss(
                  "Invalid 2nd argument for sqlite3_js_posix_create_file()."
                );
              }
              try {
                if (!util.isInt32(dataLen) || dataLen < 0) {
                  SQLite3Error.toss(
                    "Invalid 3rd argument for sqlite3_js_posix_create_file()."
                  );
                }
                const rc = util.sqlite3__wasm_posix_create_file(
                  filename,
                  pData,
                  dataLen
                );
                if (rc)
                  SQLite3Error.toss(
                    "Creation of file failed with sqlite3 result code",
                    capi.sqlite3_js_rc_str(rc)
                  );
              } finally {
                wasm2.dealloc(pData);
              }
            };
            capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {
              config2.warn(
                "sqlite3_js_vfs_create_file() is deprecated and",
                "should be avoided because it can lead to C-level crashes.",
                "See its documentation for alternative options."
              );
              let pData;
              if (data) {
                if (wasm2.isPtr(data)) {
                  pData = data;
                } else if (data instanceof ArrayBuffer) {
                  data = new Uint8Array(data);
                }
                if (data instanceof Uint8Array) {
                  pData = wasm2.allocFromTypedArray(data);
                  if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {
                    dataLen = data.byteLength;
                  }
                } else {
                  SQLite3Error.toss(
                    "Invalid 3rd argument type for sqlite3_js_vfs_create_file()."
                  );
                }
              } else {
                pData = 0;
              }
              if (!util.isInt32(dataLen) || dataLen < 0) {
                wasm2.dealloc(pData);
                SQLite3Error.toss(
                  "Invalid 4th argument for sqlite3_js_vfs_create_file()."
                );
              }
              try {
                const rc = util.sqlite3__wasm_vfs_create_file(
                  vfs,
                  filename,
                  pData,
                  dataLen
                );
                if (rc)
                  SQLite3Error.toss(
                    "Creation of file failed with sqlite3 result code",
                    capi.sqlite3_js_rc_str(rc)
                  );
              } finally {
                wasm2.dealloc(pData);
              }
            };
            capi.sqlite3_js_sql_to_string = (sql) => {
              if ("string" === typeof sql) {
                return sql;
              }
              const x = flexibleString(v);
              return x === v ? void 0 : x;
            };
            if (util.isUIThread()) {
              const __kvvfsInfo = /* @__PURE__ */ __name(function(which) {
                const rc = /* @__PURE__ */ Object.create(null);
                rc.prefix = "kvvfs-" + which;
                rc.stores = [];
                if ("session" === which || "" === which)
                  rc.stores.push(globalThis.sessionStorage);
                if ("local" === which || "" === which)
                  rc.stores.push(globalThis.localStorage);
                return rc;
              }, "__kvvfsInfo");
              capi.sqlite3_js_kvvfs_clear = function(which = "") {
                let rc = 0;
                const kvinfo = __kvvfsInfo(which);
                kvinfo.stores.forEach((s3) => {
                  const toRm = [];
                  let i;
                  for (i = 0; i < s3.length; ++i) {
                    const k = s3.key(i);
                    if (k.startsWith(kvinfo.prefix)) toRm.push(k);
                  }
                  toRm.forEach((kk) => s3.removeItem(kk));
                  rc += toRm.length;
                });
                return rc;
              };
              capi.sqlite3_js_kvvfs_size = function(which = "") {
                let sz = 0;
                const kvinfo = __kvvfsInfo(which);
                kvinfo.stores.forEach((s3) => {
                  let i;
                  for (i = 0; i < s3.length; ++i) {
                    const k = s3.key(i);
                    if (k.startsWith(kvinfo.prefix)) {
                      sz += k.length;
                      sz += s3.getItem(k).length;
                    }
                  }
                });
                return sz * 2;
              };
            }
            capi.sqlite3_db_config = function(pDb2, op, ...args) {
              switch (op) {
                case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
                case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
                case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
                case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
                case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
                case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
                case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
                case capi.SQLITE_DBCONFIG_RESET_DATABASE:
                case capi.SQLITE_DBCONFIG_DEFENSIVE:
                case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
                case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
                case capi.SQLITE_DBCONFIG_DQS_DML:
                case capi.SQLITE_DBCONFIG_DQS_DDL:
                case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
                case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
                case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
                case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
                case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
                case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE:
                case capi.SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE:
                case capi.SQLITE_DBCONFIG_ENABLE_COMMENTS:
                  if (!this.ip) {
                    this.ip = wasm2.xWrap("sqlite3__wasm_db_config_ip", "int", [
                      "sqlite3*",
                      "int",
                      "int",
                      "*"
                    ]);
                  }
                  return this.ip(pDb2, op, args[0], args[1] || 0);
                case capi.SQLITE_DBCONFIG_LOOKASIDE:
                  if (!this.pii) {
                    this.pii = wasm2.xWrap("sqlite3__wasm_db_config_pii", "int", [
                      "sqlite3*",
                      "int",
                      "*",
                      "int",
                      "int"
                    ]);
                  }
                  return this.pii(pDb2, op, args[0], args[1], args[2]);
                case capi.SQLITE_DBCONFIG_MAINDBNAME:
                  if (!this.s) {
                    this.s = wasm2.xWrap("sqlite3__wasm_db_config_s", "int", [
                      "sqlite3*",
                      "int",
                      "string:static"
                    ]);
                  }
                  return this.s(pDb2, op, args[0]);
                default:
                  return capi.SQLITE_MISUSE;
              }
            }.bind(/* @__PURE__ */ Object.create(null));
            capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {
              let arg;
              const valType = capi.sqlite3_value_type(pVal);
              switch (valType) {
                case capi.SQLITE_INTEGER:
                  if (wasm2.bigIntEnabled) {
                    arg = capi.sqlite3_value_int64(pVal);
                    if (util.bigIntFitsDouble(arg)) arg = Number(arg);
                  } else arg = capi.sqlite3_value_double(pVal);
                  break;
                case capi.SQLITE_FLOAT:
                  arg = capi.sqlite3_value_double(pVal);
                  break;
                case capi.SQLITE_TEXT:
                  arg = capi.sqlite3_value_text(pVal);
                  break;
                case capi.SQLITE_BLOB: {
                  const n2 = capi.sqlite3_value_bytes(pVal);
                  const pBlob = capi.sqlite3_value_blob(pVal);
                  if (n2 && !pBlob)
                    sqlite3.WasmAllocError.toss(
                      "Cannot allocate memory for blob argument of",
                      n2,
                      "byte(s)"
                    );
                  arg = n2 ? wasm2.heap8u().slice(pBlob, pBlob + Number(n2)) : null;
                  break;
                }
                case capi.SQLITE_NULL:
                  arg = null;
                  break;
                default:
                  if (throwIfCannotConvert) {
                    toss3(
                      capi.SQLITE_MISMATCH,
                      "Unhandled sqlite3_value_type():",
                      valType
                    );
                  }
                  arg = void 0;
              }
              return arg;
            };
            capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {
              let i;
              const tgt = [];
              for (i = 0; i < argc; ++i) {
                tgt.push(
                  capi.sqlite3_value_to_js(
                    wasm2.peekPtr(pArgv + wasm2.ptrSizeof * i),
                    throwIfCannotConvert
                  )
                );
              }
              return tgt;
            };
            capi.sqlite3_result_error_js = function(pCtx, e3) {
              if (e3 instanceof WasmAllocError) {
                capi.sqlite3_result_error_nomem(pCtx);
              } else {
                capi.sqlite3_result_error(pCtx, "" + e3, -1);
              }
            };
            capi.sqlite3_result_js = function(pCtx, val) {
              if (val instanceof Error) {
                capi.sqlite3_result_error_js(pCtx, val);
                return;
              }
              try {
                switch (typeof val) {
                  case "undefined":
                    break;
                  case "boolean":
                    capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                    break;
                  case "bigint":
                    if (util.bigIntFits32(val)) {
                      capi.sqlite3_result_int(pCtx, Number(val));
                    } else if (util.bigIntFitsDouble(val)) {
                      capi.sqlite3_result_double(pCtx, Number(val));
                    } else if (wasm2.bigIntEnabled) {
                      if (util.bigIntFits64(val))
                        capi.sqlite3_result_int64(pCtx, val);
                      else
                        toss3(
                          "BigInt value",
                          val.toString(),
                          "is too BigInt for int64."
                        );
                    } else {
                      toss3("BigInt value", val.toString(), "is too BigInt.");
                    }
                    break;
                  case "number": {
                    let f;
                    if (util.isInt32(val)) {
                      f = capi.sqlite3_result_int;
                    } else if (wasm2.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {
                      f = capi.sqlite3_result_int64;
                    } else {
                      f = capi.sqlite3_result_double;
                    }
                    f(pCtx, val);
                    break;
                  }
                  case "string": {
                    const [p, n2] = wasm2.allocCString(val, true);
                    capi.sqlite3_result_text(pCtx, p, n2, capi.SQLITE_WASM_DEALLOC);
                    break;
                  }
                  case "object":
                    if (null === val) {
                      capi.sqlite3_result_null(pCtx);
                      break;
                    } else if (util.isBindableTypedArray(val)) {
                      const pBlob = wasm2.allocFromTypedArray(val);
                      capi.sqlite3_result_blob(
                        pCtx,
                        pBlob,
                        val.byteLength,
                        capi.SQLITE_WASM_DEALLOC
                      );
                      break;
                    }
                  default:
                    toss3(
                      "Don't not how to handle this UDF result value:",
                      typeof val,
                      val
                    );
                }
              } catch (e3) {
                capi.sqlite3_result_error_js(pCtx, e3);
              }
            };
            capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {
              const v2 = capi.sqlite3_column_value(pStmt, iCol);
              return 0 === v2 ? void 0 : capi.sqlite3_value_to_js(v2, throwIfCannotConvert);
            };
            const __newOldValue = function(pObj, iCol, impl) {
              impl = capi[impl];
              if (!this.ptr) this.ptr = wasm2.allocPtr();
              else wasm2.pokePtr(this.ptr, 0);
              const rc = impl(pObj, iCol, this.ptr);
              if (rc)
                return SQLite3Error.toss(
                  rc,
                  arguments[2] + "() failed with code " + rc
                );
              const pv = wasm2.peekPtr(this.ptr);
              return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;
            }.bind(/* @__PURE__ */ Object.create(null));
            capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_new");
            capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_old");
            capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_new");
            capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_old");
            const sqlite3 = {
              WasmAllocError,
              SQLite3Error,
              capi,
              util,
              wasm: wasm2,
              config: config2,
              version: /* @__PURE__ */ Object.create(null),
              client: void 0,
              asyncPostInit: /* @__PURE__ */ __name(async function ff() {
                if (ff.isReady instanceof Promise) return ff.isReady;
                let lia = sqlite3ApiBootstrap.initializersAsync;
                delete sqlite3ApiBootstrap.initializersAsync;
                const postInit = /* @__PURE__ */ __name(async () => {
                  if (!sqlite3.__isUnderTest) {
                    delete sqlite3.util;
                    delete sqlite3.StructBinder;
                  }
                  return sqlite3;
                }, "postInit");
                const catcher = /* @__PURE__ */ __name((e3) => {
                  config2.error("an async sqlite3 initializer failed:", e3);
                  throw e3;
                }, "catcher");
                if (!lia || !lia.length) {
                  return ff.isReady = postInit().catch(catcher);
                }
                lia = lia.map((f) => {
                  return f instanceof Function ? async (x) => f(sqlite3) : f;
                });
                lia.push(postInit);
                let p = Promise.resolve(sqlite3);
                while (lia.length) p = p.then(lia.shift());
                return ff.isReady = p.catch(catcher);
              }, "ff"),
              scriptInfo: void 0
            };
            try {
              sqlite3ApiBootstrap.initializers.forEach((f) => {
                f(sqlite3);
              });
            } catch (e3) {
              console.error("sqlite3 bootstrap initializer threw:", e3);
              throw e3;
            }
            delete sqlite3ApiBootstrap.initializers;
            sqlite3ApiBootstrap.sqlite3 = sqlite3;
            return sqlite3;
          }, "sqlite3ApiBootstrap");
          globalThis.sqlite3ApiBootstrap.initializers = [];
          globalThis.sqlite3ApiBootstrap.initializersAsync = [];
          globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);
          globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;
          globalThis.WhWasmUtilInstaller = function(target) {
            "use strict";
            if (void 0 === target.bigIntEnabled) {
              target.bigIntEnabled = !!globalThis["BigInt64Array"];
            }
            const toss = /* @__PURE__ */ __name((...args) => {
              throw new Error(args.join(" "));
            }, "toss");
            if (!target.exports) {
              Object.defineProperty(target, "exports", {
                enumerable: true,
                configurable: true,
                get: /* @__PURE__ */ __name(() => target.instance && target.instance.exports, "get")
              });
            }
            const ptrIR = target.pointerIR || "i32";
            const ptrSizeof = target.ptrSizeof = "i32" === ptrIR ? 4 : "i64" === ptrIR ? 8 : toss("Unhandled ptrSizeof:", ptrIR);
            const cache = /* @__PURE__ */ Object.create(null);
            cache.heapSize = 0;
            cache.memory = null;
            cache.freeFuncIndexes = [];
            cache.scopedAlloc = [];
            cache.utf8Decoder = new TextDecoder();
            cache.utf8Encoder = new TextEncoder("utf-8");
            target.sizeofIR = (n2) => {
              switch (n2) {
                case "i8":
                  return 1;
                case "i16":
                  return 2;
                case "i32":
                case "f32":
                case "float":
                  return 4;
                case "i64":
                case "f64":
                case "double":
                  return 8;
                case "*":
                  return ptrSizeof;
                default:
                  return ("" + n2).endsWith("*") ? ptrSizeof : void 0;
              }
            };
            const heapWrappers = /* @__PURE__ */ __name(function() {
              if (!cache.memory) {
                cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;
              } else if (cache.heapSize === cache.memory.buffer.byteLength) {
                return cache;
              }
              const b = cache.memory.buffer;
              cache.HEAP8 = new Int8Array(b);
              cache.HEAP8U = new Uint8Array(b);
              cache.HEAP16 = new Int16Array(b);
              cache.HEAP16U = new Uint16Array(b);
              cache.HEAP32 = new Int32Array(b);
              cache.HEAP32U = new Uint32Array(b);
              if (target.bigIntEnabled) {
                cache.HEAP64 = new BigInt64Array(b);
                cache.HEAP64U = new BigUint64Array(b);
              }
              cache.HEAP32F = new Float32Array(b);
              cache.HEAP64F = new Float64Array(b);
              cache.heapSize = b.byteLength;
              return cache;
            }, "heapWrappers");
            target.heap8 = () => heapWrappers().HEAP8;
            target.heap8u = () => heapWrappers().HEAP8U;
            target.heap16 = () => heapWrappers().HEAP16;
            target.heap16u = () => heapWrappers().HEAP16U;
            target.heap32 = () => heapWrappers().HEAP32;
            target.heap32u = () => heapWrappers().HEAP32U;
            target.heapForSize = function(n2, unsigned = true) {
              let ctor;
              const c2 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
              switch (n2) {
                case Int8Array:
                  return c2.HEAP8;
                case Uint8Array:
                  return c2.HEAP8U;
                case Int16Array:
                  return c2.HEAP16;
                case Uint16Array:
                  return c2.HEAP16U;
                case Int32Array:
                  return c2.HEAP32;
                case Uint32Array:
                  return c2.HEAP32U;
                case 8:
                  return unsigned ? c2.HEAP8U : c2.HEAP8;
                case 16:
                  return unsigned ? c2.HEAP16U : c2.HEAP16;
                case 32:
                  return unsigned ? c2.HEAP32U : c2.HEAP32;
                case 64:
                  if (c2.HEAP64) return unsigned ? c2.HEAP64U : c2.HEAP64;
                  break;
                default:
                  if (target.bigIntEnabled) {
                    if (n2 === globalThis["BigUint64Array"]) return c2.HEAP64U;
                    else if (n2 === globalThis["BigInt64Array"]) return c2.HEAP64;
                    break;
                  }
              }
              toss(
                "Invalid heapForSize() size: expecting 8, 16, 32,",
                "or (if BigInt is enabled) 64."
              );
            };
            target.functionTable = function() {
              return target.exports.__indirect_function_table;
            };
            target.functionEntry = function(fptr) {
              const ft = target.functionTable();
              return fptr < ft.length ? ft.get(fptr) : void 0;
            };
            target.jsFuncToWasm = /* @__PURE__ */ __name(function f(func, sig) {
              if (!f._) {
                f._ = {
                  sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {
                    i: "i32",
                    p: "i32",
                    P: "i32",
                    s: "i32",
                    j: "i64",
                    f: "f32",
                    d: "f64"
                  }),
                  typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {
                    f64: 124,
                    f32: 125,
                    i64: 126,
                    i32: 127
                  }),
                  uleb128Encode: /* @__PURE__ */ __name(function(tgt, method, n2) {
                    if (n2 < 128) tgt[method](n2);
                    else tgt[method](n2 % 128 | 128, n2 >> 7);
                  }, "uleb128Encode"),
                  rxJSig: /^(\w)\((\w*)\)$/,
                  sigParams: /* @__PURE__ */ __name(function(sig2) {
                    const m = f._.rxJSig.exec(sig2);
                    return m ? m[2] : sig2.substr(1);
                  }, "sigParams"),
                  letterType: /* @__PURE__ */ __name((x) => f._.sigTypes[x] || toss("Invalid signature letter:", x), "letterType"),
                  pushSigType: /* @__PURE__ */ __name((dest, letter) => dest.push(f._.typeCodes[f._.letterType(letter)]), "pushSigType")
                };
              }
              if ("string" === typeof func) {
                const x = sig;
                sig = func;
                func = x;
              }
              const sigParams = f._.sigParams(sig);
              const wasmCode = [1, 96];
              f._.uleb128Encode(wasmCode, "push", sigParams.length);
              for (const x of sigParams) f._.pushSigType(wasmCode, x);
              if ("v" === sig[0]) wasmCode.push(0);
              else {
                wasmCode.push(1);
                f._.pushSigType(wasmCode, sig[0]);
              }
              f._.uleb128Encode(wasmCode, "unshift", wasmCode.length);
              wasmCode.unshift(
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1
              );
              wasmCode.push(
                2,
                7,
                1,
                1,
                101,
                1,
                102,
                0,
                0,
                7,
                5,
                1,
                1,
                102,
                0,
                0
              );
              return new WebAssembly.Instance(
                new WebAssembly.Module(new Uint8Array(wasmCode)),
                {
                  e: { f: func }
                }
              ).exports["f"];
            }, "f");
            const __installFunction = /* @__PURE__ */ __name(function f(func, sig, scoped) {
              if (scoped && !cache.scopedAlloc.length) {
                toss("No scopedAllocPush() scope is active.");
              }
              if ("string" === typeof func) {
                const x = sig;
                sig = func;
                func = x;
              }
              if ("string" !== typeof sig || !(func instanceof Function)) {
                toss(
                  "Invalid arguments: expecting (function,signature) or (signature,function)."
                );
              }
              const ft = target.functionTable();
              const oldLen = ft.length;
              let ptr;
              while (cache.freeFuncIndexes.length) {
                ptr = cache.freeFuncIndexes.pop();
                if (ft.get(ptr)) {
                  ptr = null;
                  continue;
                } else {
                  break;
                }
              }
              if (!ptr) {
                ptr = oldLen;
                ft.grow(1);
              }
              try {
                ft.set(ptr, func);
                if (scoped) {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
                }
                return ptr;
              } catch (e3) {
                if (!(e3 instanceof TypeError)) {
                  if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
                  throw e3;
                }
              }
              try {
                const fptr = target.jsFuncToWasm(func, sig);
                ft.set(ptr, fptr);
                if (scoped) {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
                }
              } catch (e3) {
                if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
                throw e3;
              }
              return ptr;
            }, "f");
            target.installFunction = (func, sig) => __installFunction(func, sig, false);
            target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);
            target.uninstallFunction = function(ptr) {
              if (!ptr && 0 !== ptr) return void 0;
              const fi = cache.freeFuncIndexes;
              const ft = target.functionTable();
              fi.push(ptr);
              const rc = ft.get(ptr);
              ft.set(ptr, null);
              return rc;
            };
            target.peek = /* @__PURE__ */ __name(function f(ptr, type = "i8") {
              if (type.endsWith("*")) type = ptrIR;
              const c2 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
              const list = Array.isArray(ptr) ? [] : void 0;
              let rc;
              do {
                if (list) ptr = arguments[0].shift();
                switch (type) {
                  case "i1":
                  case "i8":
                    rc = c2.HEAP8[ptr >> 0];
                    break;
                  case "i16":
                    rc = c2.HEAP16[ptr >> 1];
                    break;
                  case "i32":
                    rc = c2.HEAP32[ptr >> 2];
                    break;
                  case "float":
                  case "f32":
                    rc = c2.HEAP32F[ptr >> 2];
                    break;
                  case "double":
                  case "f64":
                    rc = Number(c2.HEAP64F[ptr >> 3]);
                    break;
                  case "i64":
                    if (target.bigIntEnabled) {
                      rc = BigInt(c2.HEAP64[ptr >> 3]);
                      break;
                    }
                  default:
                    toss("Invalid type for peek():", type);
                }
                if (list) list.push(rc);
              } while (list && arguments[0].length);
              return list || rc;
            }, "f");
            target.poke = function(ptr, value, type = "i8") {
              if (type.endsWith("*")) type = ptrIR;
              const c2 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
              for (const p of Array.isArray(ptr) ? ptr : [ptr]) {
                switch (type) {
                  case "i1":
                  case "i8":
                    c2.HEAP8[p >> 0] = value;
                    continue;
                  case "i16":
                    c2.HEAP16[p >> 1] = value;
                    continue;
                  case "i32":
                    c2.HEAP32[p >> 2] = value;
                    continue;
                  case "float":
                  case "f32":
                    c2.HEAP32F[p >> 2] = value;
                    continue;
                  case "double":
                  case "f64":
                    c2.HEAP64F[p >> 3] = value;
                    continue;
                  case "i64":
                    if (c2.HEAP64) {
                      c2.HEAP64[p >> 3] = BigInt(value);
                      continue;
                    }
                  default:
                    toss("Invalid type for poke(): " + type);
                }
              }
              return this;
            };
            target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);
            target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);
            target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i8");
            target.poke8 = (ptr, value) => target.poke(ptr, value, "i8");
            target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i16");
            target.poke16 = (ptr, value) => target.poke(ptr, value, "i16");
            target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i32");
            target.poke32 = (ptr, value) => target.poke(ptr, value, "i32");
            target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i64");
            target.poke64 = (ptr, value) => target.poke(ptr, value, "i64");
            target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f32");
            target.poke32f = (ptr, value) => target.poke(ptr, value, "f32");
            target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f64");
            target.poke64f = (ptr, value) => target.poke(ptr, value, "f64");
            target.getMemValue = target.peek;
            target.getPtrValue = target.peekPtr;
            target.setMemValue = target.poke;
            target.setPtrValue = target.pokePtr;
            target.isPtr32 = (ptr) => "number" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;
            target.isPtr = target.isPtr32;
            target.cstrlen = function(ptr) {
              if (!ptr || !target.isPtr(ptr)) return null;
              const h = heapWrappers().HEAP8U;
              let pos = ptr;
              for (; h[pos] !== 0; ++pos) {
              }
              return pos - ptr;
            };
            const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
            } : SharedArrayBuffer;
            const __utf8Decode = /* @__PURE__ */ __name(function(arrayBuffer, begin, end) {
              return cache.utf8Decoder.decode(
                arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
              );
            }, "__utf8Decode");
            target.cstrToJs = function(ptr) {
              const n2 = target.cstrlen(ptr);
              return n2 ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n2) : null === n2 ? n2 : "";
            };
            target.jstrlen = function(str) {
              if ("string" !== typeof str) return null;
              const n2 = str.length;
              let len = 0;
              for (let i = 0; i < n2; ++i) {
                let u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                  u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
                }
                if (u <= 127) ++len;
                else if (u <= 2047) len += 2;
                else if (u <= 65535) len += 3;
                else len += 4;
              }
              return len;
            };
            target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true) {
              if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {
                toss("jstrcpy() target must be an Int8Array or Uint8Array.");
              }
              if (maxBytes < 0) maxBytes = tgt.length - offset;
              if (!(maxBytes > 0) || !(offset >= 0)) return 0;
              let i = 0, max = jstr.length;
              const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
              for (; i < max && offset < end; ++i) {
                let u = jstr.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                  u = 65536 + ((u & 1023) << 10) | jstr.charCodeAt(++i) & 1023;
                }
                if (u <= 127) {
                  if (offset >= end) break;
                  tgt[offset++] = u;
                } else if (u <= 2047) {
                  if (offset + 1 >= end) break;
                  tgt[offset++] = 192 | u >> 6;
                  tgt[offset++] = 128 | u & 63;
                } else if (u <= 65535) {
                  if (offset + 2 >= end) break;
                  tgt[offset++] = 224 | u >> 12;
                  tgt[offset++] = 128 | u >> 6 & 63;
                  tgt[offset++] = 128 | u & 63;
                } else {
                  if (offset + 3 >= end) break;
                  tgt[offset++] = 240 | u >> 18;
                  tgt[offset++] = 128 | u >> 12 & 63;
                  tgt[offset++] = 128 | u >> 6 & 63;
                  tgt[offset++] = 128 | u & 63;
                }
              }
              if (addNul) tgt[offset++] = 0;
              return offset - begin;
            };
            target.cstrncpy = function(tgtPtr, srcPtr, n2) {
              if (!tgtPtr || !srcPtr)
                toss("cstrncpy() does not accept NULL strings.");
              if (n2 < 0) n2 = target.cstrlen(strPtr) + 1;
              else if (!(n2 > 0)) return 0;
              const heap = target.heap8u();
              let i = 0, ch;
              for (; i < n2 && (ch = heap[srcPtr + i]); ++i) {
                heap[tgtPtr + i] = ch;
              }
              if (i < n2) heap[tgtPtr + i++] = 0;
              return i;
            };
            target.jstrToUintArray = (str, addNul = false) => {
              return cache.utf8Encoder.encode(addNul ? str + "\0" : str);
            };
            const __affirmAlloc = /* @__PURE__ */ __name((obj, funcName) => {
              if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {
                toss(
                  "Object is missing alloc() and/or dealloc() function(s)",
                  "required by",
                  funcName + "()."
                );
              }
            }, "__affirmAlloc");
            const __allocCStr = /* @__PURE__ */ __name(function(jstr, returnWithLength, allocator, funcName) {
              __affirmAlloc(target, funcName);
              if ("string" !== typeof jstr) return null;
              if (0) {
                const n2 = target.jstrlen(jstr), ptr = allocator(n2 + 1);
                target.jstrcpy(jstr, target.heap8u(), ptr, n2 + 1, true);
                return returnWithLength ? [ptr, n2] : ptr;
              } else {
                const u = cache.utf8Encoder.encode(jstr), ptr = allocator(u.length + 1), heap = heapWrappers().HEAP8U;
                heap.set(u, ptr);
                heap[ptr + u.length] = 0;
                return returnWithLength ? [ptr, u.length] : ptr;
              }
            }, "__allocCStr");
            target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, "allocCString()");
            target.scopedAllocPush = function() {
              __affirmAlloc(target, "scopedAllocPush");
              const a = [];
              cache.scopedAlloc.push(a);
              return a;
            };
            target.scopedAllocPop = function(state2) {
              __affirmAlloc(target, "scopedAllocPop");
              const n2 = arguments.length ? cache.scopedAlloc.indexOf(state2) : cache.scopedAlloc.length - 1;
              if (n2 < 0) toss("Invalid state object for scopedAllocPop().");
              if (0 === arguments.length) state2 = cache.scopedAlloc[n2];
              cache.scopedAlloc.splice(n2, 1);
              for (let p; p = state2.pop(); ) {
                if (target.functionEntry(p)) {
                  target.uninstallFunction(p);
                } else target.dealloc(p);
              }
            };
            target.scopedAlloc = function(n2) {
              if (!cache.scopedAlloc.length) {
                toss("No scopedAllocPush() scope is active.");
              }
              const p = target.alloc(n2);
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);
              return p;
            };
            Object.defineProperty(target.scopedAlloc, "level", {
              configurable: false,
              enumerable: false,
              get: /* @__PURE__ */ __name(() => cache.scopedAlloc.length, "get"),
              set: /* @__PURE__ */ __name(() => toss("The 'active' property is read-only."), "set")
            });
            target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(
              jstr,
              returnWithLength,
              target.scopedAlloc,
              "scopedAllocCString()"
            );
            const __allocMainArgv = /* @__PURE__ */ __name(function(isScoped, list) {
              const pList = target[isScoped ? "scopedAlloc" : "alloc"](
                (list.length + 1) * target.ptrSizeof
              );
              let i = 0;
              list.forEach((e3) => {
                target.pokePtr(
                  pList + target.ptrSizeof * i++,
                  target[isScoped ? "scopedAllocCString" : "allocCString"]("" + e3)
                );
              });
              target.pokePtr(pList + target.ptrSizeof * i, 0);
              return pList;
            }, "__allocMainArgv");
            target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);
            target.allocMainArgv = (list) => __allocMainArgv(false, list);
            target.cArgvToJs = (argc, pArgv) => {
              const list = [];
              for (let i = 0; i < argc; ++i) {
                const arg = target.peekPtr(pArgv + target.ptrSizeof * i);
                list.push(arg ? target.cstrToJs(arg) : null);
              }
              return list;
            };
            target.scopedAllocCall = function(func) {
              target.scopedAllocPush();
              try {
                return func();
              } finally {
                target.scopedAllocPop();
              }
            };
            const __allocPtr = /* @__PURE__ */ __name(function(howMany, safePtrSize, method) {
              __affirmAlloc(target, method);
              const pIr = safePtrSize ? "i64" : ptrIR;
              let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
              target.poke(m, 0, pIr);
              if (1 === howMany) {
                return m;
              }
              const a = [m];
              for (let i = 1; i < howMany; ++i) {
                m += safePtrSize ? 8 : ptrSizeof;
                a[i] = m;
                target.poke(m, 0, pIr);
              }
              return a;
            }, "__allocPtr");
            target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "alloc");
            target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "scopedAlloc");
            target.xGet = function(name) {
              return target.exports[name] || toss("Cannot find exported symbol:", name);
            };
            const __argcMismatch = /* @__PURE__ */ __name((f, n2) => toss(f + "() requires", n2, "argument(s)."), "__argcMismatch");
            target.xCall = function(fname, ...args) {
              const f = fname instanceof Function ? fname : target.xGet(fname);
              if (!(f instanceof Function))
                toss("Exported symbol", fname, "is not a function.");
              if (f.length !== args.length)
                __argcMismatch(f === fname ? f.name : fname, f.length);
              return 2 === arguments.length && Array.isArray(arguments[1]) ? f.apply(null, arguments[1]) : f.apply(null, args);
            };
            cache.xWrap = /* @__PURE__ */ Object.create(null);
            cache.xWrap.convert = /* @__PURE__ */ Object.create(null);
            cache.xWrap.convert.arg = /* @__PURE__ */ new Map();
            cache.xWrap.convert.result = /* @__PURE__ */ new Map();
            const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;
            if (target.bigIntEnabled) {
              xArg.set("i64", (i) => BigInt(i));
            }
            const __xArgPtr = "i32" === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);
            xArg.set("i32", __xArgPtr).set("i16", (i) => (i | 0) & 65535).set("i8", (i) => (i | 0) & 255).set("f32", (i) => Number(i).valueOf()).set("float", xArg.get("f32")).set("f64", xArg.get("f32")).set("double", xArg.get("f64")).set("int", xArg.get("i32")).set("null", (i) => i).set(null, xArg.get("null")).set("**", __xArgPtr).set("*", __xArgPtr);
            xResult.set("*", __xArgPtr).set("pointer", __xArgPtr).set("number", (v2) => Number(v2)).set("void", (v2) => void 0).set("null", (v2) => v2).set(null, xResult.get("null"));
            {
              const copyToResult = [
                "i8",
                "i16",
                "i32",
                "int",
                "f32",
                "float",
                "f64",
                "double"
              ];
              if (target.bigIntEnabled) copyToResult.push("i64");
              const adaptPtr = xArg.get(ptrIR);
              for (const t2 of copyToResult) {
                xArg.set(t2 + "*", adaptPtr);
                xResult.set(t2 + "*", adaptPtr);
                xResult.set(t2, xArg.get(t2) || toss("Missing arg converter:", t2));
              }
            }
            const __xArgString = /* @__PURE__ */ __name(function(v2) {
              if ("string" === typeof v2) return target.scopedAllocCString(v2);
              return v2 ? __xArgPtr(v2) : null;
            }, "__xArgString");
            xArg.set("string", __xArgString).set("utf8", __xArgString).set("pointer", __xArgString);
            xResult.set("string", (i) => target.cstrToJs(i)).set("utf8", xResult.get("string")).set("string:dealloc", (i) => {
              try {
                return i ? target.cstrToJs(i) : null;
              } finally {
                target.dealloc(i);
              }
            }).set("utf8:dealloc", xResult.get("string:dealloc")).set("json", (i) => JSON.parse(target.cstrToJs(i))).set("json:dealloc", (i) => {
              try {
                return i ? JSON.parse(target.cstrToJs(i)) : null;
              } finally {
                target.dealloc(i);
              }
            });
            const AbstractArgAdapter = class {
              static {
                __name(this, "AbstractArgAdapter");
              }
              constructor(opt) {
                this.name = opt.name || "unnamed adapter";
              }
              convertArg(v2, argv2, argIndex) {
                toss("AbstractArgAdapter must be subclassed.");
              }
            };
            xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
              static {
                __name(this, "FuncPtrAdapter");
              }
              constructor(opt) {
                super(opt);
                if (xArg.FuncPtrAdapter.warnOnUse) {
                  console.warn(
                    "xArg.FuncPtrAdapter is an internal-only API",
                    "and is not intended to be invoked from",
                    "client-level code. Invoked with:",
                    opt
                  );
                }
                this.name = opt.name || "unnamed";
                this.signature = opt.signature;
                if (opt.contextKey instanceof Function) {
                  this.contextKey = opt.contextKey;
                  if (!opt.bindScope) opt.bindScope = "context";
                }
                this.bindScope = opt.bindScope || toss(
                  "FuncPtrAdapter options requires a bindScope (explicit or implied)."
                );
                if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
                  toss(
                    "Invalid options.bindScope (" + opt.bindMod + ") for FuncPtrAdapter. Expecting one of: (" + FuncPtrAdapter.bindScopes.join(", ") + ")"
                  );
                }
                this.isTransient = "transient" === this.bindScope;
                this.isContext = "context" === this.bindScope;
                this.isPermanent = "permanent" === this.bindScope;
                this.singleton = "singleton" === this.bindScope ? [] : void 0;
                this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;
              }
              contextKey(argv2, argIndex) {
                return this;
              }
              contextMap(key2) {
                const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());
                let rc = cm.get(key2);
                if (void 0 === rc) cm.set(key2, rc = []);
                return rc;
              }
              convertArg(v2, argv2, argIndex) {
                let pair = this.singleton;
                if (!pair && this.isContext) {
                  pair = this.contextMap(this.contextKey(argv2, argIndex));
                }
                if (pair && pair[0] === v2) return pair[1];
                if (v2 instanceof Function) {
                  if (this.callProxy) v2 = this.callProxy(v2);
                  const fp = __installFunction(v2, this.signature, this.isTransient);
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      "FuncPtrAdapter installed",
                      this,
                      this.contextKey(argv2, argIndex),
                      "@" + fp,
                      v2
                    );
                  }
                  if (pair) {
                    if (pair[1]) {
                      if (FuncPtrAdapter.debugFuncInstall) {
                        FuncPtrAdapter.debugOut(
                          "FuncPtrAdapter uninstalling",
                          this,
                          this.contextKey(argv2, argIndex),
                          "@" + pair[1],
                          v2
                        );
                      }
                      try {
                        cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                          pair[1]
                        );
                      } catch (e3) {
                      }
                    }
                    pair[0] = v2;
                    pair[1] = fp;
                  }
                  return fp;
                } else if (target.isPtr(v2) || null === v2 || void 0 === v2) {
                  if (pair && pair[1] && pair[1] !== v2) {
                    if (FuncPtrAdapter.debugFuncInstall) {
                      FuncPtrAdapter.debugOut(
                        "FuncPtrAdapter uninstalling",
                        this,
                        this.contextKey(argv2, argIndex),
                        "@" + pair[1],
                        v2
                      );
                    }
                    try {
                      cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                    } catch (e3) {
                    }
                    pair[0] = pair[1] = v2 | 0;
                  }
                  return v2 || 0;
                } else {
                  throw new TypeError(
                    "Invalid FuncPtrAdapter argument type. Expecting a function pointer or a " + (this.name ? this.name + " " : "") + "function matching signature " + this.signature + "."
                  );
                }
              }
            };
            xArg.FuncPtrAdapter.warnOnUse = false;
            xArg.FuncPtrAdapter.debugFuncInstall = false;
            xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);
            xArg.FuncPtrAdapter.bindScopes = [
              "transient",
              "context",
              "singleton",
              "permanent"
            ];
            const __xArgAdapterCheck = /* @__PURE__ */ __name((t2) => xArg.get(t2) || toss("Argument adapter not found:", t2), "__xArgAdapterCheck");
            const __xResultAdapterCheck = /* @__PURE__ */ __name((t2) => xResult.get(t2) || toss("Result adapter not found:", t2), "__xResultAdapterCheck");
            cache.xWrap.convertArg = (t2, ...args) => __xArgAdapterCheck(t2)(...args);
            cache.xWrap.convertArgNoCheck = (t2, ...args) => xArg.get(t2)(...args);
            cache.xWrap.convertResult = (t2, v2) => null === t2 ? v2 : t2 ? __xResultAdapterCheck(t2)(v2) : void 0;
            cache.xWrap.convertResultNoCheck = (t2, v2) => null === t2 ? v2 : t2 ? xResult.get(t2)(v2) : void 0;
            target.xWrap = function(fArg, resultType, ...argTypes) {
              if (3 === arguments.length && Array.isArray(arguments[2])) {
                argTypes = arguments[2];
              }
              if (target.isPtr(fArg)) {
                fArg = target.functionEntry(fArg) || toss("Function pointer not found in WASM function table.");
              }
              const fIsFunc = fArg instanceof Function;
              const xf = fIsFunc ? fArg : target.xGet(fArg);
              if (fIsFunc) fArg = xf.name || "unnamed function";
              if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);
              if (null === resultType && 0 === xf.length) {
                return xf;
              }
              if (void 0 !== resultType && null !== resultType)
                __xResultAdapterCheck(resultType);
              for (const t2 of argTypes) {
                if (t2 instanceof AbstractArgAdapter)
                  xArg.set(t2, (...args) => t2.convertArg(...args));
                else __xArgAdapterCheck(t2);
              }
              const cxw = cache.xWrap;
              if (0 === xf.length) {
                return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));
              }
              return function(...args) {
                if (args.length !== xf.length) __argcMismatch(fArg, xf.length);
                const scope = target.scopedAllocPush();
                try {
                  let i = 0;
                  for (; i < args.length; ++i)
                    args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);
                  return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
                } finally {
                  target.scopedAllocPop(scope);
                }
              };
            };
            const __xAdapter = /* @__PURE__ */ __name(function(func, argc, typeName, adapter, modeName, xcvPart) {
              if ("string" === typeof typeName) {
                if (1 === argc) return xcvPart.get(typeName);
                else if (2 === argc) {
                  if (!adapter) {
                    xcvPart.delete(typeName);
                    return func;
                  } else if (!(adapter instanceof Function)) {
                    toss(modeName, "requires a function argument.");
                  }
                  xcvPart.set(typeName, adapter);
                  return func;
                }
              }
              toss("Invalid arguments to", modeName);
            }, "__xAdapter");
            target.xWrap.resultAdapter = /* @__PURE__ */ __name(function f(typeName, adapter) {
              return __xAdapter(
                f,
                arguments.length,
                typeName,
                adapter,
                "resultAdapter()",
                xResult
              );
            }, "f");
            target.xWrap.argAdapter = /* @__PURE__ */ __name(function f(typeName, adapter) {
              return __xAdapter(
                f,
                arguments.length,
                typeName,
                adapter,
                "argAdapter()",
                xArg
              );
            }, "f");
            target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;
            target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {
              if (Array.isArray(arguments[3])) args = arguments[3];
              return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);
            };
            target.xWrap.testConvertArg = cache.xWrap.convertArg;
            target.xWrap.testConvertResult = cache.xWrap.convertResult;
            return target;
          };
          globalThis.WhWasmUtilInstaller.yawl = function(config2) {
            const wfetch = /* @__PURE__ */ __name(() => fetch(config2.uri, { credentials: "same-origin" }), "wfetch");
            const wui = this;
            const finalThen = /* @__PURE__ */ __name(function(arg) {
              if (config2.wasmUtilTarget) {
                const toss = /* @__PURE__ */ __name((...args) => {
                  throw new Error(args.join(" "));
                }, "toss");
                const tgt = config2.wasmUtilTarget;
                tgt.module = arg.module;
                tgt.instance = arg.instance;
                if (!tgt.instance.exports.memory) {
                  tgt.memory = config2.imports && config2.imports.env && config2.imports.env.memory || toss("Missing 'memory' object!");
                }
                if (!tgt.alloc && arg.instance.exports.malloc) {
                  const exports = arg.instance.exports;
                  tgt.alloc = function(n2) {
                    return exports.malloc(n2) || toss("Allocation of", n2, "bytes failed.");
                  };
                  tgt.dealloc = function(m) {
                    exports.free(m);
                  };
                }
                wui(tgt);
              }
              if (config2.onload) config2.onload(arg, config2);
              return arg;
            }, "finalThen");
            const loadWasm = WebAssembly.instantiateStreaming ? /* @__PURE__ */ __name(function loadWasmStreaming() {
              return WebAssembly.instantiateStreaming(
                wfetch(),
                config2.imports || {}
              ).then(finalThen);
            }, "loadWasmStreaming") : /* @__PURE__ */ __name(function loadWasmOldSchool() {
              return wfetch().then((response) => response.arrayBuffer()).then(
                (bytes) => WebAssembly.instantiate(bytes, config2.imports || {})
              ).then(finalThen);
            }, "loadWasmOldSchool");
            return loadWasm;
          }.bind(globalThis.WhWasmUtilInstaller);
          "use strict";
          globalThis.Jaccwabyt = /* @__PURE__ */ __name(function StructBinderFactory(config2) {
            const toss = /* @__PURE__ */ __name((...args) => {
              throw new Error(args.join(" "));
            }, "toss");
            if (!(config2.heap instanceof WebAssembly.Memory) && !(config2.heap instanceof Function)) {
              toss(
                "config.heap must be WebAssembly.Memory instance or a function."
              );
            }
            ["alloc", "dealloc"].forEach(function(k) {
              config2[k] instanceof Function || toss("Config option '" + k + "' must be a function.");
            });
            const SBF = StructBinderFactory;
            const heap = config2.heap instanceof Function ? config2.heap : () => new Uint8Array(config2.heap.buffer), alloc = config2.alloc, dealloc = config2.dealloc, log3 = config2.log || console.log.bind(console), memberPrefix = config2.memberPrefix || "", memberSuffix = config2.memberSuffix || "", bigIntEnabled = void 0 === config2.bigIntEnabled ? !!globalThis["BigInt64Array"] : !!config2.bigIntEnabled, BigInt2 = globalThis["BigInt"], BigInt64Array2 = globalThis["BigInt64Array"], ptrSizeof = config2.ptrSizeof || 4, ptrIR = config2.ptrIR || "i32";
            if (!SBF.debugFlags) {
              SBF.__makeDebugFlags = function(deriveFrom = null) {
                if (deriveFrom && deriveFrom.__flags)
                  deriveFrom = deriveFrom.__flags;
                const f = /* @__PURE__ */ __name(function f2(flags2) {
                  if (0 === arguments.length) {
                    return f2.__flags;
                  }
                  if (flags2 < 0) {
                    delete f2.__flags.getter;
                    delete f2.__flags.setter;
                    delete f2.__flags.alloc;
                    delete f2.__flags.dealloc;
                  } else {
                    f2.__flags.getter = 0 !== (1 & flags2);
                    f2.__flags.setter = 0 !== (2 & flags2);
                    f2.__flags.alloc = 0 !== (4 & flags2);
                    f2.__flags.dealloc = 0 !== (8 & flags2);
                  }
                  return f2._flags;
                }, "f2");
                Object.defineProperty(f, "__flags", {
                  iterable: false,
                  writable: false,
                  value: Object.create(deriveFrom)
                });
                if (!deriveFrom) f(0);
                return f;
              };
              SBF.debugFlags = SBF.__makeDebugFlags();
            }
            const isLittleEndian = function() {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);
              return new Int16Array(buffer)[0] === 256;
            }();
            const isFuncSig = /* @__PURE__ */ __name((s3) => "(" === s3[1], "isFuncSig");
            const isPtrSig = /* @__PURE__ */ __name((s3) => "p" === s3 || "P" === s3, "isPtrSig");
            const isAutoPtrSig = /* @__PURE__ */ __name((s3) => "P" === s3, "isAutoPtrSig");
            const sigLetter = /* @__PURE__ */ __name((s3) => isFuncSig(s3) ? "p" : s3[0], "sigLetter");
            const sigIR = /* @__PURE__ */ __name(function(s3) {
              switch (sigLetter(s3)) {
                case "c":
                case "C":
                  return "i8";
                case "i":
                  return "i32";
                case "p":
                case "P":
                case "s":
                  return ptrIR;
                case "j":
                  return "i64";
                case "f":
                  return "float";
                case "d":
                  return "double";
              }
              toss("Unhandled signature IR:", s3);
            }, "sigIR");
            const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss("BigInt64Array is not available.");
            const sigDVGetter = /* @__PURE__ */ __name(function(s3) {
              switch (sigLetter(s3)) {
                case "p":
                case "P":
                case "s": {
                  switch (ptrSizeof) {
                    case 4:
                      return "getInt32";
                    case 8:
                      return affirmBigIntArray() && "getBigInt64";
                  }
                  break;
                }
                case "i":
                  return "getInt32";
                case "c":
                  return "getInt8";
                case "C":
                  return "getUint8";
                case "j":
                  return affirmBigIntArray() && "getBigInt64";
                case "f":
                  return "getFloat32";
                case "d":
                  return "getFloat64";
              }
              toss("Unhandled DataView getter for signature:", s3);
            }, "sigDVGetter");
            const sigDVSetter = /* @__PURE__ */ __name(function(s3) {
              switch (sigLetter(s3)) {
                case "p":
                case "P":
                case "s": {
                  switch (ptrSizeof) {
                    case 4:
                      return "setInt32";
                    case 8:
                      return affirmBigIntArray() && "setBigInt64";
                  }
                  break;
                }
                case "i":
                  return "setInt32";
                case "c":
                  return "setInt8";
                case "C":
                  return "setUint8";
                case "j":
                  return affirmBigIntArray() && "setBigInt64";
                case "f":
                  return "setFloat32";
                case "d":
                  return "setFloat64";
              }
              toss("Unhandled DataView setter for signature:", s3);
            }, "sigDVSetter");
            const sigDVSetWrapper = /* @__PURE__ */ __name(function(s3) {
              switch (sigLetter(s3)) {
                case "i":
                case "f":
                case "c":
                case "C":
                case "d":
                  return Number;
                case "j":
                  return affirmBigIntArray() && BigInt2;
                case "p":
                case "P":
                case "s":
                  switch (ptrSizeof) {
                    case 4:
                      return Number;
                    case 8:
                      return affirmBigIntArray() && BigInt2;
                  }
                  break;
              }
              toss("Unhandled DataView set wrapper for signature:", s3);
            }, "sigDVSetWrapper");
            const sPropName = /* @__PURE__ */ __name((s3, k) => s3 + "::" + k, "sPropName");
            const __propThrowOnSet = /* @__PURE__ */ __name(function(structName, propName) {
              return () => toss(sPropName(structName, propName), "is read-only.");
            }, "__propThrowOnSet");
            const __instancePointerMap = /* @__PURE__ */ new WeakMap();
            const xPtrPropName = "(pointer-is-external)";
            const __freeStruct = /* @__PURE__ */ __name(function(ctor, obj, m) {
              if (!m) m = __instancePointerMap.get(obj);
              if (m) {
                __instancePointerMap.delete(obj);
                if (Array.isArray(obj.ondispose)) {
                  let x;
                  while (x = obj.ondispose.shift()) {
                    try {
                      if (x instanceof Function) x.call(obj);
                      else if (x instanceof StructType) x.dispose();
                      else if ("number" === typeof x) dealloc(x);
                    } catch (e3) {
                      console.warn(
                        "ondispose() for",
                        ctor.structName,
                        "@",
                        m,
                        "threw. NOT propagating it.",
                        e3
                      );
                    }
                  }
                } else if (obj.ondispose instanceof Function) {
                  try {
                    obj.ondispose();
                  } catch (e3) {
                    console.warn(
                      "ondispose() for",
                      ctor.structName,
                      "@",
                      m,
                      "threw. NOT propagating it.",
                      e3
                    );
                  }
                }
                delete obj.ondispose;
                if (ctor.debugFlags.__flags.dealloc) {
                  log3(
                    "debug.dealloc:",
                    obj[xPtrPropName] ? "EXTERNAL" : "",
                    ctor.structName,
                    "instance:",
                    ctor.structInfo.sizeof,
                    "bytes @" + m
                  );
                }
                if (!obj[xPtrPropName]) dealloc(m);
              }
            }, "__freeStruct");
            const rop = /* @__PURE__ */ __name((v2) => {
              return {
                configurable: false,
                writable: false,
                iterable: false,
                value: v2
              };
            }, "rop");
            const __allocStruct = /* @__PURE__ */ __name(function(ctor, obj, m) {
              let fill = !m;
              if (m) Object.defineProperty(obj, xPtrPropName, rop(m));
              else {
                m = alloc(ctor.structInfo.sizeof);
                if (!m) toss("Allocation of", ctor.structName, "structure failed.");
              }
              try {
                if (ctor.debugFlags.__flags.alloc) {
                  log3(
                    "debug.alloc:",
                    fill ? "" : "EXTERNAL",
                    ctor.structName,
                    "instance:",
                    ctor.structInfo.sizeof,
                    "bytes @" + m
                  );
                }
                if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
                __instancePointerMap.set(obj, m);
              } catch (e3) {
                __freeStruct(ctor, obj, m);
                throw e3;
              }
            }, "__allocStruct");
            const __memoryDump = /* @__PURE__ */ __name(function() {
              const p = this.pointer;
              return p ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof)) : null;
            }, "__memoryDump");
            const __memberKey = /* @__PURE__ */ __name((k) => memberPrefix + k + memberSuffix, "__memberKey");
            const __memberKeyProp = rop(__memberKey);
            const __lookupMember = /* @__PURE__ */ __name(function(structInfo, memberName, tossIfNotFound = true) {
              let m = structInfo.members[memberName];
              if (!m && (memberPrefix || memberSuffix)) {
                for (const v2 of Object.values(structInfo.members)) {
                  if (v2.key === memberName) {
                    m = v2;
                    break;
                  }
                }
                if (!m && tossIfNotFound) {
                  toss(
                    sPropName(structInfo.name, memberName),
                    "is not a mapped struct member."
                  );
                }
              }
              return m;
            }, "__lookupMember");
            const __memberSignature = /* @__PURE__ */ __name(function f(obj, memberName, emscriptenFormat = false) {
              if (!f._)
                f._ = (x) => x.replace(/[^vipPsjrdcC]/g, "").replace(/[pPscC]/g, "i");
              const m = __lookupMember(obj.structInfo, memberName, true);
              return emscriptenFormat ? f._(m.signature) : m.signature;
            }, "f");
            const __ptrPropDescriptor = {
              configurable: false,
              enumerable: false,
              get: /* @__PURE__ */ __name(function() {
                return __instancePointerMap.get(this);
              }, "get"),
              set: /* @__PURE__ */ __name(() => toss("Cannot assign the 'pointer' property of a struct."), "set")
            };
            const __structMemberKeys = rop(function() {
              const a = [];
              for (const k of Object.keys(this.structInfo.members)) {
                a.push(this.memberKey(k));
              }
              return a;
            });
            const __utf8Decoder = new TextDecoder("utf-8");
            const __utf8Encoder = new TextEncoder();
            const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
            } : SharedArrayBuffer;
            const __utf8Decode = /* @__PURE__ */ __name(function(arrayBuffer, begin, end) {
              return __utf8Decoder.decode(
                arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
              );
            }, "__utf8Decode");
            const __memberIsString = /* @__PURE__ */ __name(function(obj, memberName, tossIfNotFound = false) {
              const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
              return m && 1 === m.signature.length && "s" === m.signature[0] ? m : false;
            }, "__memberIsString");
            const __affirmCStringSignature = /* @__PURE__ */ __name(function(member) {
              if ("s" === member.signature) return;
              toss(
                "Invalid member type signature for C-string value:",
                JSON.stringify(member)
              );
            }, "__affirmCStringSignature");
            const __memberToJsString = /* @__PURE__ */ __name(function f(obj, memberName) {
              const m = __lookupMember(obj.structInfo, memberName, true);
              __affirmCStringSignature(m);
              const addr = obj[m.key];
              if (!addr) return null;
              let pos = addr;
              const mem = heap();
              for (; mem[pos] !== 0; ++pos) {
              }
              return addr === pos ? "" : __utf8Decode(mem, addr, pos);
            }, "f");
            const __addOnDispose = /* @__PURE__ */ __name(function(obj, ...v2) {
              if (obj.ondispose) {
                if (!Array.isArray(obj.ondispose)) {
                  obj.ondispose = [obj.ondispose];
                }
              } else {
                obj.ondispose = [];
              }
              obj.ondispose.push(...v2);
            }, "__addOnDispose");
            const __allocCString = /* @__PURE__ */ __name(function(str) {
              const u = __utf8Encoder.encode(str);
              const mem = alloc(u.length + 1);
              if (!mem) toss("Allocation error while duplicating string:", str);
              const h = heap();
              h.set(u, mem);
              h[mem + u.length] = 0;
              return mem;
            }, "__allocCString");
            const __setMemberCString = /* @__PURE__ */ __name(function(obj, memberName, str) {
              const m = __lookupMember(obj.structInfo, memberName, true);
              __affirmCStringSignature(m);
              const mem = __allocCString(str);
              obj[m.key] = mem;
              __addOnDispose(obj, mem);
              return obj;
            }, "__setMemberCString");
            const StructType = /* @__PURE__ */ __name(function ctor(structName, structInfo) {
              if (arguments[2] !== rop) {
                toss(
                  "Do not call the StructType constructor",
                  "from client-level code."
                );
              }
              Object.defineProperties(this, {
                structName: rop(structName),
                structInfo: rop(structInfo)
              });
            }, "ctor");
            StructType.prototype = Object.create(null, {
              dispose: rop(function() {
                __freeStruct(this.constructor, this);
              }),
              lookupMember: rop(function(memberName, tossIfNotFound = true) {
                return __lookupMember(this.structInfo, memberName, tossIfNotFound);
              }),
              memberToJsString: rop(function(memberName) {
                return __memberToJsString(this, memberName);
              }),
              memberIsString: rop(function(memberName, tossIfNotFound = true) {
                return __memberIsString(this, memberName, tossIfNotFound);
              }),
              memberKey: __memberKeyProp,
              memberKeys: __structMemberKeys,
              memberSignature: rop(function(memberName, emscriptenFormat = false) {
                return __memberSignature(this, memberName, emscriptenFormat);
              }),
              memoryDump: rop(__memoryDump),
              pointer: __ptrPropDescriptor,
              setMemberCString: rop(function(memberName, str) {
                return __setMemberCString(this, memberName, str);
              })
            });
            Object.assign(StructType.prototype, {
              addOnDispose: /* @__PURE__ */ __name(function(...v2) {
                __addOnDispose(this, ...v2);
                return this;
              }, "addOnDispose")
            });
            Object.defineProperties(StructType, {
              allocCString: rop(__allocCString),
              isA: rop((v2) => v2 instanceof StructType),
              hasExternalPointer: rop(
                (v2) => v2 instanceof StructType && !!v2[xPtrPropName]
              ),
              memberKey: __memberKeyProp
            });
            const isNumericValue = /* @__PURE__ */ __name((v2) => Number.isFinite(v2) || v2 instanceof (BigInt2 || Number), "isNumericValue");
            const makeMemberWrapper = /* @__PURE__ */ __name(function f(ctor, name, descr) {
              if (!f._) {
                f._ = { getters: {}, setters: {}, sw: {} };
                const a = ["i", "c", "C", "p", "P", "s", "f", "d", "v()"];
                if (bigIntEnabled) a.push("j");
                a.forEach(function(v2) {
                  f._.getters[v2] = sigDVGetter(v2);
                  f._.setters[v2] = sigDVSetter(v2);
                  f._.sw[v2] = sigDVSetWrapper(v2);
                });
                const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
                f.sigCheck = function(obj, name2, key3, sig) {
                  if (Object.prototype.hasOwnProperty.call(obj, key3)) {
                    toss(obj.structName, "already has a property named", key3 + ".");
                  }
                  rxSig1.test(sig) || rxSig2.test(sig) || toss(
                    "Malformed signature for",
                    sPropName(obj.structName, name2) + ":",
                    sig
                  );
                };
              }
              const key2 = ctor.memberKey(name);
              f.sigCheck(ctor.prototype, name, key2, descr.signature);
              descr.key = key2;
              descr.name = name;
              const sigGlyph = sigLetter(descr.signature);
              const xPropName = sPropName(ctor.prototype.structName, key2);
              const dbg = ctor.prototype.debugFlags.__flags;
              const prop = /* @__PURE__ */ Object.create(null);
              prop.configurable = false;
              prop.enumerable = false;
              prop.get = function() {
                if (dbg.getter) {
                  log3(
                    "debug.getter:",
                    f._.getters[sigGlyph],
                    "for",
                    sigIR(sigGlyph),
                    xPropName,
                    "@",
                    this.pointer,
                    "+",
                    descr.offset,
                    "sz",
                    descr.sizeof
                  );
                }
                let rc = new DataView(
                  heap().buffer,
                  this.pointer + descr.offset,
                  descr.sizeof
                )[f._.getters[sigGlyph]](0, isLittleEndian);
                if (dbg.getter) log3("debug.getter:", xPropName, "result =", rc);
                return rc;
              };
              if (descr.readOnly) {
                prop.set = __propThrowOnSet(ctor.prototype.structName, key2);
              } else {
                prop.set = function(v2) {
                  if (dbg.setter) {
                    log3(
                      "debug.setter:",
                      f._.setters[sigGlyph],
                      "for",
                      sigIR(sigGlyph),
                      xPropName,
                      "@",
                      this.pointer,
                      "+",
                      descr.offset,
                      "sz",
                      descr.sizeof,
                      v2
                    );
                  }
                  if (!this.pointer) {
                    toss("Cannot set struct property on disposed instance.");
                  }
                  if (null === v2) v2 = 0;
                  else
                    while (!isNumericValue(v2)) {
                      if (isAutoPtrSig(descr.signature) && v2 instanceof StructType) {
                        v2 = v2.pointer || 0;
                        if (dbg.setter)
                          log3("debug.setter:", xPropName, "resolved to", v2);
                        break;
                      }
                      toss("Invalid value for pointer-type", xPropName + ".");
                    }
                  new DataView(
                    heap().buffer,
                    this.pointer + descr.offset,
                    descr.sizeof
                  )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v2), isLittleEndian);
                };
              }
              Object.defineProperty(ctor.prototype, key2, prop);
            }, "f");
            const StructBinder = /* @__PURE__ */ __name(function StructBinder2(structName, structInfo) {
              if (1 === arguments.length) {
                structInfo = structName;
                structName = structInfo.name;
              } else if (!structInfo.name) {
                structInfo.name = structName;
              }
              if (!structName) toss("Struct name is required.");
              let lastMember = false;
              Object.keys(structInfo.members).forEach((k) => {
                const m = structInfo.members[k];
                if (!m.sizeof) toss(structName, "member", k, "is missing sizeof.");
                else if (m.sizeof === 1) {
                  m.signature === "c" || m.signature === "C" || toss(
                    "Unexpected sizeof==1 member",
                    sPropName(structInfo.name, k),
                    "with signature",
                    m.signature
                  );
                } else {
                  if (0 !== m.sizeof % 4) {
                    console.warn(
                      "Invalid struct member description =",
                      m,
                      "from",
                      structInfo
                    );
                    toss(
                      structName,
                      "member",
                      k,
                      "sizeof is not aligned. sizeof=" + m.sizeof
                    );
                  }
                  if (0 !== m.offset % 4) {
                    console.warn(
                      "Invalid struct member description =",
                      m,
                      "from",
                      structInfo
                    );
                    toss(
                      structName,
                      "member",
                      k,
                      "offset is not aligned. offset=" + m.offset
                    );
                  }
                }
                if (!lastMember || lastMember.offset < m.offset) lastMember = m;
              });
              if (!lastMember) toss("No member property descriptions found.");
              else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
                toss(
                  "Invalid struct config:",
                  structName,
                  "max member offset (" + lastMember.offset + ") ",
                  "extends past end of struct (sizeof=" + structInfo.sizeof + ")."
                );
              }
              const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));
              const StructCtor = /* @__PURE__ */ __name(function StructCtor2(externalMemory) {
                if (!(this instanceof StructCtor2)) {
                  toss(
                    "The",
                    structName,
                    "constructor may only be called via 'new'."
                  );
                } else if (arguments.length) {
                  if (externalMemory !== (externalMemory | 0) || externalMemory <= 0) {
                    toss("Invalid pointer value for", structName, "constructor.");
                  }
                  __allocStruct(StructCtor2, this, externalMemory);
                } else {
                  __allocStruct(StructCtor2, this);
                }
              }, "StructCtor2");
              Object.defineProperties(StructCtor, {
                debugFlags,
                isA: rop((v2) => v2 instanceof StructCtor),
                memberKey: __memberKeyProp,
                memberKeys: __structMemberKeys,
                methodInfoForKey: rop(function(mKey) {
                }),
                structInfo: rop(structInfo),
                structName: rop(structName)
              });
              StructCtor.prototype = new StructType(structName, structInfo, rop);
              Object.defineProperties(StructCtor.prototype, {
                debugFlags,
                constructor: rop(StructCtor)
              });
              Object.keys(structInfo.members).forEach(
                (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])
              );
              return StructCtor;
            }, "StructBinder2");
            StructBinder.StructType = StructType;
            StructBinder.config = config2;
            StructBinder.allocCString = __allocCString;
            if (!StructBinder.debugFlags) {
              StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
            }
            return StructBinder;
          }, "StructBinderFactory");
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            "use strict";
            const toss = /* @__PURE__ */ __name((...args) => {
              throw new Error(args.join(" "));
            }, "toss");
            const toss3 = sqlite3.SQLite3Error.toss;
            const capi = sqlite3.capi, wasm2 = sqlite3.wasm, util = sqlite3.util;
            globalThis.WhWasmUtilInstaller(wasm2);
            delete globalThis.WhWasmUtilInstaller;
            if (0) {
              const dealloc = wasm2.exports[sqlite3.config.deallocExportName];
              const nFunc = wasm2.functionTable().length;
              let i;
              for (i = 0; i < nFunc; ++i) {
                const e3 = wasm2.functionEntry(i);
                if (dealloc === e3) {
                  capi.SQLITE_WASM_DEALLOC = i;
                  break;
                }
              }
              if (dealloc !== wasm2.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
                toss(
                  "Internal error: cannot find function pointer for SQLITE_WASM_DEALLOC."
                );
              }
            }
            wasm2.bindingSignatures = [
              ["sqlite3_aggregate_context", "void*", "sqlite3_context*", "int"],
              ["sqlite3_bind_double", "int", "sqlite3_stmt*", "int", "f64"],
              ["sqlite3_bind_int", "int", "sqlite3_stmt*", "int", "int"],
              ["sqlite3_bind_null", void 0, "sqlite3_stmt*", "int"],
              ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
              ["sqlite3_bind_parameter_index", "int", "sqlite3_stmt*", "string"],
              ["sqlite3_bind_parameter_name", "string", "sqlite3_stmt*", "int"],
              [
                "sqlite3_bind_pointer",
                "int",
                "sqlite3_stmt*",
                "int",
                "*",
                "string:static",
                "*"
              ],
              [
                "sqlite3_busy_handler",
                "int",
                [
                  "sqlite3*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    signature: "i(pi)",
                    contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey")
                  }),
                  "*"
                ]
              ],
              ["sqlite3_busy_timeout", "int", "sqlite3*", "int"],
              ["sqlite3_changes", "int", "sqlite3*"],
              ["sqlite3_clear_bindings", "int", "sqlite3_stmt*"],
              ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
              ["sqlite3_column_blob", "*", "sqlite3_stmt*", "int"],
              ["sqlite3_column_bytes", "int", "sqlite3_stmt*", "int"],
              ["sqlite3_column_count", "int", "sqlite3_stmt*"],
              ["sqlite3_column_decltype", "string", "sqlite3_stmt*", "int"],
              ["sqlite3_column_double", "f64", "sqlite3_stmt*", "int"],
              ["sqlite3_column_int", "int", "sqlite3_stmt*", "int"],
              ["sqlite3_column_name", "string", "sqlite3_stmt*", "int"],
              ["sqlite3_column_text", "string", "sqlite3_stmt*", "int"],
              ["sqlite3_column_type", "int", "sqlite3_stmt*", "int"],
              ["sqlite3_column_value", "sqlite3_value*", "sqlite3_stmt*", "int"],
              [
                "sqlite3_commit_hook",
                "void*",
                [
                  "sqlite3*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "sqlite3_commit_hook",
                    signature: "i(p)",
                    contextKey: /* @__PURE__ */ __name((argv2) => argv2[0], "contextKey")
                  }),
                  "*"
                ]
              ],
              ["sqlite3_compileoption_get", "string", "int"],
              ["sqlite3_compileoption_used", "int", "string"],
              ["sqlite3_complete", "int", "string:flexible"],
              ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],
              ["sqlite3_data_count", "int", "sqlite3_stmt*"],
              ["sqlite3_db_filename", "string", "sqlite3*", "string"],
              ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
              ["sqlite3_db_name", "string", "sqlite3*", "int"],
              ["sqlite3_db_readonly", "int", "sqlite3*", "string"],
              ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
              ["sqlite3_errcode", "int", "sqlite3*"],
              ["sqlite3_errmsg", "string", "sqlite3*"],
              ["sqlite3_error_offset", "int", "sqlite3*"],
              ["sqlite3_errstr", "string", "int"],
              [
                "sqlite3_exec",
                "int",
                [
                  "sqlite3*",
                  "string:flexible",
                  new wasm2.xWrap.FuncPtrAdapter({
                    signature: "i(pipp)",
                    bindScope: "transient",
                    callProxy: /* @__PURE__ */ __name((callback) => {
                      let aNames;
                      return (pVoid, nCols, pColVals, pColNames) => {
                        try {
                          const aVals = wasm2.cArgvToJs(nCols, pColVals);
                          if (!aNames) aNames = wasm2.cArgvToJs(nCols, pColNames);
                          return callback(aVals, aNames) | 0;
                        } catch (e3) {
                          return e3.resultCode || capi.SQLITE_ERROR;
                        }
                      };
                    }, "callProxy")
                  }),
                  "*",
                  "**"
                ]
              ],
              ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
              ["sqlite3_extended_errcode", "int", "sqlite3*"],
              ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
              ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
              ["sqlite3_finalize", "int", "sqlite3_stmt*"],
              ["sqlite3_free", void 0, "*"],
              ["sqlite3_get_autocommit", "int", "sqlite3*"],
              ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
              ["sqlite3_initialize", void 0],
              ["sqlite3_interrupt", void 0, "sqlite3*"],
              ["sqlite3_is_interrupted", "int", "sqlite3*"],
              ["sqlite3_keyword_count", "int"],
              ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
              ["sqlite3_keyword_check", "int", ["string", "int"]],
              ["sqlite3_libversion", "string"],
              ["sqlite3_libversion_number", "int"],
              ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
              ["sqlite3_malloc", "*", "int"],
              ["sqlite3_open", "int", "string", "*"],
              ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
              ["sqlite3_realloc", "*", "*", "int"],
              ["sqlite3_reset", "int", "sqlite3_stmt*"],
              [
                "sqlite3_result_blob",
                void 0,
                "sqlite3_context*",
                "*",
                "int",
                "*"
              ],
              ["sqlite3_result_double", void 0, "sqlite3_context*", "f64"],
              [
                "sqlite3_result_error",
                void 0,
                "sqlite3_context*",
                "string",
                "int"
              ],
              ["sqlite3_result_error_code", void 0, "sqlite3_context*", "int"],
              ["sqlite3_result_error_nomem", void 0, "sqlite3_context*"],
              ["sqlite3_result_error_toobig", void 0, "sqlite3_context*"],
              ["sqlite3_result_int", void 0, "sqlite3_context*", "int"],
              ["sqlite3_result_null", void 0, "sqlite3_context*"],
              [
                "sqlite3_result_pointer",
                void 0,
                "sqlite3_context*",
                "*",
                "string:static",
                "*"
              ],
              ["sqlite3_result_subtype", void 0, "sqlite3_value*", "int"],
              [
                "sqlite3_result_text",
                void 0,
                "sqlite3_context*",
                "string",
                "int",
                "*"
              ],
              ["sqlite3_result_zeroblob", void 0, "sqlite3_context*", "int"],
              [
                "sqlite3_rollback_hook",
                "void*",
                [
                  "sqlite3*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "sqlite3_rollback_hook",
                    signature: "v(p)",
                    contextKey: /* @__PURE__ */ __name((argv2) => argv2[0], "contextKey")
                  }),
                  "*"
                ]
              ],
              [
                "sqlite3_set_auxdata",
                void 0,
                [
                  "sqlite3_context*",
                  "int",
                  "*",
                  true ? "*" : new wasm2.xWrap.FuncPtrAdapter({
                    name: "xDestroyAuxData",
                    signature: "v(p)",
                    contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey")
                  })
                ]
              ],
              ["sqlite3_shutdown", void 0],
              ["sqlite3_sourceid", "string"],
              ["sqlite3_sql", "string", "sqlite3_stmt*"],
              ["sqlite3_status", "int", "int", "*", "*", "int"],
              ["sqlite3_step", "int", "sqlite3_stmt*"],
              ["sqlite3_stmt_busy", "int", "sqlite3_stmt*"],
              ["sqlite3_stmt_readonly", "int", "sqlite3_stmt*"],
              ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
              ["sqlite3_strglob", "int", "string", "string"],
              ["sqlite3_stricmp", "int", "string", "string"],
              ["sqlite3_strlike", "int", "string", "string", "int"],
              ["sqlite3_strnicmp", "int", "string", "string", "int"],
              [
                "sqlite3_table_column_metadata",
                "int",
                "sqlite3*",
                "string",
                "string",
                "string",
                "**",
                "**",
                "*",
                "*",
                "*"
              ],
              ["sqlite3_total_changes", "int", "sqlite3*"],
              [
                "sqlite3_trace_v2",
                "int",
                [
                  "sqlite3*",
                  "int",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "sqlite3_trace_v2::callback",
                    signature: "i(ippp)",
                    contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey")
                  }),
                  "*"
                ]
              ],
              ["sqlite3_txn_state", "int", ["sqlite3*", "string"]],
              ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
              ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
              ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
              ["sqlite3_user_data", "void*", "sqlite3_context*"],
              ["sqlite3_value_blob", "*", "sqlite3_value*"],
              ["sqlite3_value_bytes", "int", "sqlite3_value*"],
              ["sqlite3_value_double", "f64", "sqlite3_value*"],
              ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
              ["sqlite3_value_free", void 0, "sqlite3_value*"],
              ["sqlite3_value_frombind", "int", "sqlite3_value*"],
              ["sqlite3_value_int", "int", "sqlite3_value*"],
              ["sqlite3_value_nochange", "int", "sqlite3_value*"],
              ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
              ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
              ["sqlite3_value_subtype", "int", "sqlite3_value*"],
              ["sqlite3_value_text", "string", "sqlite3_value*"],
              ["sqlite3_value_type", "int", "sqlite3_value*"],
              ["sqlite3_vfs_find", "*", "string"],
              ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
              ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
            ];
            if (!!wasm2.exports.sqlite3_progress_handler) {
              wasm2.bindingSignatures.push([
                "sqlite3_progress_handler",
                void 0,
                [
                  "sqlite3*",
                  "int",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xProgressHandler",
                    signature: "i(p)",
                    bindScope: "context",
                    contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey")
                  }),
                  "*"
                ]
              ]);
            }
            if (!!wasm2.exports.sqlite3_stmt_explain) {
              wasm2.bindingSignatures.push(
                ["sqlite3_stmt_explain", "int", "sqlite3_stmt*", "int"],
                ["sqlite3_stmt_isexplain", "int", "sqlite3_stmt*"]
              );
            }
            if (!!wasm2.exports.sqlite3_set_authorizer) {
              wasm2.bindingSignatures.push([
                "sqlite3_set_authorizer",
                "int",
                [
                  "sqlite3*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "sqlite3_set_authorizer::xAuth",
                    signature: "i(pissss)",
                    contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey"),
                    callProxy: /* @__PURE__ */ __name((callback) => {
                      return (pV, iCode, s0, s1, s22, s3) => {
                        try {
                          s0 = s0 && wasm2.cstrToJs(s0);
                          s1 = s1 && wasm2.cstrToJs(s1);
                          s22 = s22 && wasm2.cstrToJs(s22);
                          s3 = s3 && wasm2.cstrToJs(s3);
                          return callback(pV, iCode, s0, s1, s22, s3) || 0;
                        } catch (e3) {
                          return e3.resultCode || capi.SQLITE_ERROR;
                        }
                      };
                    }, "callProxy")
                  }),
                  "*"
                ]
              ]);
            }
            if (false) {
              wasm2.bindingSignatures.push([
                "sqlite3_normalized_sql",
                "string",
                "sqlite3_stmt*"
              ]);
            }
            wasm2.bindingSignatures.int64 = [
              ["sqlite3_bind_int64", "int", ["sqlite3_stmt*", "int", "i64"]],
              ["sqlite3_changes64", "i64", ["sqlite3*"]],
              ["sqlite3_column_int64", "i64", ["sqlite3_stmt*", "int"]],
              [
                "sqlite3_deserialize",
                "int",
                "sqlite3*",
                "string",
                "*",
                "i64",
                "i64",
                "int"
              ],
              ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
              ["sqlite3_malloc64", "*", "i64"],
              ["sqlite3_msize", "i64", "*"],
              ["sqlite3_overload_function", "int", ["sqlite3*", "string", "int"]],
              ["sqlite3_realloc64", "*", "*", "i64"],
              ["sqlite3_result_int64", void 0, "*", "i64"],
              ["sqlite3_result_zeroblob64", "int", "*", "i64"],
              ["sqlite3_serialize", "*", "sqlite3*", "string", "*", "int"],
              ["sqlite3_set_last_insert_rowid", void 0, ["sqlite3*", "i64"]],
              ["sqlite3_status64", "int", "int", "*", "*", "int"],
              ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
              [
                "sqlite3_update_hook",
                "*",
                [
                  "sqlite3*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "sqlite3_update_hook",
                    signature: "v(iippj)",
                    contextKey: /* @__PURE__ */ __name((argv2) => argv2[0], "contextKey"),
                    callProxy: /* @__PURE__ */ __name((callback) => {
                      return (p, op, z0, z1, rowid) => {
                        callback(
                          p,
                          op,
                          wasm2.cstrToJs(z0),
                          wasm2.cstrToJs(z1),
                          rowid
                        );
                      };
                    }, "callProxy")
                  }),
                  "*"
                ]
              ],
              ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
              ["sqlite3_value_int64", "i64", "sqlite3_value*"]
            ];
            if (wasm2.bigIntEnabled && !!wasm2.exports.sqlite3_declare_vtab) {
              wasm2.bindingSignatures.int64.push(
                [
                  "sqlite3_create_module",
                  "int",
                  ["sqlite3*", "string", "sqlite3_module*", "*"]
                ],
                [
                  "sqlite3_create_module_v2",
                  "int",
                  ["sqlite3*", "string", "sqlite3_module*", "*", "*"]
                ],
                ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
                ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
                ["sqlite3_vtab_collation", "string", "sqlite3_index_info*", "int"],
                ["sqlite3_vtab_distinct", "int", "sqlite3_index_info*"],
                ["sqlite3_vtab_in", "int", "sqlite3_index_info*", "int", "int"],
                ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
                ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
                ["sqlite3_vtab_nochange", "int", "sqlite3_context*"],
                ["sqlite3_vtab_on_conflict", "int", "sqlite3*"],
                [
                  "sqlite3_vtab_rhs_value",
                  "int",
                  "sqlite3_index_info*",
                  "int",
                  "**"
                ]
              );
            }
            if (wasm2.bigIntEnabled && !!wasm2.exports.sqlite3_preupdate_hook) {
              wasm2.bindingSignatures.int64.push(
                ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
                ["sqlite3_preupdate_count", "int", "sqlite3*"],
                ["sqlite3_preupdate_depth", "int", "sqlite3*"],
                [
                  "sqlite3_preupdate_hook",
                  "*",
                  [
                    "sqlite3*",
                    new wasm2.xWrap.FuncPtrAdapter({
                      name: "sqlite3_preupdate_hook",
                      signature: "v(ppippjj)",
                      contextKey: /* @__PURE__ */ __name((argv2) => argv2[0], "contextKey"),
                      callProxy: /* @__PURE__ */ __name((callback) => {
                        return (p, db, op, zDb, zTbl, iKey1, iKey2) => {
                          callback(
                            p,
                            db,
                            op,
                            wasm2.cstrToJs(zDb),
                            wasm2.cstrToJs(zTbl),
                            iKey1,
                            iKey2
                          );
                        };
                      }, "callProxy")
                    }),
                    "*"
                  ]
                ],
                ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
                ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]]
              );
            }
            if (wasm2.bigIntEnabled && !!wasm2.exports.sqlite3changegroup_add && !!wasm2.exports.sqlite3session_create && !!wasm2.exports.sqlite3_preupdate_hook) {
              const __ipsProxy = {
                signature: "i(ps)",
                callProxy: /* @__PURE__ */ __name((callback) => {
                  return (p, s3) => {
                    try {
                      return callback(p, wasm2.cstrToJs(s3)) | 0;
                    } catch (e3) {
                      return e3.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }, "callProxy")
              };
              wasm2.bindingSignatures.int64.push(
                ...[
                  [
                    "sqlite3changegroup_add",
                    "int",
                    ["sqlite3_changegroup*", "int", "void*"]
                  ],
                  [
                    "sqlite3changegroup_add_strm",
                    "int",
                    [
                      "sqlite3_changegroup*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changegroup_delete",
                    void 0,
                    ["sqlite3_changegroup*"]
                  ],
                  ["sqlite3changegroup_new", "int", ["**"]],
                  [
                    "sqlite3changegroup_output",
                    "int",
                    ["sqlite3_changegroup*", "int*", "**"]
                  ],
                  [
                    "sqlite3changegroup_output_strm",
                    "int",
                    [
                      "sqlite3_changegroup*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xOutput",
                        signature: "i(ppi)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changeset_apply",
                    "int",
                    [
                      "sqlite3*",
                      "int",
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xFilter",
                        bindScope: "transient",
                        ...__ipsProxy
                      }),
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xConflict",
                        signature: "i(pip)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changeset_apply_strm",
                    "int",
                    [
                      "sqlite3*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xFilter",
                        bindScope: "transient",
                        ...__ipsProxy
                      }),
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xConflict",
                        signature: "i(pip)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changeset_apply_v2",
                    "int",
                    [
                      "sqlite3*",
                      "int",
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xFilter",
                        bindScope: "transient",
                        ...__ipsProxy
                      }),
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xConflict",
                        signature: "i(pip)",
                        bindScope: "transient"
                      }),
                      "void*",
                      "**",
                      "int*",
                      "int"
                    ]
                  ],
                  [
                    "sqlite3changeset_apply_v2_strm",
                    "int",
                    [
                      "sqlite3*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xFilter",
                        bindScope: "transient",
                        ...__ipsProxy
                      }),
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xConflict",
                        signature: "i(pip)",
                        bindScope: "transient"
                      }),
                      "void*",
                      "**",
                      "int*",
                      "int"
                    ]
                  ],
                  [
                    "sqlite3changeset_concat",
                    "int",
                    ["int", "void*", "int", "void*", "int*", "**"]
                  ],
                  [
                    "sqlite3changeset_concat_strm",
                    "int",
                    [
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInputA",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInputB",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xOutput",
                        signature: "i(ppi)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changeset_conflict",
                    "int",
                    ["sqlite3_changeset_iter*", "int", "**"]
                  ],
                  ["sqlite3changeset_finalize", "int", ["sqlite3_changeset_iter*"]],
                  [
                    "sqlite3changeset_fk_conflicts",
                    "int",
                    ["sqlite3_changeset_iter*", "int*"]
                  ],
                  [
                    "sqlite3changeset_invert",
                    "int",
                    ["int", "void*", "int*", "**"]
                  ],
                  [
                    "sqlite3changeset_invert_strm",
                    "int",
                    [
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xOutput",
                        signature: "i(ppi)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3changeset_new",
                    "int",
                    ["sqlite3_changeset_iter*", "int", "**"]
                  ],
                  ["sqlite3changeset_next", "int", ["sqlite3_changeset_iter*"]],
                  [
                    "sqlite3changeset_old",
                    "int",
                    ["sqlite3_changeset_iter*", "int", "**"]
                  ],
                  [
                    "sqlite3changeset_op",
                    "int",
                    ["sqlite3_changeset_iter*", "**", "int*", "int*", "int*"]
                  ],
                  [
                    "sqlite3changeset_pk",
                    "int",
                    ["sqlite3_changeset_iter*", "**", "int*"]
                  ],
                  ["sqlite3changeset_start", "int", ["**", "int", "*"]],
                  [
                    "sqlite3changeset_start_strm",
                    "int",
                    [
                      "**",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  ["sqlite3changeset_start_v2", "int", ["**", "int", "*", "int"]],
                  [
                    "sqlite3changeset_start_v2_strm",
                    "int",
                    [
                      "**",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xInput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*",
                      "int"
                    ]
                  ],
                  ["sqlite3session_attach", "int", ["sqlite3_session*", "string"]],
                  [
                    "sqlite3session_changeset",
                    "int",
                    ["sqlite3_session*", "int*", "**"]
                  ],
                  ["sqlite3session_changeset_size", "i64", ["sqlite3_session*"]],
                  [
                    "sqlite3session_changeset_strm",
                    "int",
                    [
                      "sqlite3_session*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xOutput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  ["sqlite3session_config", "int", ["int", "void*"]],
                  ["sqlite3session_create", "int", ["sqlite3*", "string", "**"]],
                  [
                    "sqlite3session_diff",
                    "int",
                    ["sqlite3_session*", "string", "string", "**"]
                  ],
                  ["sqlite3session_enable", "int", ["sqlite3_session*", "int"]],
                  ["sqlite3session_indirect", "int", ["sqlite3_session*", "int"]],
                  ["sqlite3session_isempty", "int", ["sqlite3_session*"]],
                  ["sqlite3session_memory_used", "i64", ["sqlite3_session*"]],
                  [
                    "sqlite3session_object_config",
                    "int",
                    ["sqlite3_session*", "int", "void*"]
                  ],
                  [
                    "sqlite3session_patchset",
                    "int",
                    ["sqlite3_session*", "*", "**"]
                  ],
                  [
                    "sqlite3session_patchset_strm",
                    "int",
                    [
                      "sqlite3_session*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xOutput",
                        signature: "i(ppp)",
                        bindScope: "transient"
                      }),
                      "void*"
                    ]
                  ],
                  [
                    "sqlite3session_table_filter",
                    void 0,
                    [
                      "sqlite3_session*",
                      new wasm2.xWrap.FuncPtrAdapter({
                        name: "xFilter",
                        ...__ipsProxy,
                        contextKey: /* @__PURE__ */ __name((argv2, argIndex) => argv2[0], "contextKey")
                      }),
                      "*"
                    ]
                  ]
                ]
              );
            }
            wasm2.bindingSignatures.wasmInternal = [
              ["sqlite3__wasm_db_reset", "int", "sqlite3*"],
              ["sqlite3__wasm_db_vfs", "sqlite3_vfs*", "sqlite3*", "string"],
              [
                "sqlite3__wasm_vfs_create_file",
                "int",
                "sqlite3_vfs*",
                "string",
                "*",
                "int"
              ],
              ["sqlite3__wasm_posix_create_file", "int", "string", "*", "int"],
              ["sqlite3__wasm_vfs_unlink", "int", "sqlite3_vfs*", "string"],
              ["sqlite3__wasm_qfmt_token", "string:dealloc", "string", "int"]
            ];
            sqlite3.StructBinder = globalThis.Jaccwabyt({
              heap: 0 ? wasm2.memory : wasm2.heap8u,
              alloc: wasm2.alloc,
              dealloc: wasm2.dealloc,
              bigIntEnabled: wasm2.bigIntEnabled,
              memberPrefix: "$"
            });
            delete globalThis.Jaccwabyt;
            {
              const __xString = wasm2.xWrap.argAdapter("string");
              wasm2.xWrap.argAdapter(
                "string:flexible",
                (v2) => __xString(util.flexibleString(v2))
              );
              wasm2.xWrap.argAdapter(
                "string:static",
                function(v2) {
                  if (wasm2.isPtr(v2)) return v2;
                  v2 = "" + v2;
                  let rc = this[v2];
                  return rc || (this[v2] = wasm2.allocCString(v2));
                }.bind(/* @__PURE__ */ Object.create(null))
              );
              const __xArgPtr = wasm2.xWrap.argAdapter("*");
              const nilType = /* @__PURE__ */ __name(function() {
              }, "nilType");
              wasm2.xWrap.argAdapter("sqlite3_filename", __xArgPtr)(
                "sqlite3_context*",
                __xArgPtr
              )("sqlite3_value*", __xArgPtr)("void*", __xArgPtr)(
                "sqlite3_changegroup*",
                __xArgPtr
              )("sqlite3_changeset_iter*", __xArgPtr)(
                "sqlite3_session*",
                __xArgPtr
              )(
                "sqlite3_stmt*",
                (v2) => __xArgPtr(
                  v2 instanceof (sqlite3?.oo1?.Stmt || nilType) ? v2.pointer : v2
                )
              )(
                "sqlite3*",
                (v2) => __xArgPtr(
                  v2 instanceof (sqlite3?.oo1?.DB || nilType) ? v2.pointer : v2
                )
              )("sqlite3_vfs*", (v2) => {
                if ("string" === typeof v2) {
                  return capi.sqlite3_vfs_find(v2) || sqlite3.SQLite3Error.toss(
                    capi.SQLITE_NOTFOUND,
                    "Unknown sqlite3_vfs name:",
                    v2
                  );
                }
                return __xArgPtr(
                  v2 instanceof (capi.sqlite3_vfs || nilType) ? v2.pointer : v2
                );
              });
              if (wasm2.exports.sqlite3_declare_vtab) {
                wasm2.xWrap.argAdapter(
                  "sqlite3_index_info*",
                  (v2) => __xArgPtr(
                    v2 instanceof (capi.sqlite3_index_info || nilType) ? v2.pointer : v2
                  )
                )(
                  "sqlite3_module*",
                  (v2) => __xArgPtr(
                    v2 instanceof (capi.sqlite3_module || nilType) ? v2.pointer : v2
                  )
                );
              }
              const __xRcPtr = wasm2.xWrap.resultAdapter("*");
              wasm2.xWrap.resultAdapter("sqlite3*", __xRcPtr)(
                "sqlite3_context*",
                __xRcPtr
              )("sqlite3_stmt*", __xRcPtr)("sqlite3_value*", __xRcPtr)(
                "sqlite3_vfs*",
                __xRcPtr
              )("void*", __xRcPtr);
              if (0 === wasm2.exports.sqlite3_step.length) {
                wasm2.xWrap.doArgcCheck = false;
                sqlite3.config.warn(
                  "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
                );
              }
              for (const e3 of wasm2.bindingSignatures) {
                capi[e3[0]] = wasm2.xWrap.apply(null, e3);
              }
              for (const e3 of wasm2.bindingSignatures.wasmInternal) {
                util[e3[0]] = wasm2.xWrap.apply(null, e3);
              }
              const fI64Disabled = /* @__PURE__ */ __name(function(fname) {
                return () => toss(
                  fname + "() is unavailable due to lack",
                  "of BigInt support in this build."
                );
              }, "fI64Disabled");
              for (const e3 of wasm2.bindingSignatures.int64) {
                capi[e3[0]] = wasm2.bigIntEnabled ? wasm2.xWrap.apply(null, e3) : fI64Disabled(e3[0]);
              }
              delete wasm2.bindingSignatures;
              if (wasm2.exports.sqlite3__wasm_db_error) {
                const __db_err = wasm2.xWrap(
                  "sqlite3__wasm_db_error",
                  "int",
                  "sqlite3*",
                  "int",
                  "string"
                );
                util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {
                  if (resultCode instanceof sqlite3.WasmAllocError) {
                    resultCode = capi.SQLITE_NOMEM;
                    message = 0;
                  } else if (resultCode instanceof Error) {
                    message = message || "" + resultCode;
                    resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
                  }
                  return pDb2 ? __db_err(pDb2, resultCode, message) : resultCode;
                };
              } else {
                util.sqlite3__wasm_db_error = function(pDb2, errCode, msg) {
                  console.warn(
                    "sqlite3__wasm_db_error() is not exported.",
                    arguments
                  );
                  return errCode;
                };
              }
            }
            {
              const cJson = wasm2.xCall("sqlite3__wasm_enum_json");
              if (!cJson) {
                toss(
                  "Maintenance required: increase sqlite3__wasm_enum_json()'s",
                  "static buffer size!"
                );
              }
              wasm2.ctype = JSON.parse(wasm2.cstrToJs(cJson));
              const defineGroups = [
                "access",
                "authorizer",
                "blobFinalizers",
                "changeset",
                "config",
                "dataTypes",
                "dbConfig",
                "dbStatus",
                "encodings",
                "fcntl",
                "flock",
                "ioCap",
                "limits",
                "openFlags",
                "prepareFlags",
                "resultCodes",
                "sqlite3Status",
                "stmtStatus",
                "syncFlags",
                "trace",
                "txnState",
                "udfFlags",
                "version"
              ];
              if (wasm2.bigIntEnabled) {
                defineGroups.push("serialize", "session", "vtab");
              }
              for (const t2 of defineGroups) {
                for (const e3 of Object.entries(wasm2.ctype[t2])) {
                  capi[e3[0]] = e3[1];
                }
              }
              if (!wasm2.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
                toss(
                  "Internal error: cannot resolve exported function",
                  "entry SQLITE_WASM_DEALLOC (==" + capi.SQLITE_WASM_DEALLOC + ")."
                );
              }
              const __rcMap = /* @__PURE__ */ Object.create(null);
              for (const t2 of ["resultCodes"]) {
                for (const e3 of Object.entries(wasm2.ctype[t2])) {
                  __rcMap[e3[1]] = e3[0];
                }
              }
              capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];
              const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {
                WasmTestStruct: true,
                sqlite3_kvvfs_methods: !util.isUIThread(),
                sqlite3_index_info: !wasm2.bigIntEnabled,
                sqlite3_index_constraint: !wasm2.bigIntEnabled,
                sqlite3_index_orderby: !wasm2.bigIntEnabled,
                sqlite3_index_constraint_usage: !wasm2.bigIntEnabled
              });
              for (const s3 of wasm2.ctype.structs) {
                if (!notThese[s3.name]) {
                  capi[s3.name] = sqlite3.StructBinder(s3);
                }
              }
              if (capi.sqlite3_index_info) {
                for (const k of [
                  "sqlite3_index_constraint",
                  "sqlite3_index_orderby",
                  "sqlite3_index_constraint_usage"
                ]) {
                  capi.sqlite3_index_info[k] = capi[k];
                  delete capi[k];
                }
                capi.sqlite3_vtab_config = wasm2.xWrap(
                  "sqlite3__wasm_vtab_config",
                  "int",
                  ["sqlite3*", "int", "int"]
                );
              }
            }
            const __dbArgcMismatch = /* @__PURE__ */ __name((pDb2, f, n2) => {
              return util.sqlite3__wasm_db_error(
                pDb2,
                capi.SQLITE_MISUSE,
                f + "() requires " + n2 + " argument" + (1 === n2 ? "" : "s") + "."
              );
            }, "__dbArgcMismatch");
            const __errEncoding = /* @__PURE__ */ __name((pDb2) => {
              return util.sqlite3__wasm_db_error(
                pDb2,
                capi.SQLITE_FORMAT,
                "SQLITE_UTF8 is the only supported encoding."
              );
            }, "__errEncoding");
            const __argPDb = /* @__PURE__ */ __name((pDb2) => wasm2.xWrap.argAdapter("sqlite3*")(pDb2), "__argPDb");
            const __argStr = /* @__PURE__ */ __name((str) => wasm2.isPtr(str) ? wasm2.cstrToJs(str) : str, "__argStr");
            const __dbCleanupMap = function(pDb2, mode) {
              pDb2 = __argPDb(pDb2);
              let m = this.dbMap.get(pDb2);
              if (!mode) {
                this.dbMap.delete(pDb2);
                return m;
              } else if (!m && mode > 0) {
                this.dbMap.set(pDb2, m = /* @__PURE__ */ Object.create(null));
              }
              return m;
            }.bind(
              Object.assign(/* @__PURE__ */ Object.create(null), {
                dbMap: /* @__PURE__ */ new Map()
              })
            );
            __dbCleanupMap.addCollation = function(pDb2, name) {
              const m = __dbCleanupMap(pDb2, 1);
              if (!m.collation) m.collation = /* @__PURE__ */ new Set();
              m.collation.add(__argStr(name).toLowerCase());
            };
            __dbCleanupMap._addUDF = function(pDb2, name, arity, map) {
              name = __argStr(name).toLowerCase();
              let u = map.get(name);
              if (!u) map.set(name, u = /* @__PURE__ */ new Set());
              u.add(arity < 0 ? -1 : arity);
            };
            __dbCleanupMap.addFunction = function(pDb2, name, arity) {
              const m = __dbCleanupMap(pDb2, 1);
              if (!m.udf) m.udf = /* @__PURE__ */ new Map();
              this._addUDF(pDb2, name, arity, m.udf);
            };
            if (wasm2.exports.sqlite3_create_window_function) {
              __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {
                const m = __dbCleanupMap(pDb2, 1);
                if (!m.wudf) m.wudf = /* @__PURE__ */ new Map();
                this._addUDF(pDb2, name, arity, m.wudf);
              };
            }
            __dbCleanupMap.cleanup = function(pDb2) {
              pDb2 = __argPDb(pDb2);
              const closeArgs = [pDb2];
              for (const name of [
                "sqlite3_busy_handler",
                "sqlite3_commit_hook",
                "sqlite3_preupdate_hook",
                "sqlite3_progress_handler",
                "sqlite3_rollback_hook",
                "sqlite3_set_authorizer",
                "sqlite3_trace_v2",
                "sqlite3_update_hook"
              ]) {
                const x = wasm2.exports[name];
                if (!x) {
                  continue;
                }
                closeArgs.length = x.length;
                try {
                  capi[name](...closeArgs);
                } catch (e3) {
                  sqlite3.config.warn(
                    "close-time call of",
                    name + "(",
                    closeArgs,
                    ") threw:",
                    e3
                  );
                }
              }
              const m = __dbCleanupMap(pDb2, 0);
              if (!m) return;
              if (m.collation) {
                for (const name of m.collation) {
                  try {
                    capi.sqlite3_create_collation_v2(
                      pDb2,
                      name,
                      capi.SQLITE_UTF8,
                      0,
                      0,
                      0
                    );
                  } catch (e3) {
                  }
                }
                delete m.collation;
              }
              let i;
              for (i = 0; i < 2; ++i) {
                const fmap = i ? m.wudf : m.udf;
                if (!fmap) continue;
                const func = i ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;
                for (const e3 of fmap) {
                  const name = e3[0], arities = e3[1];
                  const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
                  if (i) fargs.push(0);
                  for (const arity of arities) {
                    try {
                      fargs[2] = arity;
                      func.apply(null, fargs);
                    } catch (e4) {
                    }
                  }
                  arities.clear();
                }
                fmap.clear();
              }
              delete m.udf;
              delete m.wudf;
            };
            {
              const __sqlite3CloseV2 = wasm2.xWrap(
                "sqlite3_close_v2",
                "int",
                "sqlite3*"
              );
              capi.sqlite3_close_v2 = function(pDb2) {
                if (1 !== arguments.length)
                  return __dbArgcMismatch(pDb2, "sqlite3_close_v2", 1);
                if (pDb2) {
                  try {
                    __dbCleanupMap.cleanup(pDb2);
                  } catch (e3) {
                  }
                }
                return __sqlite3CloseV2(pDb2);
              };
            }
            if (capi.sqlite3session_create) {
              const __sqlite3SessionDelete = wasm2.xWrap(
                "sqlite3session_delete",
                void 0,
                ["sqlite3_session*"]
              );
              capi.sqlite3session_delete = function(pSession) {
                if (1 !== arguments.length) {
                  return __dbArgcMismatch(pDb, "sqlite3session_delete", 1);
                } else if (pSession) {
                  capi.sqlite3session_table_filter(pSession, 0, 0);
                }
                __sqlite3SessionDelete(pSession);
              };
            }
            {
              const contextKey = /* @__PURE__ */ __name((argv2, argIndex) => {
                return "argv[" + argIndex + "]:" + argv2[0] + ":" + wasm2.cstrToJs(argv2[1]).toLowerCase();
              }, "contextKey");
              const __sqlite3CreateCollationV2 = wasm2.xWrap(
                "sqlite3_create_collation_v2",
                "int",
                [
                  "sqlite3*",
                  "string",
                  "int",
                  "*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xCompare",
                    signature: "i(pipip)",
                    contextKey
                  }),
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xDestroy",
                    signature: "v(p)",
                    contextKey
                  })
                ]
              );
              capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {
                if (6 !== arguments.length)
                  return __dbArgcMismatch(pDb2, "sqlite3_create_collation_v2", 6);
                else if (0 === (eTextRep & 15)) {
                  eTextRep |= capi.SQLITE_UTF8;
                } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
                  return __errEncoding(pDb2);
                }
                try {
                  const rc = __sqlite3CreateCollationV2(
                    pDb2,
                    zName,
                    eTextRep,
                    pArg,
                    xCompare,
                    xDestroy
                  );
                  if (0 === rc && xCompare instanceof Function) {
                    __dbCleanupMap.addCollation(pDb2, zName);
                  }
                  return rc;
                } catch (e3) {
                  return util.sqlite3__wasm_db_error(pDb2, e3);
                }
              };
              capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {
                return 5 === arguments.length ? capi.sqlite3_create_collation_v2(
                  pDb2,
                  zName,
                  eTextRep,
                  pArg,
                  xCompare,
                  0
                ) : __dbArgcMismatch(pDb2, "sqlite3_create_collation", 5);
              };
            }
            {
              const contextKey = /* @__PURE__ */ __name(function(argv2, argIndex) {
                return argv2[0] + ":" + (argv2[2] < 0 ? -1 : argv2[2]) + ":" + argIndex + ":" + wasm2.cstrToJs(argv2[1]).toLowerCase();
              }, "contextKey");
              const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {
                xInverseAndStep: {
                  signature: "v(pip)",
                  contextKey,
                  callProxy: /* @__PURE__ */ __name((callback) => {
                    return (pCtx, argc, pArgv) => {
                      try {
                        callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                      } catch (e3) {
                        capi.sqlite3_result_error_js(pCtx, e3);
                      }
                    };
                  }, "callProxy")
                },
                xFinalAndValue: {
                  signature: "v(p)",
                  contextKey,
                  callProxy: /* @__PURE__ */ __name((callback) => {
                    return (pCtx) => {
                      try {
                        capi.sqlite3_result_js(pCtx, callback(pCtx));
                      } catch (e3) {
                        capi.sqlite3_result_error_js(pCtx, e3);
                      }
                    };
                  }, "callProxy")
                },
                xFunc: {
                  signature: "v(pip)",
                  contextKey,
                  callProxy: /* @__PURE__ */ __name((callback) => {
                    return (pCtx, argc, pArgv) => {
                      try {
                        capi.sqlite3_result_js(
                          pCtx,
                          callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
                        );
                      } catch (e3) {
                        capi.sqlite3_result_error_js(pCtx, e3);
                      }
                    };
                  }, "callProxy")
                },
                xDestroy: {
                  signature: "v(p)",
                  contextKey,
                  callProxy: /* @__PURE__ */ __name((callback) => {
                    return (pVoid) => {
                      try {
                        callback(pVoid);
                      } catch (e3) {
                        console.error("UDF xDestroy method threw:", e3);
                      }
                    };
                  }, "callProxy")
                }
              });
              const __sqlite3CreateFunction = wasm2.xWrap(
                "sqlite3_create_function_v2",
                "int",
                [
                  "sqlite3*",
                  "string",
                  "int",
                  "int",
                  "*",
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xFunc",
                    ...__cfProxy.xFunc
                  }),
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xStep",
                    ...__cfProxy.xInverseAndStep
                  }),
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xFinal",
                    ...__cfProxy.xFinalAndValue
                  }),
                  new wasm2.xWrap.FuncPtrAdapter({
                    name: "xDestroy",
                    ...__cfProxy.xDestroy
                  })
                ]
              );
              const __sqlite3CreateWindowFunction = wasm2.exports.sqlite3_create_window_function ? wasm2.xWrap("sqlite3_create_window_function", "int", [
                "sqlite3*",
                "string",
                "int",
                "int",
                "*",
                new wasm2.xWrap.FuncPtrAdapter({
                  name: "xStep",
                  ...__cfProxy.xInverseAndStep
                }),
                new wasm2.xWrap.FuncPtrAdapter({
                  name: "xFinal",
                  ...__cfProxy.xFinalAndValue
                }),
                new wasm2.xWrap.FuncPtrAdapter({
                  name: "xValue",
                  ...__cfProxy.xFinalAndValue
                }),
                new wasm2.xWrap.FuncPtrAdapter({
                  name: "xInverse",
                  ...__cfProxy.xInverseAndStep
                }),
                new wasm2.xWrap.FuncPtrAdapter({
                  name: "xDestroy",
                  ...__cfProxy.xDestroy
                })
              ]) : void 0;
              capi.sqlite3_create_function_v2 = /* @__PURE__ */ __name(function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    pDb2,
                    "sqlite3_create_function_v2",
                    f.length
                  );
                } else if (0 === (eTextRep & 15)) {
                  eTextRep |= capi.SQLITE_UTF8;
                } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
                  return __errEncoding(pDb2);
                }
                try {
                  const rc = __sqlite3CreateFunction(
                    pDb2,
                    funcName,
                    nArg,
                    eTextRep,
                    pApp,
                    xFunc,
                    xStep,
                    xFinal,
                    xDestroy
                  );
                  if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {
                    __dbCleanupMap.addFunction(pDb2, funcName, nArg);
                  }
                  return rc;
                } catch (e3) {
                  console.error("sqlite3_create_function_v2() setup threw:", e3);
                  return util.sqlite3__wasm_db_error(
                    pDb2,
                    e3,
                    "Creation of UDF threw: " + e3
                  );
                }
              }, "f");
              capi.sqlite3_create_function = /* @__PURE__ */ __name(function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
                return f.length === arguments.length ? capi.sqlite3_create_function_v2(
                  pDb2,
                  funcName,
                  nArg,
                  eTextRep,
                  pApp,
                  xFunc,
                  xStep,
                  xFinal,
                  0
                ) : __dbArgcMismatch(pDb2, "sqlite3_create_function", f.length);
              }, "f");
              if (__sqlite3CreateWindowFunction) {
                capi.sqlite3_create_window_function = /* @__PURE__ */ __name(function f(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {
                  if (f.length !== arguments.length) {
                    return __dbArgcMismatch(
                      pDb2,
                      "sqlite3_create_window_function",
                      f.length
                    );
                  } else if (0 === (eTextRep & 15)) {
                    eTextRep |= capi.SQLITE_UTF8;
                  } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
                    return __errEncoding(pDb2);
                  }
                  try {
                    const rc = __sqlite3CreateWindowFunction(
                      pDb2,
                      funcName,
                      nArg,
                      eTextRep,
                      pApp,
                      xStep,
                      xFinal,
                      xValue,
                      xInverse,
                      xDestroy
                    );
                    if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {
                      __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);
                    }
                    return rc;
                  } catch (e3) {
                    console.error(
                      "sqlite3_create_window_function() setup threw:",
                      e3
                    );
                    return util.sqlite3__wasm_db_error(
                      pDb2,
                      e3,
                      "Creation of UDF threw: " + e3
                    );
                  }
                }, "f");
              } else {
                delete capi.sqlite3_create_window_function;
              }
              capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;
              if (capi.sqlite3_create_window_function) {
                capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;
              }
              capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_values_to_js;
              if (capi.sqlite3_create_window_function) {
                capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;
              }
              capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_result_error_js;
              if (capi.sqlite3_create_window_function) {
                capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;
              }
            }
            {
              const __flexiString = /* @__PURE__ */ __name((v2, n2) => {
                if ("string" === typeof v2) {
                  n2 = -1;
                } else if (util.isSQLableTypedArray(v2)) {
                  n2 = v2.byteLength;
                  v2 = util.typedArrayToString(
                    v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2
                  );
                } else if (Array.isArray(v2)) {
                  v2 = v2.join("");
                  n2 = -1;
                }
                return [v2, n2];
              }, "__flexiString");
              const __prepare = {
                basic: wasm2.xWrap("sqlite3_prepare_v3", "int", [
                  "sqlite3*",
                  "string",
                  "int",
                  "int",
                  "**",
                  "**"
                ]),
                full: wasm2.xWrap("sqlite3_prepare_v3", "int", [
                  "sqlite3*",
                  "*",
                  "int",
                  "int",
                  "**",
                  "**"
                ])
              };
              capi.sqlite3_prepare_v3 = /* @__PURE__ */ __name(function f(pDb2, sql, sqlLen, prepFlags, ppStmt, pzTail) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(pDb2, "sqlite3_prepare_v3", f.length);
                }
                const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
                switch (typeof xSql) {
                  case "string":
                    return __prepare.basic(
                      pDb2,
                      xSql,
                      xSqlLen,
                      prepFlags,
                      ppStmt,
                      null
                    );
                  case "number":
                    return __prepare.full(
                      pDb2,
                      xSql,
                      xSqlLen,
                      prepFlags,
                      ppStmt,
                      pzTail
                    );
                  default:
                    return util.sqlite3__wasm_db_error(
                      pDb2,
                      capi.SQLITE_MISUSE,
                      "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
                    );
                }
              }, "f");
              capi.sqlite3_prepare_v2 = /* @__PURE__ */ __name(function f(pDb2, sql, sqlLen, ppStmt, pzTail) {
                return f.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, "sqlite3_prepare_v2", f.length);
              }, "f");
            }
            {
              const __bindText = wasm2.xWrap("sqlite3_bind_text", "int", [
                "sqlite3_stmt*",
                "int",
                "string",
                "int",
                "*"
              ]);
              const __bindBlob = wasm2.xWrap("sqlite3_bind_blob", "int", [
                "sqlite3_stmt*",
                "int",
                "*",
                "int",
                "*"
              ]);
              capi.sqlite3_bind_text = /* @__PURE__ */ __name(function f(pStmt, iCol, text2, nText, xDestroy) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    capi.sqlite3_db_handle(pStmt),
                    "sqlite3_bind_text",
                    f.length
                  );
                } else if (wasm2.isPtr(text2) || null === text2) {
                  return __bindText(pStmt, iCol, text2, nText, xDestroy);
                } else if (text2 instanceof ArrayBuffer) {
                  text2 = new Uint8Array(text2);
                } else if (Array.isArray(pMem)) {
                  text2 = pMem.join("");
                }
                let p, n2;
                try {
                  if (util.isSQLableTypedArray(text2)) {
                    p = wasm2.allocFromTypedArray(text2);
                    n2 = text2.byteLength;
                  } else if ("string" === typeof text2) {
                    [p, n2] = wasm2.allocCString(text2);
                  } else {
                    return util.sqlite3__wasm_db_error(
                      capi.sqlite3_db_handle(pStmt),
                      capi.SQLITE_MISUSE,
                      "Invalid 3rd argument type for sqlite3_bind_text()."
                    );
                  }
                  return __bindText(pStmt, iCol, p, n2, capi.SQLITE_WASM_DEALLOC);
                } catch (e3) {
                  wasm2.dealloc(p);
                  return util.sqlite3__wasm_db_error(
                    capi.sqlite3_db_handle(pStmt),
                    e3
                  );
                }
              }, "f");
              capi.sqlite3_bind_blob = /* @__PURE__ */ __name(function f(pStmt, iCol, pMem2, nMem, xDestroy) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    capi.sqlite3_db_handle(pStmt),
                    "sqlite3_bind_blob",
                    f.length
                  );
                } else if (wasm2.isPtr(pMem2) || null === pMem2) {
                  return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);
                } else if (pMem2 instanceof ArrayBuffer) {
                  pMem2 = new Uint8Array(pMem2);
                } else if (Array.isArray(pMem2)) {
                  pMem2 = pMem2.join("");
                }
                let p, n2;
                try {
                  if (util.isBindableTypedArray(pMem2)) {
                    p = wasm2.allocFromTypedArray(pMem2);
                    n2 = nMem >= 0 ? nMem : pMem2.byteLength;
                  } else if ("string" === typeof pMem2) {
                    [p, n2] = wasm2.allocCString(pMem2);
                  } else {
                    return util.sqlite3__wasm_db_error(
                      capi.sqlite3_db_handle(pStmt),
                      capi.SQLITE_MISUSE,
                      "Invalid 3rd argument type for sqlite3_bind_blob()."
                    );
                  }
                  return __bindBlob(pStmt, iCol, p, n2, capi.SQLITE_WASM_DEALLOC);
                } catch (e3) {
                  wasm2.dealloc(p);
                  return util.sqlite3__wasm_db_error(
                    capi.sqlite3_db_handle(pStmt),
                    e3
                  );
                }
              }, "f");
            }
            {
              capi.sqlite3_config = function(op, ...args) {
                if (arguments.length < 2) return capi.SQLITE_MISUSE;
                switch (op) {
                  case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
                  case capi.SQLITE_CONFIG_MEMSTATUS:
                  case capi.SQLITE_CONFIG_SMALL_MALLOC:
                  case capi.SQLITE_CONFIG_SORTERREF_SIZE:
                  case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
                  case capi.SQLITE_CONFIG_URI:
                    return wasm2.exports.sqlite3__wasm_config_i(op, args[0]);
                  case capi.SQLITE_CONFIG_LOOKASIDE:
                    return wasm2.exports.sqlite3__wasm_config_ii(
                      op,
                      args[0],
                      args[1]
                    );
                  case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                    return wasm2.exports.sqlite3__wasm_config_j(op, args[0]);
                  case capi.SQLITE_CONFIG_GETMALLOC:
                  case capi.SQLITE_CONFIG_GETMUTEX:
                  case capi.SQLITE_CONFIG_GETPCACHE2:
                  case capi.SQLITE_CONFIG_GETPCACHE:
                  case capi.SQLITE_CONFIG_HEAP:
                  case capi.SQLITE_CONFIG_LOG:
                  case capi.SQLITE_CONFIG_MALLOC:
                  case capi.SQLITE_CONFIG_MMAP_SIZE:
                  case capi.SQLITE_CONFIG_MULTITHREAD:
                  case capi.SQLITE_CONFIG_MUTEX:
                  case capi.SQLITE_CONFIG_PAGECACHE:
                  case capi.SQLITE_CONFIG_PCACHE2:
                  case capi.SQLITE_CONFIG_PCACHE:
                  case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
                  case capi.SQLITE_CONFIG_PMASZ:
                  case capi.SQLITE_CONFIG_SERIALIZED:
                  case capi.SQLITE_CONFIG_SINGLETHREAD:
                  case capi.SQLITE_CONFIG_SQLLOG:
                  case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
                  default:
                    return capi.SQLITE_NOTFOUND;
                }
              };
            }
            {
              const __autoExtFptr = /* @__PURE__ */ new Set();
              capi.sqlite3_auto_extension = function(fPtr) {
                if (fPtr instanceof Function) {
                  fPtr = wasm2.installFunction("i(ppp)", fPtr);
                } else if (1 !== arguments.length || !wasm2.isPtr(fPtr)) {
                  return capi.SQLITE_MISUSE;
                }
                const rc = wasm2.exports.sqlite3_auto_extension(fPtr);
                if (fPtr !== arguments[0]) {
                  if (0 === rc) __autoExtFptr.add(fPtr);
                  else wasm2.uninstallFunction(fPtr);
                }
                return rc;
              };
              capi.sqlite3_cancel_auto_extension = function(fPtr) {
                if (!fPtr || 1 !== arguments.length || !wasm2.isPtr(fPtr)) return 0;
                return wasm2.exports.sqlite3_cancel_auto_extension(fPtr);
              };
              capi.sqlite3_reset_auto_extension = function() {
                wasm2.exports.sqlite3_reset_auto_extension();
                for (const fp of __autoExtFptr) wasm2.uninstallFunction(fp);
                __autoExtFptr.clear();
              };
            }
            const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
            if (pKvvfs) {
              if (util.isUIThread()) {
                const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
                  wasm2.exports.sqlite3__wasm_kvvfs_methods()
                );
                delete capi.sqlite3_kvvfs_methods;
                const kvvfsMakeKey = wasm2.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm2.pstack;
                const kvvfsStorage = /* @__PURE__ */ __name((zClass) => 115 === wasm2.peek(zClass) ? sessionStorage : localStorage, "kvvfsStorage");
                const kvvfsImpls = {
                  xRead: /* @__PURE__ */ __name((zClass, zKey, zBuf, nBuf) => {
                    const stack = pstack.pointer, astack = wasm2.scopedAllocPush();
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return -3;
                      const jKey = wasm2.cstrToJs(zXKey);
                      const jV = kvvfsStorage(zClass).getItem(jKey);
                      if (!jV) return -1;
                      const nV = jV.length;
                      if (nBuf <= 0) return nV;
                      else if (1 === nBuf) {
                        wasm2.poke(zBuf, 0);
                        return nV;
                      }
                      const zV = wasm2.scopedAllocCString(jV);
                      if (nBuf > nV + 1) nBuf = nV + 1;
                      wasm2.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                      wasm2.poke(zBuf + nBuf - 1, 0);
                      return nBuf - 1;
                    } catch (e3) {
                      console.error("kvstorageRead()", e3);
                      return -2;
                    } finally {
                      pstack.restore(stack);
                      wasm2.scopedAllocPop(astack);
                    }
                  }, "xRead"),
                  xWrite: /* @__PURE__ */ __name((zClass, zKey, zData) => {
                    const stack = pstack.pointer;
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return 1;
                      const jKey = wasm2.cstrToJs(zXKey);
                      kvvfsStorage(zClass).setItem(jKey, wasm2.cstrToJs(zData));
                      return 0;
                    } catch (e3) {
                      console.error("kvstorageWrite()", e3);
                      return capi.SQLITE_IOERR;
                    } finally {
                      pstack.restore(stack);
                    }
                  }, "xWrite"),
                  xDelete: /* @__PURE__ */ __name((zClass, zKey) => {
                    const stack = pstack.pointer;
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return 1;
                      kvvfsStorage(zClass).removeItem(wasm2.cstrToJs(zXKey));
                      return 0;
                    } catch (e3) {
                      console.error("kvstorageDelete()", e3);
                      return capi.SQLITE_IOERR;
                    } finally {
                      pstack.restore(stack);
                    }
                  }, "xDelete")
                };
                for (const k of Object.keys(kvvfsImpls)) {
                  kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm2.installFunction(
                    kvvfsMethods.memberSignature(k),
                    kvvfsImpls[k]
                  );
                }
              } else {
                capi.sqlite3_vfs_unregister(pKvvfs);
              }
            }
            wasm2.xWrap.FuncPtrAdapter.warnOnUse = true;
            const StructBinder = sqlite3.StructBinder;
            const installMethod = /* @__PURE__ */ __name(function callee2(tgt, name, func, applyArgcCheck = callee2.installMethodArgcCheck) {
              if (!(tgt instanceof StructBinder.StructType)) {
                toss("Usage error: target object is-not-a StructType.");
              } else if (!(func instanceof Function) && !wasm2.isPtr(func)) {
                toss("Usage error: expecting a Function or WASM pointer to one.");
              }
              if (1 === arguments.length) {
                return (n2, f) => callee2(tgt, n2, f, applyArgcCheck);
              }
              if (!callee2.argcProxy) {
                callee2.argcProxy = function(tgt2, funcName, func2, sig) {
                  return function(...args) {
                    if (func2.length !== arguments.length) {
                      toss(
                        "Argument mismatch for",
                        tgt2.structInfo.name + "::" + funcName + ": Native signature is:",
                        sig
                      );
                    }
                    return func2.apply(this, args);
                  };
                };
                callee2.removeFuncList = function() {
                  if (this.ondispose.__removeFuncList) {
                    this.ondispose.__removeFuncList.forEach((v2, ndx) => {
                      if ("number" === typeof v2) {
                        try {
                          wasm2.uninstallFunction(v2);
                        } catch (e3) {
                        }
                      }
                    });
                    delete this.ondispose.__removeFuncList;
                  }
                };
              }
              const sigN = tgt.memberSignature(name);
              if (sigN.length < 2) {
                toss(
                  "Member",
                  name,
                  "does not have a function pointer signature:",
                  sigN
                );
              }
              const memKey = tgt.memberKey(name);
              const fProxy = applyArgcCheck && !wasm2.isPtr(func) ? callee2.argcProxy(tgt, memKey, func, sigN) : func;
              if (wasm2.isPtr(fProxy)) {
                if (fProxy && !wasm2.functionEntry(fProxy)) {
                  toss("Pointer", fProxy, "is not a WASM function table entry.");
                }
                tgt[memKey] = fProxy;
              } else {
                const pFunc = wasm2.installFunction(
                  fProxy,
                  tgt.memberSignature(name, true)
                );
                tgt[memKey] = pFunc;
                if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
                  tgt.addOnDispose(
                    "ondispose.__removeFuncList handler",
                    callee2.removeFuncList
                  );
                  tgt.ondispose.__removeFuncList = [];
                }
                tgt.ondispose.__removeFuncList.push(memKey, pFunc);
              }
              return (n2, f) => callee2(tgt, n2, f, applyArgcCheck);
            }, "callee2");
            installMethod.installMethodArgcCheck = false;
            const installMethods = /* @__PURE__ */ __name(function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
              const seen = /* @__PURE__ */ new Map();
              for (const k of Object.keys(methods)) {
                const m = methods[k];
                const prior = seen.get(m);
                if (prior) {
                  const mkey = structInstance.memberKey(k);
                  structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
                } else {
                  installMethod(structInstance, k, m, applyArgcCheck);
                  seen.set(m, k);
                }
              }
              return structInstance;
            }, "installMethods");
            StructBinder.StructType.prototype.installMethod = /* @__PURE__ */ __name(function callee2(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {
              return arguments.length < 3 && name && "object" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);
            }, "callee2");
            StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
              return installMethods(this, methods, applyArgcCheck);
            };
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            sqlite3.version = {
              libVersion: "3.50.4",
              libVersionNumber: 3050004,
              sourceId: "2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3",
              downloadVersion: 3500400
            };
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            const toss = /* @__PURE__ */ __name((...args) => {
              throw new Error(args.join(" "));
            }, "toss");
            const toss3 = /* @__PURE__ */ __name((...args) => {
              throw new sqlite3.SQLite3Error(...args);
            }, "toss3");
            const capi = sqlite3.capi, wasm2 = sqlite3.wasm, util = sqlite3.util;
            const __ptrMap = /* @__PURE__ */ new WeakMap();
            const __stmtMap = /* @__PURE__ */ new WeakMap();
            const getOwnOption = /* @__PURE__ */ __name((opts, p, dflt) => {
              const d = Object.getOwnPropertyDescriptor(opts, p);
              return d ? d.value : dflt;
            }, "getOwnOption");
            const checkSqlite3Rc = /* @__PURE__ */ __name(function(dbPtr, sqliteResultCode) {
              if (sqliteResultCode) {
                if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;
                toss3(
                  sqliteResultCode,
                  "sqlite3 result code",
                  sqliteResultCode + ":",
                  dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)
                );
              }
              return arguments[0];
            }, "checkSqlite3Rc");
            const __dbTraceToConsole = wasm2.installFunction(
              "i(ippp)",
              function(t2, c2, p, x) {
                if (capi.SQLITE_TRACE_STMT === t2) {
                  console.log(
                    "SQL TRACE #" + ++this.counter + " via sqlite3@" + c2 + ":",
                    wasm2.cstrToJs(x)
                  );
                }
              }.bind({ counter: 0 })
            );
            const __vfsPostOpenCallback = /* @__PURE__ */ Object.create(null);
            const dbCtorHelper = /* @__PURE__ */ __name(function ctor(...args) {
              if (!ctor._name2vfs) {
                ctor._name2vfs = /* @__PURE__ */ Object.create(null);
                const isWorkerThread = "function" === typeof importScripts ? (n2) => toss3(
                  "The VFS for",
                  n2,
                  "is only available in the main window thread."
                ) : false;
                ctor._name2vfs[":localStorage:"] = {
                  vfs: "kvvfs",
                  filename: isWorkerThread || (() => "local")
                };
                ctor._name2vfs[":sessionStorage:"] = {
                  vfs: "kvvfs",
                  filename: isWorkerThread || (() => "session")
                };
              }
              const opt = ctor.normalizeArgs(...args);
              let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
              if ("string" !== typeof fn && "number" !== typeof fn || "string" !== typeof flagsStr || vfsName && "string" !== typeof vfsName && "number" !== typeof vfsName) {
                sqlite3.config.error("Invalid DB ctor args", opt, arguments);
                toss3("Invalid arguments for DB constructor.");
              }
              let fnJs = "number" === typeof fn ? wasm2.cstrToJs(fn) : fn;
              const vfsCheck = ctor._name2vfs[fnJs];
              if (vfsCheck) {
                vfsName = vfsCheck.vfs;
                fn = fnJs = vfsCheck.filename(fnJs);
              }
              let pDb2, oflags = 0;
              if (flagsStr.indexOf("c") >= 0) {
                oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
              }
              if (flagsStr.indexOf("w") >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;
              if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;
              oflags |= capi.SQLITE_OPEN_EXRESCODE;
              const stack = wasm2.pstack.pointer;
              try {
                const pPtr = wasm2.pstack.allocPtr();
                let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
                pDb2 = wasm2.peekPtr(pPtr);
                checkSqlite3Rc(pDb2, rc);
                capi.sqlite3_extended_result_codes(pDb2, 1);
                if (flagsStr.indexOf("t") >= 0) {
                  capi.sqlite3_trace_v2(
                    pDb2,
                    capi.SQLITE_TRACE_STMT,
                    __dbTraceToConsole,
                    pDb2
                  );
                }
              } catch (e3) {
                if (pDb2) capi.sqlite3_close_v2(pDb2);
                throw e3;
              } finally {
                wasm2.pstack.restore(stack);
              }
              this.filename = fnJs;
              __ptrMap.set(this, pDb2);
              __stmtMap.set(this, /* @__PURE__ */ Object.create(null));
              try {
                const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3("Internal error: cannot get VFS for new db handle.");
                const postInitSql = __vfsPostOpenCallback[pVfs];
                if (postInitSql) {
                  if (postInitSql instanceof Function) {
                    postInitSql(this, sqlite3);
                  } else {
                    checkSqlite3Rc(
                      pDb2,
                      capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)
                    );
                  }
                }
              } catch (e3) {
                this.close();
                throw e3;
              }
            }, "ctor");
            dbCtorHelper.setVfsPostOpenCallback = function(pVfs, callback) {
              if (!(callback instanceof Function)) {
                toss3(
                  "dbCtorHelper.setVfsPostOpenCallback() should not be used with a non-function argument.",
                  arguments
                );
              }
              __vfsPostOpenCallback[pVfs] = callback;
            };
            dbCtorHelper.normalizeArgs = function(filename = ":memory:", flags2 = "c", vfs = null) {
              const arg = {};
              if (1 === arguments.length && arguments[0] && "object" === typeof arguments[0]) {
                Object.assign(arg, arguments[0]);
                if (void 0 === arg.flags) arg.flags = "c";
                if (void 0 === arg.vfs) arg.vfs = null;
                if (void 0 === arg.filename) arg.filename = ":memory:";
              } else {
                arg.filename = filename;
                arg.flags = flags2;
                arg.vfs = vfs;
              }
              return arg;
            };
            const DB = /* @__PURE__ */ __name(function(...args) {
              dbCtorHelper.apply(this, args);
            }, "DB");
            DB.dbCtorHelper = dbCtorHelper;
            const BindTypes = {
              null: 1,
              number: 2,
              string: 3,
              boolean: 4,
              blob: 5
            };
            BindTypes["undefined"] == BindTypes.null;
            if (wasm2.bigIntEnabled) {
              BindTypes.bigint = BindTypes.number;
            }
            const Stmt = /* @__PURE__ */ __name(function() {
              if (BindTypes !== arguments[2]) {
                toss3(
                  capi.SQLITE_MISUSE,
                  "Do not call the Stmt constructor directly. Use DB.prepare()."
                );
              }
              this.db = arguments[0];
              __ptrMap.set(this, arguments[1]);
              this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
            }, "Stmt");
            const affirmDbOpen = /* @__PURE__ */ __name(function(db) {
              if (!db.pointer) toss3("DB has been closed.");
              return db;
            }, "affirmDbOpen");
            const affirmColIndex = /* @__PURE__ */ __name(function(stmt, ndx) {
              if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
                toss3("Column index", ndx, "is out of range.");
              }
              return stmt;
            }, "affirmColIndex");
            const parseExecArgs = /* @__PURE__ */ __name(function(db, args) {
              const out2 = /* @__PURE__ */ Object.create(null);
              out2.opt = /* @__PURE__ */ Object.create(null);
              switch (args.length) {
                case 1:
                  if ("string" === typeof args[0] || util.isSQLableTypedArray(args[0])) {
                    out2.sql = args[0];
                  } else if (Array.isArray(args[0])) {
                    out2.sql = args[0];
                  } else if (args[0] && "object" === typeof args[0]) {
                    out2.opt = args[0];
                    out2.sql = out2.opt.sql;
                  }
                  break;
                case 2:
                  out2.sql = args[0];
                  out2.opt = args[1];
                  break;
                default:
                  toss3("Invalid argument count for exec().");
              }
              out2.sql = util.flexibleString(out2.sql);
              if ("string" !== typeof out2.sql) {
                toss3("Missing SQL argument or unsupported SQL value type.");
              }
              const opt = out2.opt;
              switch (opt.returnValue) {
                case "resultRows":
                  if (!opt.resultRows) opt.resultRows = [];
                  out2.returnVal = () => opt.resultRows;
                  break;
                case "saveSql":
                  if (!opt.saveSql) opt.saveSql = [];
                  out2.returnVal = () => opt.saveSql;
                  break;
                case void 0:
                case "this":
                  out2.returnVal = () => db;
                  break;
                default:
                  toss3("Invalid returnValue value:", opt.returnValue);
              }
              if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {
                if (!opt.resultRows) opt.resultRows = [];
                out2.returnVal = () => opt.resultRows;
              }
              if (opt.callback || opt.resultRows) {
                switch (void 0 === opt.rowMode ? "array" : opt.rowMode) {
                  case "object":
                    out2.cbArg = (stmt, cache) => {
                      if (!cache.columnNames)
                        cache.columnNames = stmt.getColumnNames([]);
                      const row = stmt.get([]);
                      const rv = /* @__PURE__ */ Object.create(null);
                      for (const i in cache.columnNames)
                        rv[cache.columnNames[i]] = row[i];
                      return rv;
                    };
                    break;
                  case "array":
                    out2.cbArg = (stmt) => stmt.get([]);
                    break;
                  case "stmt":
                    if (Array.isArray(opt.resultRows)) {
                      toss3(
                        "exec(): invalid rowMode for a resultRows array: must",
                        "be one of 'array', 'object',",
                        "a result column number, or column name reference."
                      );
                    }
                    out2.cbArg = (stmt) => stmt;
                    break;
                  default:
                    if (util.isInt32(opt.rowMode)) {
                      out2.cbArg = (stmt) => stmt.get(opt.rowMode);
                      break;
                    } else if ("string" === typeof opt.rowMode && opt.rowMode.length > 1 && "$" === opt.rowMode[0]) {
                      const $colName = opt.rowMode.substr(1);
                      out2.cbArg = (stmt) => {
                        const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];
                        return void 0 === rc ? toss3(
                          capi.SQLITE_NOTFOUND,
                          "exec(): unknown result column:",
                          $colName
                        ) : rc;
                      };
                      break;
                    }
                    toss3("Invalid rowMode:", opt.rowMode);
                }
              }
              return out2;
            }, "parseExecArgs");
            const __selectFirstRow = /* @__PURE__ */ __name((db, sql, bind, ...getArgs) => {
              const stmt = db.prepare(sql);
              try {
                const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;
                stmt.reset();
                return rc;
              } finally {
                stmt.finalize();
              }
            }, "__selectFirstRow");
            const __selectAll = /* @__PURE__ */ __name((db, sql, bind, rowMode) => db.exec({
              sql,
              bind,
              rowMode,
              returnValue: "resultRows"
            }), "__selectAll");
            DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);
            DB.prototype = {
              isOpen: /* @__PURE__ */ __name(function() {
                return !!this.pointer;
              }, "isOpen"),
              affirmOpen: /* @__PURE__ */ __name(function() {
                return affirmDbOpen(this);
              }, "affirmOpen"),
              close: /* @__PURE__ */ __name(function() {
                if (this.pointer) {
                  if (this.onclose && this.onclose.before instanceof Function) {
                    try {
                      this.onclose.before(this);
                    } catch (e3) {
                    }
                  }
                  const pDb2 = this.pointer;
                  Object.keys(__stmtMap.get(this)).forEach((k, s3) => {
                    if (s3 && s3.pointer) {
                      try {
                        s3.finalize();
                      } catch (e3) {
                      }
                    }
                  });
                  __ptrMap.delete(this);
                  __stmtMap.delete(this);
                  capi.sqlite3_close_v2(pDb2);
                  if (this.onclose && this.onclose.after instanceof Function) {
                    try {
                      this.onclose.after(this);
                    } catch (e3) {
                    }
                  }
                  delete this.filename;
                }
              }, "close"),
              changes: /* @__PURE__ */ __name(function(total = false, sixtyFour = false) {
                const p = affirmDbOpen(this).pointer;
                if (total) {
                  return sixtyFour ? capi.sqlite3_total_changes64(p) : capi.sqlite3_total_changes(p);
                } else {
                  return sixtyFour ? capi.sqlite3_changes64(p) : capi.sqlite3_changes(p);
                }
              }, "changes"),
              dbFilename: /* @__PURE__ */ __name(function(dbName = "main") {
                return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
              }, "dbFilename"),
              dbName: /* @__PURE__ */ __name(function(dbNumber = 0) {
                return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
              }, "dbName"),
              dbVfsName: /* @__PURE__ */ __name(function(dbName = 0) {
                let rc;
                const pVfs = capi.sqlite3_js_db_vfs(
                  affirmDbOpen(this).pointer,
                  dbName
                );
                if (pVfs) {
                  const v2 = new capi.sqlite3_vfs(pVfs);
                  try {
                    rc = wasm2.cstrToJs(v2.$zName);
                  } finally {
                    v2.dispose();
                  }
                }
                return rc;
              }, "dbVfsName"),
              prepare: /* @__PURE__ */ __name(function(sql) {
                affirmDbOpen(this);
                const stack = wasm2.pstack.pointer;
                let ppStmt, pStmt;
                try {
                  ppStmt = wasm2.pstack.alloc(8);
                  DB.checkRc(
                    this,
                    capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null)
                  );
                  pStmt = wasm2.peekPtr(ppStmt);
                } finally {
                  wasm2.pstack.restore(stack);
                }
                if (!pStmt) toss3("Cannot prepare empty SQL.");
                const stmt = new Stmt(this, pStmt, BindTypes);
                __stmtMap.get(this)[pStmt] = stmt;
                return stmt;
              }, "prepare"),
              exec: /* @__PURE__ */ __name(function() {
                affirmDbOpen(this);
                const arg = parseExecArgs(this, arguments);
                if (!arg.sql) {
                  return toss3("exec() requires an SQL string.");
                }
                const opt = arg.opt;
                const callback = opt.callback;
                const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;
                let stmt;
                let bind = opt.bind;
                let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);
                const stack = wasm2.scopedAllocPush();
                const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;
                try {
                  const isTA = util.isSQLableTypedArray(arg.sql);
                  let sqlByteLen = isTA ? arg.sql.byteLength : wasm2.jstrlen(arg.sql);
                  const ppStmt = wasm2.scopedAlloc(
                    2 * wasm2.ptrSizeof + (sqlByteLen + 1)
                  );
                  const pzTail = ppStmt + wasm2.ptrSizeof;
                  let pSql = pzTail + wasm2.ptrSizeof;
                  const pSqlEnd = pSql + sqlByteLen;
                  if (isTA) wasm2.heap8().set(arg.sql, pSql);
                  else wasm2.jstrcpy(arg.sql, wasm2.heap8(), pSql, sqlByteLen, false);
                  wasm2.poke(pSql + sqlByteLen, 0);
                  while (pSql && wasm2.peek(pSql, "i8")) {
                    wasm2.pokePtr([ppStmt, pzTail], 0);
                    DB.checkRc(
                      this,
                      capi.sqlite3_prepare_v3(
                        this.pointer,
                        pSql,
                        sqlByteLen,
                        0,
                        ppStmt,
                        pzTail
                      )
                    );
                    const pStmt = wasm2.peekPtr(ppStmt);
                    pSql = wasm2.peekPtr(pzTail);
                    sqlByteLen = pSqlEnd - pSql;
                    if (!pStmt) continue;
                    if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
                    stmt = new Stmt(this, pStmt, BindTypes);
                    if (bind && stmt.parameterCount) {
                      stmt.bind(bind);
                      bind = null;
                    }
                    if (evalFirstResult && stmt.columnCount) {
                      let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                      evalFirstResult = false;
                      if (arg.cbArg || resultRows) {
                        const cbArgCache = /* @__PURE__ */ Object.create(null);
                        for (; stmt.step(); stmt._lockedByExec = false) {
                          if (0 === gotColNames++) {
                            stmt.getColumnNames(
                              cbArgCache.columnNames = opt.columnNames || []
                            );
                          }
                          stmt._lockedByExec = true;
                          const row = arg.cbArg(stmt, cbArgCache);
                          if (resultRows) resultRows.push(row);
                          if (callback && false === callback.call(opt, row, stmt)) {
                            break;
                          }
                        }
                        stmt._lockedByExec = false;
                      }
                      if (0 === gotColNames) {
                        stmt.getColumnNames(opt.columnNames);
                      }
                    } else {
                      stmt.step();
                    }
                    stmt.reset().finalize();
                    stmt = null;
                  }
                } finally {
                  wasm2.scopedAllocPop(stack);
                  if (stmt) {
                    delete stmt._lockedByExec;
                    stmt.finalize();
                  }
                }
                return arg.returnVal();
              }, "exec"),
              createFunction: /* @__PURE__ */ __name(function f(name, xFunc, opt) {
                const isFunc = /* @__PURE__ */ __name((f2) => f2 instanceof Function, "isFunc");
                switch (arguments.length) {
                  case 1:
                    opt = name;
                    name = opt.name;
                    xFunc = opt.xFunc || 0;
                    break;
                  case 2:
                    if (!isFunc(xFunc)) {
                      opt = xFunc;
                      xFunc = opt.xFunc || 0;
                    }
                    break;
                  case 3:
                    break;
                  default:
                    break;
                }
                if (!opt) opt = {};
                if ("string" !== typeof name) {
                  toss3("Invalid arguments: missing function name.");
                }
                let xStep = opt.xStep || 0;
                let xFinal = opt.xFinal || 0;
                const xValue = opt.xValue || 0;
                const xInverse = opt.xInverse || 0;
                let isWindow = void 0;
                if (isFunc(xFunc)) {
                  isWindow = false;
                  if (isFunc(xStep) || isFunc(xFinal)) {
                    toss3("Ambiguous arguments: scalar or aggregate?");
                  }
                  xStep = xFinal = null;
                } else if (isFunc(xStep)) {
                  if (!isFunc(xFinal)) {
                    toss3("Missing xFinal() callback for aggregate or window UDF.");
                  }
                  xFunc = null;
                } else if (isFunc(xFinal)) {
                  toss3("Missing xStep() callback for aggregate or window UDF.");
                } else {
                  toss3("Missing function-type properties.");
                }
                if (false === isWindow) {
                  if (isFunc(xValue) || isFunc(xInverse)) {
                    toss3(
                      "xValue and xInverse are not permitted for non-window UDFs."
                    );
                  }
                } else if (isFunc(xValue)) {
                  if (!isFunc(xInverse)) {
                    toss3("xInverse must be provided if xValue is.");
                  }
                  isWindow = true;
                } else if (isFunc(xInverse)) {
                  toss3("xValue must be provided if xInverse is.");
                }
                const pApp = opt.pApp;
                if (void 0 !== pApp && null !== pApp && ("number" !== typeof pApp || !util.isInt32(pApp))) {
                  toss3(
                    "Invalid value for pApp property. Must be a legal WASM pointer value."
                  );
                }
                const xDestroy = opt.xDestroy || 0;
                if (xDestroy && !isFunc(xDestroy)) {
                  toss3("xDestroy property must be a function.");
                }
                let fFlags = 0;
                if (getOwnOption(opt, "deterministic"))
                  fFlags |= capi.SQLITE_DETERMINISTIC;
                if (getOwnOption(opt, "directOnly"))
                  fFlags |= capi.SQLITE_DIRECTONLY;
                if (getOwnOption(opt, "innocuous")) fFlags |= capi.SQLITE_INNOCUOUS;
                name = name.toLowerCase();
                const xArity = xFunc || xStep;
                const arity = getOwnOption(opt, "arity");
                const arityArg = "number" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;
                let rc;
                if (isWindow) {
                  rc = capi.sqlite3_create_window_function(
                    this.pointer,
                    name,
                    arityArg,
                    capi.SQLITE_UTF8 | fFlags,
                    pApp || 0,
                    xStep,
                    xFinal,
                    xValue,
                    xInverse,
                    xDestroy
                  );
                } else {
                  rc = capi.sqlite3_create_function_v2(
                    this.pointer,
                    name,
                    arityArg,
                    capi.SQLITE_UTF8 | fFlags,
                    pApp || 0,
                    xFunc,
                    xStep,
                    xFinal,
                    xDestroy
                  );
                }
                DB.checkRc(this, rc);
                return this;
              }, "f"),
              selectValue: /* @__PURE__ */ __name(function(sql, bind, asType) {
                return __selectFirstRow(this, sql, bind, 0, asType);
              }, "selectValue"),
              selectValues: /* @__PURE__ */ __name(function(sql, bind, asType) {
                const stmt = this.prepare(sql), rc = [];
                try {
                  stmt.bind(bind);
                  while (stmt.step()) rc.push(stmt.get(0, asType));
                  stmt.reset();
                } finally {
                  stmt.finalize();
                }
                return rc;
              }, "selectValues"),
              selectArray: /* @__PURE__ */ __name(function(sql, bind) {
                return __selectFirstRow(this, sql, bind, []);
              }, "selectArray"),
              selectObject: /* @__PURE__ */ __name(function(sql, bind) {
                return __selectFirstRow(this, sql, bind, {});
              }, "selectObject"),
              selectArrays: /* @__PURE__ */ __name(function(sql, bind) {
                return __selectAll(this, sql, bind, "array");
              }, "selectArrays"),
              selectObjects: /* @__PURE__ */ __name(function(sql, bind) {
                return __selectAll(this, sql, bind, "object");
              }, "selectObjects"),
              openStatementCount: /* @__PURE__ */ __name(function() {
                return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
              }, "openStatementCount"),
              transaction: /* @__PURE__ */ __name(function(callback) {
                let opener = "BEGIN";
                if (arguments.length > 1) {
                  if (/[^a-zA-Z]/.test(arguments[0])) {
                    toss3(
                      capi.SQLITE_MISUSE,
                      "Invalid argument for BEGIN qualifier."
                    );
                  }
                  opener += " " + arguments[0];
                  callback = arguments[1];
                }
                affirmDbOpen(this).exec(opener);
                try {
                  const rc = callback(this);
                  this.exec("COMMIT");
                  return rc;
                } catch (e3) {
                  this.exec("ROLLBACK");
                  throw e3;
                }
              }, "transaction"),
              savepoint: /* @__PURE__ */ __name(function(callback) {
                affirmDbOpen(this).exec("SAVEPOINT oo1");
                try {
                  const rc = callback(this);
                  this.exec("RELEASE oo1");
                  return rc;
                } catch (e3) {
                  this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
                  throw e3;
                }
              }, "savepoint"),
              checkRc: /* @__PURE__ */ __name(function(resultCode) {
                return checkSqlite3Rc(this, resultCode);
              }, "checkRc")
            };
            const affirmStmtOpen = /* @__PURE__ */ __name(function(stmt) {
              if (!stmt.pointer) toss3("Stmt has been closed.");
              return stmt;
            }, "affirmStmtOpen");
            const isSupportedBindType = /* @__PURE__ */ __name(function(v2) {
              let t2 = BindTypes[null === v2 || void 0 === v2 ? "null" : typeof v2];
              switch (t2) {
                case BindTypes.boolean:
                case BindTypes.null:
                case BindTypes.number:
                case BindTypes.string:
                  return t2;
                case BindTypes.bigint:
                  if (wasm2.bigIntEnabled) return t2;
                default:
                  return util.isBindableTypedArray(v2) ? BindTypes.blob : void 0;
              }
            }, "isSupportedBindType");
            const affirmSupportedBindType = /* @__PURE__ */ __name(function(v2) {
              return isSupportedBindType(v2) || toss3("Unsupported bind() argument type:", typeof v2);
            }, "affirmSupportedBindType");
            const affirmParamIndex = /* @__PURE__ */ __name(function(stmt, key2) {
              const n2 = "number" === typeof key2 ? key2 : capi.sqlite3_bind_parameter_index(stmt.pointer, key2);
              if (0 === n2 || !util.isInt32(n2)) {
                toss3("Invalid bind() parameter name: " + key2);
              } else if (n2 < 1 || n2 > stmt.parameterCount)
                toss3("Bind index", key2, "is out of range.");
              return n2;
            }, "affirmParamIndex");
            const affirmNotLockedByExec = /* @__PURE__ */ __name(function(stmt, currentOpName) {
              if (stmt._lockedByExec) {
                toss3(
                  "Operation is illegal when statement is locked:",
                  currentOpName
                );
              }
              return stmt;
            }, "affirmNotLockedByExec");
            const bindOne = /* @__PURE__ */ __name(function f(stmt, ndx, bindType, val) {
              affirmNotLockedByExec(affirmStmtOpen(stmt), "bind()");
              if (!f._) {
                f._tooBigInt = (v2) => toss3(
                  "BigInt value is too big to store without precision loss:",
                  v2
                );
                f._ = {
                  string: /* @__PURE__ */ __name(function(stmt2, ndx2, val2, asBlob) {
                    const [pStr, n2] = wasm2.allocCString(val2, true);
                    const f2 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
                    return f2(stmt2.pointer, ndx2, pStr, n2, capi.SQLITE_WASM_DEALLOC);
                  }, "string")
                };
              }
              affirmSupportedBindType(val);
              ndx = affirmParamIndex(stmt, ndx);
              let rc = 0;
              switch (null === val || void 0 === val ? BindTypes.null : bindType) {
                case BindTypes.null:
                  rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
                  break;
                case BindTypes.string:
                  rc = f._.string(stmt, ndx, val, false);
                  break;
                case BindTypes.number: {
                  let m;
                  if (util.isInt32(val)) m = capi.sqlite3_bind_int;
                  else if ("bigint" === typeof val) {
                    if (!util.bigIntFits64(val)) {
                      f._tooBigInt(val);
                    } else if (wasm2.bigIntEnabled) {
                      m = capi.sqlite3_bind_int64;
                    } else if (util.bigIntFitsDouble(val)) {
                      val = Number(val);
                      m = capi.sqlite3_bind_double;
                    } else {
                      f._tooBigInt(val);
                    }
                  } else {
                    val = Number(val);
                    if (wasm2.bigIntEnabled && Number.isInteger(val)) {
                      m = capi.sqlite3_bind_int64;
                    } else {
                      m = capi.sqlite3_bind_double;
                    }
                  }
                  rc = m(stmt.pointer, ndx, val);
                  break;
                }
                case BindTypes.boolean:
                  rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
                  break;
                case BindTypes.blob: {
                  if ("string" === typeof val) {
                    rc = f._.string(stmt, ndx, val, true);
                    break;
                  } else if (val instanceof ArrayBuffer) {
                    val = new Uint8Array(val);
                  } else if (!util.isBindableTypedArray(val)) {
                    toss3(
                      "Binding a value as a blob requires",
                      "that it be a string, Uint8Array, Int8Array, or ArrayBuffer."
                    );
                  }
                  const pBlob = wasm2.alloc(val.byteLength || 1);
                  wasm2.heap8().set(val.byteLength ? val : [0], pBlob);
                  rc = capi.sqlite3_bind_blob(
                    stmt.pointer,
                    ndx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC
                  );
                  break;
                }
                default:
                  sqlite3.config.warn("Unsupported bind() argument type:", val);
                  toss3("Unsupported bind() argument type: " + typeof val);
              }
              if (rc) DB.checkRc(stmt.db.pointer, rc);
              stmt._mayGet = false;
              return stmt;
            }, "f");
            Stmt.prototype = {
              finalize: /* @__PURE__ */ __name(function() {
                if (this.pointer) {
                  affirmNotLockedByExec(this, "finalize()");
                  const rc = capi.sqlite3_finalize(this.pointer);
                  delete __stmtMap.get(this.db)[this.pointer];
                  __ptrMap.delete(this);
                  delete this._mayGet;
                  delete this.parameterCount;
                  delete this._lockedByExec;
                  delete this.db;
                  return rc;
                }
              }, "finalize"),
              clearBindings: /* @__PURE__ */ __name(function() {
                affirmNotLockedByExec(affirmStmtOpen(this), "clearBindings()");
                capi.sqlite3_clear_bindings(this.pointer);
                this._mayGet = false;
                return this;
              }, "clearBindings"),
              reset: /* @__PURE__ */ __name(function(alsoClearBinds) {
                affirmNotLockedByExec(this, "reset()");
                if (alsoClearBinds) this.clearBindings();
                const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
                this._mayGet = false;
                checkSqlite3Rc(this.db, rc);
                return this;
              }, "reset"),
              bind: /* @__PURE__ */ __name(function() {
                affirmStmtOpen(this);
                let ndx, arg;
                switch (arguments.length) {
                  case 1:
                    ndx = 1;
                    arg = arguments[0];
                    break;
                  case 2:
                    ndx = arguments[0];
                    arg = arguments[1];
                    break;
                  default:
                    toss3("Invalid bind() arguments.");
                }
                if (void 0 === arg) {
                  return this;
                } else if (!this.parameterCount) {
                  toss3("This statement has no bindable parameters.");
                }
                this._mayGet = false;
                if (null === arg) {
                  return bindOne(this, ndx, BindTypes.null, arg);
                } else if (Array.isArray(arg)) {
                  if (1 !== arguments.length) {
                    toss3(
                      "When binding an array, an index argument is not permitted."
                    );
                  }
                  arg.forEach(
                    (v2, i) => bindOne(this, i + 1, affirmSupportedBindType(v2), v2)
                  );
                  return this;
                } else if (arg instanceof ArrayBuffer) {
                  arg = new Uint8Array(arg);
                }
                if ("object" === typeof arg && !util.isBindableTypedArray(arg)) {
                  if (1 !== arguments.length) {
                    toss3(
                      "When binding an object, an index argument is not permitted."
                    );
                  }
                  Object.keys(arg).forEach(
                    (k) => bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k])
                  );
                  return this;
                } else {
                  return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
                }
                toss3("Should not reach this point.");
              }, "bind"),
              bindAsBlob: /* @__PURE__ */ __name(function(ndx, arg) {
                affirmStmtOpen(this);
                if (1 === arguments.length) {
                  arg = ndx;
                  ndx = 1;
                }
                const t2 = affirmSupportedBindType(arg);
                if (BindTypes.string !== t2 && BindTypes.blob !== t2 && BindTypes.null !== t2) {
                  toss3("Invalid value type for bindAsBlob()");
                }
                return bindOne(this, ndx, BindTypes.blob, arg);
              }, "bindAsBlob"),
              step: /* @__PURE__ */ __name(function() {
                affirmNotLockedByExec(this, "step()");
                const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
                switch (rc) {
                  case capi.SQLITE_DONE:
                    return this._mayGet = false;
                  case capi.SQLITE_ROW:
                    return this._mayGet = true;
                  default:
                    this._mayGet = false;
                    sqlite3.config.warn(
                      "sqlite3_step() rc=",
                      rc,
                      capi.sqlite3_js_rc_str(rc),
                      "SQL =",
                      capi.sqlite3_sql(this.pointer)
                    );
                    DB.checkRc(this.db.pointer, rc);
                }
              }, "step"),
              stepReset: /* @__PURE__ */ __name(function() {
                this.step();
                return this.reset();
              }, "stepReset"),
              stepFinalize: /* @__PURE__ */ __name(function() {
                try {
                  const rc = this.step();
                  this.reset();
                  return rc;
                } finally {
                  try {
                    this.finalize();
                  } catch (e3) {
                  }
                }
              }, "stepFinalize"),
              get: /* @__PURE__ */ __name(function(ndx, asType) {
                if (!affirmStmtOpen(this)._mayGet) {
                  toss3("Stmt.step() has not (recently) returned true.");
                }
                if (Array.isArray(ndx)) {
                  let i = 0;
                  const n2 = this.columnCount;
                  while (i < n2) {
                    ndx[i] = this.get(i++);
                  }
                  return ndx;
                } else if (ndx && "object" === typeof ndx) {
                  let i = 0;
                  const n2 = this.columnCount;
                  while (i < n2) {
                    ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);
                  }
                  return ndx;
                }
                affirmColIndex(this, ndx);
                switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {
                  case capi.SQLITE_NULL:
                    return null;
                  case capi.SQLITE_INTEGER: {
                    if (wasm2.bigIntEnabled) {
                      const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                      if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {
                        return Number(rc).valueOf();
                      }
                      return rc;
                    } else {
                      const rc = capi.sqlite3_column_double(this.pointer, ndx);
                      if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {
                        toss3(
                          "Integer is out of range for JS integer range: " + rc
                        );
                      }
                      return util.isInt32(rc) ? rc | 0 : rc;
                    }
                  }
                  case capi.SQLITE_FLOAT:
                    return capi.sqlite3_column_double(this.pointer, ndx);
                  case capi.SQLITE_TEXT:
                    return capi.sqlite3_column_text(this.pointer, ndx);
                  case capi.SQLITE_BLOB: {
                    const n2 = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n2);
                    if (n2) rc.set(wasm2.heap8u().slice(ptr, ptr + n2), 0);
                    if (n2 && this.db._blobXfer instanceof Array) {
                      this.db._blobXfer.push(rc.buffer);
                    }
                    return rc;
                  }
                  default:
                    toss3(
                      "Don't know how to translate",
                      "type of result column #" + ndx + "."
                    );
                }
                toss3("Not reached.");
              }, "get"),
              getInt: /* @__PURE__ */ __name(function(ndx) {
                return this.get(ndx, capi.SQLITE_INTEGER);
              }, "getInt"),
              getFloat: /* @__PURE__ */ __name(function(ndx) {
                return this.get(ndx, capi.SQLITE_FLOAT);
              }, "getFloat"),
              getString: /* @__PURE__ */ __name(function(ndx) {
                return this.get(ndx, capi.SQLITE_TEXT);
              }, "getString"),
              getBlob: /* @__PURE__ */ __name(function(ndx) {
                return this.get(ndx, capi.SQLITE_BLOB);
              }, "getBlob"),
              getJSON: /* @__PURE__ */ __name(function(ndx) {
                const s3 = this.get(ndx, capi.SQLITE_STRING);
                return null === s3 ? s3 : JSON.parse(s3);
              }, "getJSON"),
              getColumnName: /* @__PURE__ */ __name(function(ndx) {
                return capi.sqlite3_column_name(
                  affirmColIndex(affirmStmtOpen(this), ndx).pointer,
                  ndx
                );
              }, "getColumnName"),
              getColumnNames: /* @__PURE__ */ __name(function(tgt = []) {
                affirmColIndex(affirmStmtOpen(this), 0);
                const n2 = this.columnCount;
                for (let i = 0; i < n2; ++i) {
                  tgt.push(capi.sqlite3_column_name(this.pointer, i));
                }
                return tgt;
              }, "getColumnNames"),
              getParamIndex: /* @__PURE__ */ __name(function(name) {
                return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;
              }, "getParamIndex"),
              getParamName: /* @__PURE__ */ __name(function(ndx) {
                return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_name(this.pointer, ndx) : void 0;
              }, "getParamName"),
              isBusy: /* @__PURE__ */ __name(function() {
                return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));
              }, "isBusy"),
              isReadOnly: /* @__PURE__ */ __name(function() {
                return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));
              }, "isReadOnly")
            };
            {
              const prop = {
                enumerable: true,
                get: /* @__PURE__ */ __name(function() {
                  return __ptrMap.get(this);
                }, "get"),
                set: /* @__PURE__ */ __name(() => toss3("The pointer property is read-only."), "set")
              };
              Object.defineProperty(Stmt.prototype, "pointer", prop);
              Object.defineProperty(DB.prototype, "pointer", prop);
            }
            Object.defineProperty(Stmt.prototype, "columnCount", {
              enumerable: false,
              get: /* @__PURE__ */ __name(function() {
                return capi.sqlite3_column_count(this.pointer);
              }, "get"),
              set: /* @__PURE__ */ __name(() => toss3("The columnCount property is read-only."), "set")
            });
            sqlite3.oo1 = {
              DB,
              Stmt
            };
            if (util.isUIThread()) {
              sqlite3.oo1.JsStorageDb = function(storageName = "session") {
                const opt = dbCtorHelper.normalizeArgs(...arguments);
                storageName = opt.filename;
                if ("session" !== storageName && "local" !== storageName) {
                  toss3("JsStorageDb db name must be one of 'session' or 'local'.");
                }
                opt.vfs = "kvvfs";
                dbCtorHelper.call(this, opt);
              };
              const jdb = sqlite3.oo1.JsStorageDb;
              jdb.prototype = Object.create(DB.prototype);
              jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
              jdb.prototype.clearStorage = function() {
                return jdb.clearStorage(affirmDbOpen(this).filename);
              };
              jdb.storageSize = capi.sqlite3_js_kvvfs_size;
              jdb.prototype.storageSize = function() {
                return jdb.storageSize(affirmDbOpen(this).filename);
              };
            }
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            const util = sqlite3.util;
            sqlite3.initWorker1API = function() {
              "use strict";
              const toss = /* @__PURE__ */ __name((...args) => {
                throw new Error(args.join(" "));
              }, "toss");
              if (!(globalThis.WorkerGlobalScope instanceof Function)) {
                toss("initWorker1API() must be run from a Worker thread.");
              }
              const sqlite32 = this.sqlite3 || toss("Missing this.sqlite3 object.");
              const DB = sqlite32.oo1.DB;
              const getDbId = /* @__PURE__ */ __name(function(db) {
                let id = wState.idMap.get(db);
                if (id) return id;
                id = "db#" + ++wState.idSeq + "@" + db.pointer;
                wState.idMap.set(db, id);
                return id;
              }, "getDbId");
              const wState = {
                dbList: [],
                idSeq: 0,
                idMap: /* @__PURE__ */ new WeakMap(),
                xfer: [],
                open: /* @__PURE__ */ __name(function(opt) {
                  const db = new DB(opt);
                  this.dbs[getDbId(db)] = db;
                  if (this.dbList.indexOf(db) < 0) this.dbList.push(db);
                  return db;
                }, "open"),
                close: /* @__PURE__ */ __name(function(db, alsoUnlink) {
                  if (db) {
                    delete this.dbs[getDbId(db)];
                    const filename = db.filename;
                    const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);
                    db.close();
                    const ddNdx = this.dbList.indexOf(db);
                    if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);
                    if (alsoUnlink && filename && pVfs) {
                      util.sqlite3__wasm_vfs_unlink(pVfs, filename);
                    }
                  }
                }, "close"),
                post: /* @__PURE__ */ __name(function(msg, xferList) {
                  if (xferList && xferList.length) {
                    globalThis.postMessage(msg, Array.from(xferList));
                    xferList.length = 0;
                  } else {
                    globalThis.postMessage(msg);
                  }
                }, "post"),
                dbs: /* @__PURE__ */ Object.create(null),
                getDb: /* @__PURE__ */ __name(function(id, require2 = true) {
                  return this.dbs[id] || (require2 ? toss("Unknown (or closed) DB ID:", id) : void 0);
                }, "getDb")
              };
              const affirmDbOpen = /* @__PURE__ */ __name(function(db = wState.dbList[0]) {
                return db && db.pointer ? db : toss("DB is not opened.");
              }, "affirmDbOpen");
              const getMsgDb = /* @__PURE__ */ __name(function(msgData, affirmExists = true) {
                const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
                return affirmExists ? affirmDbOpen(db) : db;
              }, "getMsgDb");
              const getDefaultDbId = /* @__PURE__ */ __name(function() {
                return wState.dbList[0] && getDbId(wState.dbList[0]);
              }, "getDefaultDbId");
              const isSpecialDbFilename = /* @__PURE__ */ __name((n2) => {
                return "" === n2 || ":" === n2[0];
              }, "isSpecialDbFilename");
              const wMsgHandler = {
                open: /* @__PURE__ */ __name(function(ev) {
                  const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);
                  if (args.simulateError) {
                    toss("Throwing because of simulateError flag.");
                  }
                  const rc = /* @__PURE__ */ Object.create(null);
                  oargs.vfs = args.vfs;
                  oargs.filename = args.filename || "";
                  const db = wState.open(oargs);
                  rc.filename = db.filename;
                  rc.persistent = !!sqlite32.capi.sqlite3_js_db_uses_vfs(
                    db.pointer,
                    "opfs"
                  );
                  rc.dbId = getDbId(db);
                  rc.vfs = db.dbVfsName();
                  return rc;
                }, "open"),
                close: /* @__PURE__ */ __name(function(ev) {
                  const db = getMsgDb(ev, false);
                  const response = {
                    filename: db && db.filename
                  };
                  if (db) {
                    const doUnlink = ev.args && "object" === typeof ev.args ? !!ev.args.unlink : false;
                    wState.close(db, doUnlink);
                  }
                  return response;
                }, "close"),
                exec: /* @__PURE__ */ __name(function(ev) {
                  const rc = "string" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);
                  if ("stmt" === rc.rowMode) {
                    toss(
                      "Invalid rowMode for 'exec': stmt mode",
                      "does not work in the Worker API."
                    );
                  } else if (!rc.sql) {
                    toss("'exec' requires input SQL.");
                  }
                  const db = getMsgDb(ev);
                  if (rc.callback || Array.isArray(rc.resultRows)) {
                    db._blobXfer = wState.xfer;
                  }
                  const theCallback = rc.callback;
                  let rowNumber = 0;
                  const hadColNames = !!rc.columnNames;
                  if ("string" === typeof theCallback) {
                    if (!hadColNames) rc.columnNames = [];
                    rc.callback = function(row, stmt) {
                      wState.post(
                        {
                          type: theCallback,
                          columnNames: rc.columnNames,
                          rowNumber: ++rowNumber,
                          row
                        },
                        wState.xfer
                      );
                    };
                  }
                  try {
                    const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;
                    db.exec(rc);
                    if (void 0 !== changeCount) {
                      rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;
                    }
                    const lastInsertRowId = !!rc.lastInsertRowId ? sqlite32.capi.sqlite3_last_insert_rowid(db) : void 0;
                    if (void 0 !== lastInsertRowId) {
                      rc.lastInsertRowId = lastInsertRowId;
                    }
                    if (rc.callback instanceof Function) {
                      rc.callback = theCallback;
                      wState.post({
                        type: theCallback,
                        columnNames: rc.columnNames,
                        rowNumber: null,
                        row: void 0
                      });
                    }
                  } finally {
                    delete db._blobXfer;
                    if (rc.callback) rc.callback = theCallback;
                  }
                  return rc;
                }, "exec"),
                "config-get": /* @__PURE__ */ __name(function() {
                  const rc = /* @__PURE__ */ Object.create(null), src = sqlite32.config;
                  ["bigIntEnabled"].forEach(function(k) {
                    if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
                  });
                  rc.version = sqlite32.version;
                  rc.vfsList = sqlite32.capi.sqlite3_js_vfs_list();
                  return rc;
                }, "config-get"),
                export: /* @__PURE__ */ __name(function(ev) {
                  const db = getMsgDb(ev);
                  const response = {
                    byteArray: sqlite32.capi.sqlite3_js_db_export(db.pointer),
                    filename: db.filename,
                    mimetype: "application/x-sqlite3"
                  };
                  wState.xfer.push(response.byteArray.buffer);
                  return response;
                }, "export"),
                toss: /* @__PURE__ */ __name(function(ev) {
                  toss("Testing worker exception");
                }, "toss")
              };
              globalThis.onmessage = async function(ev) {
                ev = ev.data;
                let result, dbId = ev.dbId, evType = ev.type;
                const arrivalTime = performance.now();
                try {
                  if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {
                    result = await wMsgHandler[evType](ev);
                  } else {
                    toss("Unknown db worker message type:", ev.type);
                  }
                } catch (err2) {
                  evType = "error";
                  result = {
                    operation: ev.type,
                    message: err2.message,
                    errorClass: err2.name,
                    input: ev
                  };
                  if (err2.stack) {
                    result.stack = "string" === typeof err2.stack ? err2.stack.split(/\n\s*/) : err2.stack;
                  }
                  if (0)
                    sqlite32.config.warn(
                      "Worker is propagating an exception to main thread.",
                      "Reporting it _here_ for the stack trace:",
                      err2,
                      result
                    );
                }
                if (!dbId) {
                  dbId = result.dbId || getDefaultDbId();
                }
                wState.post(
                  {
                    type: evType,
                    dbId,
                    messageId: ev.messageId,
                    workerReceivedTime: arrivalTime,
                    workerRespondTime: performance.now(),
                    departureTime: ev.departureTime,
                    result
                  },
                  wState.xfer
                );
              };
              globalThis.postMessage({
                type: "sqlite3-api",
                result: "worker1-ready"
              });
            }.bind({ sqlite3 });
          });
          "use strict";
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            const wasm2 = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
            const vfs = /* @__PURE__ */ Object.create(null);
            sqlite3.vfs = vfs;
            capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {
              if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
                toss("Expecting a sqlite3_vfs-type argument.");
              }
              const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
              if (rc) {
                toss("sqlite3_vfs_register(", this, ") failed with rc", rc);
              }
              if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
                toss(
                  "BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
                  this
                );
              }
              return this;
            };
            vfs.installVfs = function(opt) {
              let count3 = 0;
              const propList = ["io", "vfs"];
              for (const key2 of propList) {
                const o2 = opt[key2];
                if (o2) {
                  ++count3;
                  o2.struct.installMethods(o2.methods, !!o2.applyArgcCheck);
                  if ("vfs" === key2) {
                    if (!o2.struct.$zName && "string" === typeof o2.name) {
                      o2.struct.addOnDispose(
                        o2.struct.$zName = wasm2.allocCString(o2.name)
                      );
                    }
                    o2.struct.registerVfs(!!o2.asDefault);
                  }
                }
              }
              if (!count3)
                toss(
                  "Misuse: installVfs() options object requires at least",
                  "one of:",
                  propList
                );
              return this;
            };
          });
          "use strict";
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            if (!sqlite3.wasm.exports.sqlite3_declare_vtab) {
              return;
            }
            const wasm2 = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
            const vtab = /* @__PURE__ */ Object.create(null);
            sqlite3.vtab = vtab;
            const sii = capi.sqlite3_index_info;
            sii.prototype.nthConstraint = function(n2, asPtr = false) {
              if (n2 < 0 || n2 >= this.$nConstraint) return false;
              const ptr = this.$aConstraint + sii.sqlite3_index_constraint.structInfo.sizeof * n2;
              return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
            };
            sii.prototype.nthConstraintUsage = function(n2, asPtr = false) {
              if (n2 < 0 || n2 >= this.$nConstraint) return false;
              const ptr = this.$aConstraintUsage + sii.sqlite3_index_constraint_usage.structInfo.sizeof * n2;
              return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
            };
            sii.prototype.nthOrderBy = function(n2, asPtr = false) {
              if (n2 < 0 || n2 >= this.$nOrderBy) return false;
              const ptr = this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n2;
              return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
            };
            const __xWrapFactory = /* @__PURE__ */ __name(function(methodName, StructType) {
              return function(ptr, removeMapping = false) {
                if (0 === arguments.length) ptr = new StructType();
                if (ptr instanceof StructType) {
                  this.set(ptr.pointer, ptr);
                  return ptr;
                } else if (!wasm2.isPtr(ptr)) {
                  sqlite3.SQLite3Error.toss(
                    "Invalid argument to",
                    methodName + "()"
                  );
                }
                let rc = this.get(ptr);
                if (removeMapping) this.delete(ptr);
                return rc;
              }.bind(/* @__PURE__ */ new Map());
            }, "__xWrapFactory");
            const StructPtrMapper = /* @__PURE__ */ __name(function(name, StructType) {
              const __xWrap = __xWrapFactory(name, StructType);
              return Object.assign(/* @__PURE__ */ Object.create(null), {
                StructType,
                create: /* @__PURE__ */ __name((ppOut) => {
                  const rc = __xWrap();
                  wasm2.pokePtr(ppOut, rc.pointer);
                  return rc;
                }, "create"),
                get: /* @__PURE__ */ __name((pCObj) => __xWrap(pCObj), "get"),
                unget: /* @__PURE__ */ __name((pCObj) => __xWrap(pCObj, true), "unget"),
                dispose: /* @__PURE__ */ __name((pCObj) => {
                  const o2 = __xWrap(pCObj, true);
                  if (o2) o2.dispose();
                }, "dispose")
              });
            }, "StructPtrMapper");
            vtab.xVtab = StructPtrMapper("xVtab", capi.sqlite3_vtab);
            vtab.xCursor = StructPtrMapper("xCursor", capi.sqlite3_vtab_cursor);
            vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);
            vtab.xError = /* @__PURE__ */ __name(function f(methodName, err2, defaultRc) {
              if (f.errorReporter instanceof Function) {
                try {
                  f.errorReporter(
                    "sqlite3_module::" + methodName + "(): " + err2.message
                  );
                } catch (e3) {
                }
              }
              let rc;
              if (err2 instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
              else if (arguments.length > 2) rc = defaultRc;
              else if (err2 instanceof sqlite3.SQLite3Error) rc = err2.resultCode;
              return rc || capi.SQLITE_ERROR;
            }, "f");
            vtab.xError.errorReporter = 1 ? console.error.bind(console) : false;
            vtab.xRowid = (ppRowid64, value) => wasm2.poke(ppRowid64, value, "i64");
            vtab.setupModule = function(opt) {
              let createdMod = false;
              const mod = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());
              try {
                const methods = opt.methods || toss("Missing 'methods' object.");
                for (const e3 of Object.entries({
                  xConnect: "xCreate",
                  xDisconnect: "xDestroy"
                })) {
                  const k = e3[0], v2 = e3[1];
                  if (true === methods[k]) methods[k] = methods[v2];
                  else if (true === methods[v2]) methods[v2] = methods[k];
                }
                if (opt.catchExceptions) {
                  const fwrap = /* @__PURE__ */ __name(function(methodName, func) {
                    if (["xConnect", "xCreate"].indexOf(methodName) >= 0) {
                      return function(pDb2, pAux, argc, argv2, ppVtab, pzErr) {
                        try {
                          return func(...arguments) || 0;
                        } catch (e3) {
                          if (!(e3 instanceof sqlite3.WasmAllocError)) {
                            wasm2.dealloc(wasm2.peekPtr(pzErr));
                            wasm2.pokePtr(pzErr, wasm2.allocCString(e3.message));
                          }
                          return vtab.xError(methodName, e3);
                        }
                      };
                    } else {
                      return function(...args) {
                        try {
                          return func(...args) || 0;
                        } catch (e3) {
                          return vtab.xError(methodName, e3);
                        }
                      };
                    }
                  }, "fwrap");
                  const mnames = [
                    "xCreate",
                    "xConnect",
                    "xBestIndex",
                    "xDisconnect",
                    "xDestroy",
                    "xOpen",
                    "xClose",
                    "xFilter",
                    "xNext",
                    "xEof",
                    "xColumn",
                    "xRowid",
                    "xUpdate",
                    "xBegin",
                    "xSync",
                    "xCommit",
                    "xRollback",
                    "xFindFunction",
                    "xRename",
                    "xSavepoint",
                    "xRelease",
                    "xRollbackTo",
                    "xShadowName"
                  ];
                  const remethods = /* @__PURE__ */ Object.create(null);
                  for (const k of mnames) {
                    const m = methods[k];
                    if (!(m instanceof Function)) continue;
                    else if ("xConnect" === k && methods.xCreate === m) {
                      remethods[k] = methods.xCreate;
                    } else if ("xCreate" === k && methods.xConnect === m) {
                      remethods[k] = methods.xConnect;
                    } else {
                      remethods[k] = fwrap(k, m);
                    }
                  }
                  mod.installMethods(remethods, false);
                } else {
                  mod.installMethods(methods, !!opt.applyArgcCheck);
                }
                if (0 === mod.$iVersion) {
                  let v2;
                  if ("number" === typeof opt.iVersion) v2 = opt.iVersion;
                  else if (mod.$xShadowName) v2 = 3;
                  else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                    v2 = 2;
                  else v2 = 1;
                  mod.$iVersion = v2;
                }
              } catch (e3) {
                if (createdMod) createdMod.dispose();
                throw e3;
              }
              return mod;
            };
            capi.sqlite3_module.prototype.setupModule = function(opt) {
              return vtab.setupModule.call(this, opt);
            };
          });
          "use strict";
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            const installOpfsVfs = /* @__PURE__ */ __name(function callee2(options2) {
              if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
                return Promise.reject(
                  new Error(
                    "Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep"
                  )
                );
              } else if ("undefined" === typeof WorkerGlobalScope) {
                return Promise.reject(
                  new Error(
                    "The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait()."
                  )
                );
              } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
                return Promise.reject(new Error("Missing required OPFS APIs."));
              }
              if (!options2 || "object" !== typeof options2) {
                options2 = /* @__PURE__ */ Object.create(null);
              }
              const urlParams = new URL(globalThis.location.href).searchParams;
              if (urlParams.has("opfs-disable")) {
                return Promise.resolve(sqlite3);
              }
              if (void 0 === options2.verbose) {
                options2.verbose = urlParams.has("opfs-verbose") ? +urlParams.get("opfs-verbose") || 2 : 1;
              }
              if (void 0 === options2.sanityChecks) {
                options2.sanityChecks = urlParams.has("opfs-sanity-check");
              }
              if (void 0 === options2.proxyUri) {
                options2.proxyUri = callee2.defaultProxyUri;
              }
              if ("function" === typeof options2.proxyUri) {
                options2.proxyUri = options2.proxyUri();
              }
              const thePromise = new Promise(function(promiseResolve_, promiseReject_) {
                const loggers = [
                  sqlite3.config.error,
                  sqlite3.config.warn,
                  sqlite3.config.log
                ];
                const logImpl = /* @__PURE__ */ __name((level, ...args) => {
                  if (options2.verbose > level)
                    loggers[level]("OPFS syncer:", ...args);
                }, "logImpl");
                const log3 = /* @__PURE__ */ __name((...args) => logImpl(2, ...args), "log");
                const warn3 = /* @__PURE__ */ __name((...args) => logImpl(1, ...args), "warn");
                const error22 = /* @__PURE__ */ __name((...args) => logImpl(0, ...args), "error2");
                const toss = sqlite3.util.toss;
                const capi = sqlite3.capi;
                const util = sqlite3.util;
                const wasm2 = sqlite3.wasm;
                const sqlite3_vfs = capi.sqlite3_vfs;
                const sqlite3_file = capi.sqlite3_file;
                const sqlite3_io_methods = capi.sqlite3_io_methods;
                const opfsUtil = /* @__PURE__ */ Object.create(null);
                const thisThreadHasOPFS = /* @__PURE__ */ __name(() => {
                  return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && navigator?.storage?.getDirectory;
                }, "thisThreadHasOPFS");
                opfsUtil.metrics = {
                  dump: /* @__PURE__ */ __name(function() {
                    let k, n2 = 0, t2 = 0, w = 0;
                    for (k in state2.opIds) {
                      const m = metrics[k];
                      n2 += m.count;
                      t2 += m.time;
                      w += m.wait;
                      m.avgTime = m.count && m.time ? m.time / m.count : 0;
                      m.avgWait = m.count && m.wait ? m.wait / m.count : 0;
                    }
                    sqlite3.config.log(
                      globalThis.location.href,
                      "metrics for",
                      globalThis.location.href,
                      ":",
                      metrics,
                      "\nTotal of",
                      n2,
                      "op(s) for",
                      t2,
                      "ms (incl. " + w + " ms of waiting on the async side)"
                    );
                    sqlite3.config.log("Serialization metrics:", metrics.s11n);
                    W.postMessage({ type: "opfs-async-metrics" });
                  }, "dump"),
                  reset: /* @__PURE__ */ __name(function() {
                    let k;
                    const r3 = /* @__PURE__ */ __name((m) => m.count = m.time = m.wait = 0, "r3");
                    for (k in state2.opIds) {
                      r3(metrics[k] = /* @__PURE__ */ Object.create(null));
                    }
                    let s3 = metrics.s11n = /* @__PURE__ */ Object.create(null);
                    s3 = s3.serialize = /* @__PURE__ */ Object.create(null);
                    s3.count = s3.time = 0;
                    s3 = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);
                    s3.count = s3.time = 0;
                  }, "reset")
                };
                const opfsIoMethods = new sqlite3_io_methods();
                const opfsVfs = new sqlite3_vfs().addOnDispose(
                  () => opfsIoMethods.dispose()
                );
                let promiseWasRejected = void 0;
                const promiseReject = /* @__PURE__ */ __name((err2) => {
                  promiseWasRejected = true;
                  opfsVfs.dispose();
                  return promiseReject_(err2);
                }, "promiseReject");
                const promiseResolve = /* @__PURE__ */ __name(() => {
                  promiseWasRejected = false;
                  return promiseResolve_(sqlite3);
                }, "promiseResolve");
                const W = new Worker(
                  new URL("sqlite3-opfs-async-proxy.js", import.meta.url)
                );
                setTimeout(() => {
                  if (void 0 === promiseWasRejected) {
                    promiseReject(
                      new Error(
                        "Timeout while waiting for OPFS async proxy worker."
                      )
                    );
                  }
                }, 4e3);
                W._originalOnError = W.onerror;
                W.onerror = function(err2) {
                  error22("Error initializing OPFS asyncer:", err2);
                  promiseReject(
                    new Error(
                      "Loading OPFS async Worker failed for unknown reasons."
                    )
                  );
                };
                const pDVfs = capi.sqlite3_vfs_find(null);
                const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
                opfsIoMethods.$iVersion = 1;
                opfsVfs.$iVersion = 2;
                opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
                opfsVfs.$mxPathname = 1024;
                opfsVfs.$zName = wasm2.allocCString("opfs");
                opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
                opfsVfs.addOnDispose(
                  "$zName",
                  opfsVfs.$zName,
                  "cleanup default VFS wrapper",
                  () => dVfs ? dVfs.dispose() : null
                );
                const state2 = /* @__PURE__ */ Object.create(null);
                state2.verbose = options2.verbose;
                state2.littleEndian = (() => {
                  const buffer = new ArrayBuffer(2);
                  new DataView(buffer).setInt16(0, 256, true);
                  return new Int16Array(buffer)[0] === 256;
                })();
                state2.asyncIdleWaitTime = 150;
                state2.asyncS11nExceptions = 1;
                state2.fileBufferSize = 1024 * 64;
                state2.sabS11nOffset = state2.fileBufferSize;
                state2.sabS11nSize = opfsVfs.$mxPathname * 2;
                state2.sabIO = new SharedArrayBuffer(
                  state2.fileBufferSize + state2.sabS11nSize
                );
                state2.opIds = /* @__PURE__ */ Object.create(null);
                const metrics = /* @__PURE__ */ Object.create(null);
                {
                  let i = 0;
                  state2.opIds.whichOp = i++;
                  state2.opIds.rc = i++;
                  state2.opIds.xAccess = i++;
                  state2.opIds.xClose = i++;
                  state2.opIds.xDelete = i++;
                  state2.opIds.xDeleteNoWait = i++;
                  state2.opIds.xFileSize = i++;
                  state2.opIds.xLock = i++;
                  state2.opIds.xOpen = i++;
                  state2.opIds.xRead = i++;
                  state2.opIds.xSleep = i++;
                  state2.opIds.xSync = i++;
                  state2.opIds.xTruncate = i++;
                  state2.opIds.xUnlock = i++;
                  state2.opIds.xWrite = i++;
                  state2.opIds.mkdir = i++;
                  state2.opIds["opfs-async-metrics"] = i++;
                  state2.opIds["opfs-async-shutdown"] = i++;
                  state2.opIds.retry = i++;
                  state2.sabOP = new SharedArrayBuffer(i * 4);
                  opfsUtil.metrics.reset();
                }
                state2.sq3Codes = /* @__PURE__ */ Object.create(null);
                [
                  "SQLITE_ACCESS_EXISTS",
                  "SQLITE_ACCESS_READWRITE",
                  "SQLITE_BUSY",
                  "SQLITE_CANTOPEN",
                  "SQLITE_ERROR",
                  "SQLITE_IOERR",
                  "SQLITE_IOERR_ACCESS",
                  "SQLITE_IOERR_CLOSE",
                  "SQLITE_IOERR_DELETE",
                  "SQLITE_IOERR_FSYNC",
                  "SQLITE_IOERR_LOCK",
                  "SQLITE_IOERR_READ",
                  "SQLITE_IOERR_SHORT_READ",
                  "SQLITE_IOERR_TRUNCATE",
                  "SQLITE_IOERR_UNLOCK",
                  "SQLITE_IOERR_WRITE",
                  "SQLITE_LOCK_EXCLUSIVE",
                  "SQLITE_LOCK_NONE",
                  "SQLITE_LOCK_PENDING",
                  "SQLITE_LOCK_RESERVED",
                  "SQLITE_LOCK_SHARED",
                  "SQLITE_LOCKED",
                  "SQLITE_MISUSE",
                  "SQLITE_NOTFOUND",
                  "SQLITE_OPEN_CREATE",
                  "SQLITE_OPEN_DELETEONCLOSE",
                  "SQLITE_OPEN_MAIN_DB",
                  "SQLITE_OPEN_READONLY"
                ].forEach((k) => {
                  if (void 0 === (state2.sq3Codes[k] = capi[k])) {
                    toss("Maintenance required: not found:", k);
                  }
                });
                state2.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {
                  OPFS_UNLOCK_ASAP: 1,
                  OPFS_UNLINK_BEFORE_OPEN: 2,
                  defaultUnlockAsap: false
                });
                const opRun = /* @__PURE__ */ __name((op, ...args) => {
                  const opNdx = state2.opIds[op] || toss("Invalid op ID:", op);
                  state2.s11n.serialize(...args);
                  Atomics.store(state2.sabOPView, state2.opIds.rc, -1);
                  Atomics.store(state2.sabOPView, state2.opIds.whichOp, opNdx);
                  Atomics.notify(state2.sabOPView, state2.opIds.whichOp);
                  const t2 = performance.now();
                  while ("not-equal" !== Atomics.wait(state2.sabOPView, state2.opIds.rc, -1)) {
                  }
                  const rc = Atomics.load(state2.sabOPView, state2.opIds.rc);
                  metrics[op].wait += performance.now() - t2;
                  if (rc && state2.asyncS11nExceptions) {
                    const err2 = state2.s11n.deserialize();
                    if (err2) error22(op + "() async error:", ...err2);
                  }
                  return rc;
                }, "opRun");
                opfsUtil.debug = {
                  asyncShutdown: /* @__PURE__ */ __name(() => {
                    warn3(
                      "Shutting down OPFS async listener. The OPFS VFS will no longer work."
                    );
                    opRun("opfs-async-shutdown");
                  }, "asyncShutdown"),
                  asyncRestart: /* @__PURE__ */ __name(() => {
                    warn3(
                      "Attempting to restart OPFS VFS async listener. Might work, might not."
                    );
                    W.postMessage({ type: "opfs-async-restart" });
                  }, "asyncRestart")
                };
                const initS11n = /* @__PURE__ */ __name(() => {
                  if (state2.s11n) return state2.s11n;
                  const textDecoder = new TextDecoder(), textEncoder = new TextEncoder("utf-8"), viewU8 = new Uint8Array(
                    state2.sabIO,
                    state2.sabS11nOffset,
                    state2.sabS11nSize
                  ), viewDV = new DataView(
                    state2.sabIO,
                    state2.sabS11nOffset,
                    state2.sabS11nSize
                  );
                  state2.s11n = /* @__PURE__ */ Object.create(null);
                  const TypeIds = /* @__PURE__ */ Object.create(null);
                  TypeIds.number = {
                    id: 1,
                    size: 8,
                    getter: "getFloat64",
                    setter: "setFloat64"
                  };
                  TypeIds.bigint = {
                    id: 2,
                    size: 8,
                    getter: "getBigInt64",
                    setter: "setBigInt64"
                  };
                  TypeIds.boolean = {
                    id: 3,
                    size: 4,
                    getter: "getInt32",
                    setter: "setInt32"
                  };
                  TypeIds.string = { id: 4 };
                  const getTypeId = /* @__PURE__ */ __name((v2) => TypeIds[typeof v2] || toss(
                    "Maintenance required: this value type cannot be serialized.",
                    v2
                  ), "getTypeId");
                  const getTypeIdById = /* @__PURE__ */ __name((tid) => {
                    switch (tid) {
                      case TypeIds.number.id:
                        return TypeIds.number;
                      case TypeIds.bigint.id:
                        return TypeIds.bigint;
                      case TypeIds.boolean.id:
                        return TypeIds.boolean;
                      case TypeIds.string.id:
                        return TypeIds.string;
                      default:
                        toss("Invalid type ID:", tid);
                    }
                  }, "getTypeIdById");
                  state2.s11n.deserialize = function(clear3 = false) {
                    ++metrics.s11n.deserialize.count;
                    const t2 = performance.now();
                    const argc = viewU8[0];
                    const rc = argc ? [] : null;
                    if (argc) {
                      const typeIds = [];
                      let offset = 1, i, n2, v2;
                      for (i = 0; i < argc; ++i, ++offset) {
                        typeIds.push(getTypeIdById(viewU8[offset]));
                      }
                      for (i = 0; i < argc; ++i) {
                        const t3 = typeIds[i];
                        if (t3.getter) {
                          v2 = viewDV[t3.getter](offset, state2.littleEndian);
                          offset += t3.size;
                        } else {
                          n2 = viewDV.getInt32(offset, state2.littleEndian);
                          offset += 4;
                          v2 = textDecoder.decode(viewU8.slice(offset, offset + n2));
                          offset += n2;
                        }
                        rc.push(v2);
                      }
                    }
                    if (clear3) viewU8[0] = 0;
                    metrics.s11n.deserialize.time += performance.now() - t2;
                    return rc;
                  };
                  state2.s11n.serialize = function(...args) {
                    const t2 = performance.now();
                    ++metrics.s11n.serialize.count;
                    if (args.length) {
                      const typeIds = [];
                      let i = 0, offset = 1;
                      viewU8[0] = args.length & 255;
                      for (; i < args.length; ++i, ++offset) {
                        typeIds.push(getTypeId(args[i]));
                        viewU8[offset] = typeIds[i].id;
                      }
                      for (i = 0; i < args.length; ++i) {
                        const t3 = typeIds[i];
                        if (t3.setter) {
                          viewDV[t3.setter](offset, args[i], state2.littleEndian);
                          offset += t3.size;
                        } else {
                          const s3 = textEncoder.encode(args[i]);
                          viewDV.setInt32(offset, s3.byteLength, state2.littleEndian);
                          offset += 4;
                          viewU8.set(s3, offset);
                          offset += s3.byteLength;
                        }
                      }
                    } else {
                      viewU8[0] = 0;
                    }
                    metrics.s11n.serialize.time += performance.now() - t2;
                  };
                  return state2.s11n;
                }, "initS11n");
                const randomFilename = /* @__PURE__ */ __name(function f(len = 16) {
                  if (!f._chars) {
                    f._chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789";
                    f._n = f._chars.length;
                  }
                  const a = [];
                  let i = 0;
                  for (; i < len; ++i) {
                    const ndx = Math.random() * (f._n * 64) % f._n | 0;
                    a[i] = f._chars[ndx];
                  }
                  return a.join("");
                }, "f");
                const __openFiles = /* @__PURE__ */ Object.create(null);
                const opTimer = /* @__PURE__ */ Object.create(null);
                opTimer.op = void 0;
                opTimer.start = void 0;
                const mTimeStart = /* @__PURE__ */ __name((op) => {
                  opTimer.start = performance.now();
                  opTimer.op = op;
                  ++metrics[op].count;
                }, "mTimeStart");
                const mTimeEnd = /* @__PURE__ */ __name(() => metrics[opTimer.op].time += performance.now() - opTimer.start, "mTimeEnd");
                const ioSyncWrappers = {
                  xCheckReservedLock: /* @__PURE__ */ __name(function(pFile, pOut) {
                    wasm2.poke(pOut, 0, "i32");
                    return 0;
                  }, "xCheckReservedLock"),
                  xClose: /* @__PURE__ */ __name(function(pFile) {
                    mTimeStart("xClose");
                    let rc = 0;
                    const f = __openFiles[pFile];
                    if (f) {
                      delete __openFiles[pFile];
                      rc = opRun("xClose", pFile);
                      if (f.sq3File) f.sq3File.dispose();
                    }
                    mTimeEnd();
                    return rc;
                  }, "xClose"),
                  xDeviceCharacteristics: /* @__PURE__ */ __name(function(pFile) {
                    return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
                  }, "xDeviceCharacteristics"),
                  xFileControl: /* @__PURE__ */ __name(function(pFile, opId, pArg) {
                    return capi.SQLITE_NOTFOUND;
                  }, "xFileControl"),
                  xFileSize: /* @__PURE__ */ __name(function(pFile, pSz64) {
                    mTimeStart("xFileSize");
                    let rc = opRun("xFileSize", pFile);
                    if (0 == rc) {
                      try {
                        const sz = state2.s11n.deserialize()[0];
                        wasm2.poke(pSz64, sz, "i64");
                      } catch (e3) {
                        error22("Unexpected error reading xFileSize() result:", e3);
                        rc = state2.sq3Codes.SQLITE_IOERR;
                      }
                    }
                    mTimeEnd();
                    return rc;
                  }, "xFileSize"),
                  xLock: /* @__PURE__ */ __name(function(pFile, lockType) {
                    mTimeStart("xLock");
                    const f = __openFiles[pFile];
                    let rc = 0;
                    if (!f.lockType) {
                      rc = opRun("xLock", pFile, lockType);
                      if (0 === rc) f.lockType = lockType;
                    } else {
                      f.lockType = lockType;
                    }
                    mTimeEnd();
                    return rc;
                  }, "xLock"),
                  xRead: /* @__PURE__ */ __name(function(pFile, pDest, n2, offset64) {
                    mTimeStart("xRead");
                    const f = __openFiles[pFile];
                    let rc;
                    try {
                      rc = opRun("xRead", pFile, n2, Number(offset64));
                      if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                        wasm2.heap8u().set(f.sabView.subarray(0, n2), pDest);
                      }
                    } catch (e3) {
                      error22("xRead(", arguments, ") failed:", e3, f);
                      rc = capi.SQLITE_IOERR_READ;
                    }
                    mTimeEnd();
                    return rc;
                  }, "xRead"),
                  xSync: /* @__PURE__ */ __name(function(pFile, flags2) {
                    mTimeStart("xSync");
                    ++metrics.xSync.count;
                    const rc = opRun("xSync", pFile, flags2);
                    mTimeEnd();
                    return rc;
                  }, "xSync"),
                  xTruncate: /* @__PURE__ */ __name(function(pFile, sz64) {
                    mTimeStart("xTruncate");
                    const rc = opRun("xTruncate", pFile, Number(sz64));
                    mTimeEnd();
                    return rc;
                  }, "xTruncate"),
                  xUnlock: /* @__PURE__ */ __name(function(pFile, lockType) {
                    mTimeStart("xUnlock");
                    const f = __openFiles[pFile];
                    let rc = 0;
                    if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {
                      rc = opRun("xUnlock", pFile, lockType);
                    }
                    if (0 === rc) f.lockType = lockType;
                    mTimeEnd();
                    return rc;
                  }, "xUnlock"),
                  xWrite: /* @__PURE__ */ __name(function(pFile, pSrc, n2, offset64) {
                    mTimeStart("xWrite");
                    const f = __openFiles[pFile];
                    let rc;
                    try {
                      f.sabView.set(wasm2.heap8u().subarray(pSrc, pSrc + n2));
                      rc = opRun("xWrite", pFile, n2, Number(offset64));
                    } catch (e3) {
                      error22("xWrite(", arguments, ") failed:", e3, f);
                      rc = capi.SQLITE_IOERR_WRITE;
                    }
                    mTimeEnd();
                    return rc;
                  }, "xWrite")
                };
                const vfsSyncWrappers = {
                  xAccess: /* @__PURE__ */ __name(function(pVfs, zName, flags2, pOut) {
                    mTimeStart("xAccess");
                    const rc = opRun("xAccess", wasm2.cstrToJs(zName));
                    wasm2.poke(pOut, rc ? 0 : 1, "i32");
                    mTimeEnd();
                    return 0;
                  }, "xAccess"),
                  xCurrentTime: /* @__PURE__ */ __name(function(pVfs, pOut) {
                    wasm2.poke(
                      pOut,
                      24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                      "double"
                    );
                    return 0;
                  }, "xCurrentTime"),
                  xCurrentTimeInt64: /* @__PURE__ */ __name(function(pVfs, pOut) {
                    wasm2.poke(
                      pOut,
                      24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),
                      "i64"
                    );
                    return 0;
                  }, "xCurrentTimeInt64"),
                  xDelete: /* @__PURE__ */ __name(function(pVfs, zName, doSyncDir) {
                    mTimeStart("xDelete");
                    const rc = opRun(
                      "xDelete",
                      wasm2.cstrToJs(zName),
                      doSyncDir,
                      false
                    );
                    mTimeEnd();
                    return rc;
                  }, "xDelete"),
                  xFullPathname: /* @__PURE__ */ __name(function(pVfs, zName, nOut, pOut) {
                    const i = wasm2.cstrncpy(pOut, zName, nOut);
                    return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
                  }, "xFullPathname"),
                  xGetLastError: /* @__PURE__ */ __name(function(pVfs, nOut, pOut) {
                    warn3("OPFS xGetLastError() has nothing sensible to return.");
                    return 0;
                  }, "xGetLastError"),
                  xOpen: /* @__PURE__ */ __name(function f(pVfs, zName, pFile, flags2, pOutFlags) {
                    mTimeStart("xOpen");
                    let opfsFlags = 0;
                    if (0 === zName) {
                      zName = randomFilename();
                    } else if (wasm2.isPtr(zName)) {
                      if (capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)) {
                        opfsFlags |= state2.opfsFlags.OPFS_UNLOCK_ASAP;
                      }
                      if (capi.sqlite3_uri_boolean(zName, "delete-before-open", 0)) {
                        opfsFlags |= state2.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;
                      }
                      zName = wasm2.cstrToJs(zName);
                    }
                    const fh = /* @__PURE__ */ Object.create(null);
                    fh.fid = pFile;
                    fh.filename = zName;
                    fh.sab = new SharedArrayBuffer(state2.fileBufferSize);
                    fh.flags = flags2;
                    fh.readOnly = !(sqlite3.SQLITE_OPEN_CREATE & flags2) && !!(flags2 & capi.SQLITE_OPEN_READONLY);
                    const rc = opRun("xOpen", pFile, zName, flags2, opfsFlags);
                    if (!rc) {
                      if (fh.readOnly) {
                        wasm2.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, "i32");
                      }
                      __openFiles[pFile] = fh;
                      fh.sabView = state2.sabFileBufView;
                      fh.sq3File = new sqlite3_file(pFile);
                      fh.sq3File.$pMethods = opfsIoMethods.pointer;
                      fh.lockType = capi.SQLITE_LOCK_NONE;
                    }
                    mTimeEnd();
                    return rc;
                  }, "f")
                };
                if (dVfs) {
                  opfsVfs.$xRandomness = dVfs.$xRandomness;
                  opfsVfs.$xSleep = dVfs.$xSleep;
                }
                if (!opfsVfs.$xRandomness) {
                  vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {
                    const heap = wasm2.heap8u();
                    let i = 0;
                    for (; i < nOut; ++i)
                      heap[pOut + i] = Math.random() * 255e3 & 255;
                    return i;
                  };
                }
                if (!opfsVfs.$xSleep) {
                  vfsSyncWrappers.xSleep = function(pVfs, ms) {
                    Atomics.wait(state2.sabOPView, state2.opIds.xSleep, 0, ms);
                    return 0;
                  };
                }
                opfsUtil.getResolvedPath = function(filename, splitIt) {
                  const p = new URL(filename, "file://irrelevant").pathname;
                  return splitIt ? p.split("/").filter((v2) => !!v2) : p;
                };
                opfsUtil.getDirForFilename = /* @__PURE__ */ __name(async function f(absFilename, createDirs = false) {
                  const path = opfsUtil.getResolvedPath(absFilename, true);
                  const filename = path.pop();
                  let dh = opfsUtil.rootDirectory;
                  for (const dirName of path) {
                    if (dirName) {
                      dh = await dh.getDirectoryHandle(dirName, {
                        create: !!createDirs
                      });
                    }
                  }
                  return [dh, filename];
                }, "f");
                opfsUtil.mkdir = async function(absDirName) {
                  try {
                    await opfsUtil.getDirForFilename(
                      absDirName + "/filepart",
                      true
                    );
                    return true;
                  } catch (e3) {
                    return false;
                  }
                };
                opfsUtil.entryExists = async function(fsEntryName) {
                  try {
                    const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                    await dh.getFileHandle(fn);
                    return true;
                  } catch (e3) {
                    return false;
                  }
                };
                opfsUtil.randomFilename = randomFilename;
                opfsUtil.treeList = async function() {
                  const doDir = /* @__PURE__ */ __name(async function callee3(dirHandle, tgt) {
                    tgt.name = dirHandle.name;
                    tgt.dirs = [];
                    tgt.files = [];
                    for await (const handle2 of dirHandle.values()) {
                      if ("directory" === handle2.kind) {
                        const subDir = /* @__PURE__ */ Object.create(null);
                        tgt.dirs.push(subDir);
                        await callee3(handle2, subDir);
                      } else {
                        tgt.files.push(handle2.name);
                      }
                    }
                  }, "callee3");
                  const root2 = /* @__PURE__ */ Object.create(null);
                  await doDir(opfsUtil.rootDirectory, root2);
                  return root2;
                };
                opfsUtil.rmfr = async function() {
                  const dir3 = opfsUtil.rootDirectory, opt = { recurse: true };
                  for await (const handle2 of dir3.values()) {
                    dir3.removeEntry(handle2.name, opt);
                  }
                };
                opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {
                  try {
                    const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                      fsEntryName,
                      false
                    );
                    await hDir.removeEntry(filenamePart, { recursive });
                    return true;
                  } catch (e3) {
                    if (throwOnError) {
                      throw new Error(
                        "unlink(",
                        arguments[0],
                        ") failed: " + e3.message,
                        {
                          cause: e3
                        }
                      );
                    }
                    return false;
                  }
                };
                opfsUtil.traverse = async function(opt) {
                  const defaultOpt = {
                    recursive: true,
                    directory: opfsUtil.rootDirectory
                  };
                  if ("function" === typeof opt) {
                    opt = { callback: opt };
                  }
                  opt = Object.assign(defaultOpt, opt || {});
                  const doDir = /* @__PURE__ */ __name(async function callee3(dirHandle, depth) {
                    for await (const handle2 of dirHandle.values()) {
                      if (false === opt.callback(handle2, dirHandle, depth))
                        return false;
                      else if (opt.recursive && "directory" === handle2.kind) {
                        if (false === await callee3(handle2, depth + 1)) break;
                      }
                    }
                  }, "callee3");
                  doDir(opt.directory, 0);
                };
                const importDbChunked = /* @__PURE__ */ __name(async function(filename, callback) {
                  const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                    filename,
                    true
                  );
                  const hFile = await hDir.getFileHandle(fnamePart, {
                    create: true
                  });
                  let sah = await hFile.createSyncAccessHandle();
                  let nWrote = 0, chunk, checkedHeader = false, err2 = false;
                  try {
                    sah.truncate(0);
                    while (void 0 !== (chunk = await callback())) {
                      if (chunk instanceof ArrayBuffer)
                        chunk = new Uint8Array(chunk);
                      if (0 === nWrote && chunk.byteLength >= 15) {
                        util.affirmDbHeader(chunk);
                        checkedHeader = true;
                      }
                      sah.write(chunk, { at: nWrote });
                      nWrote += chunk.byteLength;
                    }
                    if (nWrote < 512 || 0 !== nWrote % 512) {
                      toss(
                        "Input size",
                        nWrote,
                        "is not correct for an SQLite database."
                      );
                    }
                    if (!checkedHeader) {
                      const header = new Uint8Array(20);
                      sah.read(header, { at: 0 });
                      util.affirmDbHeader(header);
                    }
                    sah.write(new Uint8Array([1, 1]), { at: 18 });
                    return nWrote;
                  } catch (e3) {
                    await sah.close();
                    sah = void 0;
                    await hDir.removeEntry(fnamePart).catch(() => {
                    });
                    throw e3;
                  } finally {
                    if (sah) await sah.close();
                  }
                }, "importDbChunked");
                opfsUtil.importDb = async function(filename, bytes) {
                  if (bytes instanceof Function) {
                    return importDbChunked(filename, bytes);
                  }
                  if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                  util.affirmIsDb(bytes);
                  const n2 = bytes.byteLength;
                  const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                    filename,
                    true
                  );
                  let sah, err2, nWrote = 0;
                  try {
                    const hFile = await hDir.getFileHandle(fnamePart, {
                      create: true
                    });
                    sah = await hFile.createSyncAccessHandle();
                    sah.truncate(0);
                    nWrote = sah.write(bytes, { at: 0 });
                    if (nWrote != n2) {
                      toss(
                        "Expected to write " + n2 + " bytes but wrote " + nWrote + "."
                      );
                    }
                    sah.write(new Uint8Array([1, 1]), { at: 18 });
                    return nWrote;
                  } catch (e3) {
                    if (sah) {
                      await sah.close();
                      sah = void 0;
                    }
                    await hDir.removeEntry(fnamePart).catch(() => {
                    });
                    throw e3;
                  } finally {
                    if (sah) await sah.close();
                  }
                };
                if (sqlite3.oo1) {
                  const OpfsDb = /* @__PURE__ */ __name(function(...args) {
                    const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                    opt.vfs = opfsVfs.$zName;
                    sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
                  }, "OpfsDb");
                  OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
                  sqlite3.oo1.OpfsDb = OpfsDb;
                  OpfsDb.importDb = opfsUtil.importDb;
                  sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(
                    opfsVfs.pointer,
                    function(oo1Db, sqlite32) {
                      sqlite32.capi.sqlite3_busy_timeout(oo1Db, 1e4);
                    }
                  );
                }
                const sanityCheck = /* @__PURE__ */ __name(function() {
                  const scope = wasm2.scopedAllocPush();
                  const sq3File = new sqlite3_file();
                  try {
                    const fid = sq3File.pointer;
                    const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;
                    const pOut = wasm2.scopedAlloc(8);
                    const dbFile = "/sanity/check/file" + randomFilename(8);
                    const zDbFile = wasm2.scopedAllocCString(dbFile);
                    let rc;
                    state2.s11n.serialize("This is \xE4 string.");
                    rc = state2.s11n.deserialize();
                    log3("deserialize() says:", rc);
                    if ("This is \xE4 string." !== rc[0]) toss("String d13n error.");
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm2.peek(pOut, "i32");
                    log3("xAccess(", dbFile, ") exists ?=", rc);
                    rc = vfsSyncWrappers.xOpen(
                      opfsVfs.pointer,
                      zDbFile,
                      fid,
                      openFlags,
                      pOut
                    );
                    log3(
                      "open rc =",
                      rc,
                      "state.sabOPView[xOpen] =",
                      state2.sabOPView[state2.opIds.xOpen]
                    );
                    if (0 !== rc) {
                      error22("open failed with code", rc);
                      return;
                    }
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm2.peek(pOut, "i32");
                    if (!rc) toss("xAccess() failed to detect file.");
                    rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                    if (rc) toss("sync failed w/ rc", rc);
                    rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                    if (rc) toss("truncate failed w/ rc", rc);
                    wasm2.poke(pOut, 0, "i64");
                    rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                    if (rc) toss("xFileSize failed w/ rc", rc);
                    log3("xFileSize says:", wasm2.peek(pOut, "i64"));
                    rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                    if (rc) toss("xWrite() failed!");
                    const readBuf = wasm2.scopedAlloc(16);
                    rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                    wasm2.poke(readBuf + 6, 0);
                    let jRead = wasm2.cstrToJs(readBuf);
                    log3("xRead() got:", jRead);
                    if ("sanity" !== jRead) toss("Unexpected xRead() value.");
                    if (vfsSyncWrappers.xSleep) {
                      log3("xSleep()ing before close()ing...");
                      vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);
                      log3("waking up from xSleep()");
                    }
                    rc = ioSyncWrappers.xClose(fid);
                    log3("xClose rc =", rc, "sabOPView =", state2.sabOPView);
                    log3("Deleting file:", dbFile);
                    vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm2.peek(pOut, "i32");
                    if (rc)
                      toss(
                        "Expecting 0 from xAccess(",
                        dbFile,
                        ") after xDelete()."
                      );
                    warn3("End of OPFS sanity checks.");
                  } finally {
                    sq3File.dispose();
                    wasm2.scopedAllocPop(scope);
                  }
                }, "sanityCheck");
                W.onmessage = function({ data }) {
                  switch (data.type) {
                    case "opfs-unavailable":
                      promiseReject(new Error(data.payload.join(" ")));
                      break;
                    case "opfs-async-loaded":
                      W.postMessage({ type: "opfs-async-init", args: state2 });
                      break;
                    case "opfs-async-inited": {
                      if (true === promiseWasRejected) {
                        break;
                      }
                      try {
                        sqlite3.vfs.installVfs({
                          io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                          vfs: { struct: opfsVfs, methods: vfsSyncWrappers }
                        });
                        state2.sabOPView = new Int32Array(state2.sabOP);
                        state2.sabFileBufView = new Uint8Array(
                          state2.sabIO,
                          0,
                          state2.fileBufferSize
                        );
                        state2.sabS11nView = new Uint8Array(
                          state2.sabIO,
                          state2.sabS11nOffset,
                          state2.sabS11nSize
                        );
                        initS11n();
                        if (options2.sanityChecks) {
                          warn3(
                            "Running sanity checks because of opfs-sanity-check URL arg..."
                          );
                          sanityCheck();
                        }
                        if (thisThreadHasOPFS()) {
                          navigator.storage.getDirectory().then((d) => {
                            W.onerror = W._originalOnError;
                            delete W._originalOnError;
                            sqlite3.opfs = opfsUtil;
                            opfsUtil.rootDirectory = d;
                            log3("End of OPFS sqlite3_vfs setup.", opfsVfs);
                            promiseResolve();
                          }).catch(promiseReject);
                        } else {
                          promiseResolve();
                        }
                      } catch (e3) {
                        error22(e3);
                        promiseReject(e3);
                      }
                      break;
                    }
                    default: {
                      const errMsg = "Unexpected message from the OPFS async worker: " + JSON.stringify(data);
                      error22(errMsg);
                      promiseReject(new Error(errMsg));
                      break;
                    }
                  }
                };
              });
              return thePromise;
            }, "callee2");
            installOpfsVfs.defaultProxyUri = "sqlite3-opfs-async-proxy.js";
            globalThis.sqlite3ApiBootstrap.initializersAsync.push(
              async (sqlite32) => {
                try {
                  let proxyJs = installOpfsVfs.defaultProxyUri;
                  if (sqlite32.scriptInfo.sqlite3Dir) {
                    installOpfsVfs.defaultProxyUri = sqlite32.scriptInfo.sqlite3Dir + proxyJs;
                  }
                  return installOpfsVfs().catch((e3) => {
                    sqlite32.config.warn(
                      "Ignoring inability to install OPFS sqlite3_vfs:",
                      e3.message
                    );
                  });
                } catch (e3) {
                  sqlite32.config.error("installOpfsVfs() exception:", e3);
                  return Promise.reject(e3);
                }
              }
            );
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
            "use strict";
            const toss = sqlite3.util.toss;
            const toss3 = sqlite3.util.toss3;
            const initPromises = /* @__PURE__ */ Object.create(null);
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm2 = sqlite3.wasm;
            const SECTOR_SIZE = 4096;
            const HEADER_MAX_PATH_SIZE = 512;
            const HEADER_FLAGS_SIZE = 4;
            const HEADER_DIGEST_SIZE = 8;
            const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
            const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
            const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
            const HEADER_OFFSET_DATA = SECTOR_SIZE;
            const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;
            const FLAG_COMPUTE_DIGEST_V2 = capi.SQLITE_OPEN_MEMORY;
            const OPAQUE_DIR_NAME = ".opaque";
            const getRandomName = /* @__PURE__ */ __name(() => Math.random().toString(36).slice(2), "getRandomName");
            const textDecoder = new TextDecoder();
            const textEncoder = new TextEncoder();
            const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {
              name: "opfs-sahpool",
              directory: void 0,
              initialCapacity: 6,
              clearOnInit: false,
              verbosity: 2,
              forceReinitIfPreviouslyFailed: false
            });
            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log
            ];
            const log3 = sqlite3.config.log;
            const warn3 = sqlite3.config.warn;
            const error22 = sqlite3.config.error;
            const __mapVfsToPool = /* @__PURE__ */ new Map();
            const getPoolForVfs = /* @__PURE__ */ __name((pVfs) => __mapVfsToPool.get(pVfs), "getPoolForVfs");
            const setPoolForVfs = /* @__PURE__ */ __name((pVfs, pool) => {
              if (pool) __mapVfsToPool.set(pVfs, pool);
              else __mapVfsToPool.delete(pVfs);
            }, "setPoolForVfs");
            const __mapSqlite3File = /* @__PURE__ */ new Map();
            const getPoolForPFile = /* @__PURE__ */ __name((pFile) => __mapSqlite3File.get(pFile), "getPoolForPFile");
            const setPoolForPFile = /* @__PURE__ */ __name((pFile, pool) => {
              if (pool) __mapSqlite3File.set(pFile, pool);
              else __mapSqlite3File.delete(pFile);
            }, "setPoolForPFile");
            const ioMethods = {
              xCheckReservedLock: /* @__PURE__ */ __name(function(pFile, pOut) {
                const pool = getPoolForPFile(pFile);
                pool.log("xCheckReservedLock");
                pool.storeErr();
                wasm2.poke32(pOut, 1);
                return 0;
              }, "xCheckReservedLock"),
              xClose: /* @__PURE__ */ __name(function(pFile) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                if (file) {
                  try {
                    pool.log(`xClose ${file.path}`);
                    pool.mapS3FileToOFile(pFile, false);
                    file.sah.flush();
                    if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                      pool.deletePath(file.path);
                    }
                  } catch (e3) {
                    return pool.storeErr(e3, capi.SQLITE_IOERR);
                  }
                }
                return 0;
              }, "xClose"),
              xDeviceCharacteristics: /* @__PURE__ */ __name(function(pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              }, "xDeviceCharacteristics"),
              xFileControl: /* @__PURE__ */ __name(function(pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              }, "xFileControl"),
              xFileSize: /* @__PURE__ */ __name(function(pFile, pSz64) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xFileSize`);
                const file = pool.getOFileForS3File(pFile);
                const size = file.sah.getSize() - HEADER_OFFSET_DATA;
                wasm2.poke64(pSz64, BigInt(size));
                return 0;
              }, "xFileSize"),
              xLock: /* @__PURE__ */ __name(function(pFile, lockType) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xLock ${lockType}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                file.lockType = lockType;
                return 0;
              }, "xLock"),
              xRead: /* @__PURE__ */ __name(function(pFile, pDest, n2, offset64) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                pool.log(`xRead ${file.path} ${n2} @ ${offset64}`);
                try {
                  const nRead = file.sah.read(
                    wasm2.heap8u().subarray(pDest, pDest + n2),
                    { at: HEADER_OFFSET_DATA + Number(offset64) }
                  );
                  if (nRead < n2) {
                    wasm2.heap8u().fill(0, pDest + nRead, pDest + n2);
                    return capi.SQLITE_IOERR_SHORT_READ;
                  }
                  return 0;
                } catch (e3) {
                  return pool.storeErr(e3, capi.SQLITE_IOERR);
                }
              }, "xRead"),
              xSectorSize: /* @__PURE__ */ __name(function(pFile) {
                return SECTOR_SIZE;
              }, "xSectorSize"),
              xSync: /* @__PURE__ */ __name(function(pFile, flags2) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xSync ${flags2}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                try {
                  file.sah.flush();
                  return 0;
                } catch (e3) {
                  return pool.storeErr(e3, capi.SQLITE_IOERR);
                }
              }, "xSync"),
              xTruncate: /* @__PURE__ */ __name(function(pFile, sz64) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xTruncate ${sz64}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                try {
                  file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
                  return 0;
                } catch (e3) {
                  return pool.storeErr(e3, capi.SQLITE_IOERR);
                }
              }, "xTruncate"),
              xUnlock: /* @__PURE__ */ __name(function(pFile, lockType) {
                const pool = getPoolForPFile(pFile);
                pool.log("xUnlock");
                const file = pool.getOFileForS3File(pFile);
                file.lockType = lockType;
                return 0;
              }, "xUnlock"),
              xWrite: /* @__PURE__ */ __name(function(pFile, pSrc, n2, offset64) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                pool.log(`xWrite ${file.path} ${n2} ${offset64}`);
                try {
                  const nBytes = file.sah.write(
                    wasm2.heap8u().subarray(pSrc, pSrc + n2),
                    { at: HEADER_OFFSET_DATA + Number(offset64) }
                  );
                  return n2 === nBytes ? 0 : toss("Unknown write() failure.");
                } catch (e3) {
                  return pool.storeErr(e3, capi.SQLITE_IOERR);
                }
              }, "xWrite")
            };
            const opfsIoMethods = new capi.sqlite3_io_methods();
            opfsIoMethods.$iVersion = 1;
            sqlite3.vfs.installVfs({
              io: { struct: opfsIoMethods, methods: ioMethods }
            });
            const vfsMethods = {
              xAccess: /* @__PURE__ */ __name(function(pVfs, zName, flags2, pOut) {
                const pool = getPoolForVfs(pVfs);
                pool.storeErr();
                try {
                  const name = pool.getPath(zName);
                  wasm2.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
                } catch (e3) {
                  wasm2.poke32(pOut, 0);
                }
                return 0;
              }, "xAccess"),
              xCurrentTime: /* @__PURE__ */ __name(function(pVfs, pOut) {
                wasm2.poke(
                  pOut,
                  24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                  "double"
                );
                return 0;
              }, "xCurrentTime"),
              xCurrentTimeInt64: /* @__PURE__ */ __name(function(pVfs, pOut) {
                wasm2.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), "i64");
                return 0;
              }, "xCurrentTimeInt64"),
              xDelete: /* @__PURE__ */ __name(function(pVfs, zName, doSyncDir) {
                const pool = getPoolForVfs(pVfs);
                pool.log(`xDelete ${wasm2.cstrToJs(zName)}`);
                pool.storeErr();
                try {
                  pool.deletePath(pool.getPath(zName));
                  return 0;
                } catch (e3) {
                  pool.storeErr(e3);
                  return capi.SQLITE_IOERR_DELETE;
                }
              }, "xDelete"),
              xFullPathname: /* @__PURE__ */ __name(function(pVfs, zName, nOut, pOut) {
                const i = wasm2.cstrncpy(pOut, zName, nOut);
                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
              }, "xFullPathname"),
              xGetLastError: /* @__PURE__ */ __name(function(pVfs, nOut, pOut) {
                const pool = getPoolForVfs(pVfs);
                const e3 = pool.popErr();
                pool.log(`xGetLastError ${nOut} e =`, e3);
                if (e3) {
                  const scope = wasm2.scopedAllocPush();
                  try {
                    const [cMsg, n2] = wasm2.scopedAllocCString(e3.message, true);
                    wasm2.cstrncpy(pOut, cMsg, nOut);
                    if (n2 > nOut) wasm2.poke8(pOut + nOut - 1, 0);
                  } catch (e4) {
                    return capi.SQLITE_NOMEM;
                  } finally {
                    wasm2.scopedAllocPop(scope);
                  }
                }
                return e3 ? e3.sqlite3Rc || capi.SQLITE_IOERR : 0;
              }, "xGetLastError"),
              xOpen: /* @__PURE__ */ __name(function f(pVfs, zName, pFile, flags2, pOutFlags) {
                const pool = getPoolForVfs(pVfs);
                try {
                  flags2 &= ~FLAG_COMPUTE_DIGEST_V2;
                  pool.log(`xOpen ${wasm2.cstrToJs(zName)} ${flags2}`);
                  const path = zName && wasm2.peek8(zName) ? pool.getPath(zName) : getRandomName();
                  let sah = pool.getSAHForPath(path);
                  if (!sah && flags2 & capi.SQLITE_OPEN_CREATE) {
                    if (pool.getFileCount() < pool.getCapacity()) {
                      sah = pool.nextAvailableSAH();
                      pool.setAssociatedPath(sah, path, flags2);
                    } else {
                      toss("SAH pool is full. Cannot create file", path);
                    }
                  }
                  if (!sah) {
                    toss("file not found:", path);
                  }
                  const file = { path, flags: flags2, sah };
                  pool.mapS3FileToOFile(pFile, file);
                  file.lockType = capi.SQLITE_LOCK_NONE;
                  const sq3File = new capi.sqlite3_file(pFile);
                  sq3File.$pMethods = opfsIoMethods.pointer;
                  sq3File.dispose();
                  wasm2.poke32(pOutFlags, flags2);
                  return 0;
                } catch (e3) {
                  pool.storeErr(e3);
                  return capi.SQLITE_CANTOPEN;
                }
              }, "f")
            };
            const createOpfsVfs = /* @__PURE__ */ __name(function(vfsName) {
              if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
                toss3("VFS name is already registered:", vfsName);
              }
              const opfsVfs = new capi.sqlite3_vfs();
              const pDVfs = capi.sqlite3_vfs_find(null);
              const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
              opfsVfs.$iVersion = 2;
              opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
              opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
              opfsVfs.addOnDispose(
                opfsVfs.$zName = wasm2.allocCString(vfsName),
                () => setPoolForVfs(opfsVfs.pointer, 0)
              );
              if (dVfs) {
                opfsVfs.$xRandomness = dVfs.$xRandomness;
                opfsVfs.$xSleep = dVfs.$xSleep;
                dVfs.dispose();
              }
              if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
                vfsMethods.xRandomness = function(pVfs, nOut, pOut) {
                  const heap = wasm2.heap8u();
                  let i = 0;
                  for (; i < nOut; ++i)
                    heap[pOut + i] = Math.random() * 255e3 & 255;
                  return i;
                };
              }
              if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
                vfsMethods.xSleep = (pVfs, ms) => 0;
              }
              sqlite3.vfs.installVfs({
                vfs: { struct: opfsVfs, methods: vfsMethods }
              });
              return opfsVfs;
            }, "createOpfsVfs");
            class OpfsSAHPool {
              static {
                __name(this, "OpfsSAHPool");
              }
              vfsDir;
              #dhVfsRoot;
              #dhOpaque;
              #dhVfsParent;
              #mapSAHToName = /* @__PURE__ */ new Map();
              #mapFilenameToSAH = /* @__PURE__ */ new Map();
              #availableSAH = /* @__PURE__ */ new Set();
              #mapS3FileToOFile_ = /* @__PURE__ */ new Map();
              #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
              #dvBody;
              #cVfs;
              #verbosity;
              constructor(options2 = /* @__PURE__ */ Object.create(null)) {
                this.#verbosity = options2.verbosity ?? optionDefaults.verbosity;
                this.vfsName = options2.name || optionDefaults.name;
                this.#cVfs = createOpfsVfs(this.vfsName);
                setPoolForVfs(this.#cVfs.pointer, this);
                this.vfsDir = options2.directory || "." + this.vfsName;
                this.#dvBody = new DataView(
                  this.#apBody.buffer,
                  this.#apBody.byteOffset
                );
                this.isReady = this.reset(
                  !!(options2.clearOnInit ?? optionDefaults.clearOnInit)
                ).then(() => {
                  if (this.$error) throw this.$error;
                  return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(
                    options2.initialCapacity || optionDefaults.initialCapacity
                  );
                });
              }
              #logImpl(level, ...args) {
                if (this.#verbosity > level)
                  loggers[level](this.vfsName + ":", ...args);
              }
              log(...args) {
                this.#logImpl(2, ...args);
              }
              warn(...args) {
                this.#logImpl(1, ...args);
              }
              error(...args) {
                this.#logImpl(0, ...args);
              }
              getVfs() {
                return this.#cVfs;
              }
              getCapacity() {
                return this.#mapSAHToName.size;
              }
              getFileCount() {
                return this.#mapFilenameToSAH.size;
              }
              getFileNames() {
                const rc = [];
                for (const n2 of this.#mapFilenameToSAH.keys()) rc.push(n2);
                return rc;
              }
              async addCapacity(n2) {
                for (let i = 0; i < n2; ++i) {
                  const name = getRandomName();
                  const h = await this.#dhOpaque.getFileHandle(name, {
                    create: true
                  });
                  const ah = await h.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  this.setAssociatedPath(ah, "", 0);
                }
                return this.getCapacity();
              }
              async reduceCapacity(n2) {
                let nRm = 0;
                for (const ah of Array.from(this.#availableSAH)) {
                  if (nRm === n2 || this.getFileCount() === this.getCapacity()) {
                    break;
                  }
                  const name = this.#mapSAHToName.get(ah);
                  ah.close();
                  await this.#dhOpaque.removeEntry(name);
                  this.#mapSAHToName.delete(ah);
                  this.#availableSAH.delete(ah);
                  ++nRm;
                }
                return nRm;
              }
              releaseAccessHandles() {
                for (const ah of this.#mapSAHToName.keys()) ah.close();
                this.#mapSAHToName.clear();
                this.#mapFilenameToSAH.clear();
                this.#availableSAH.clear();
              }
              async acquireAccessHandles(clearFiles = false) {
                const files = [];
                for await (const [name, h] of this.#dhOpaque) {
                  if ("file" === h.kind) {
                    files.push([name, h]);
                  }
                }
                return Promise.all(
                  files.map(async ([name, h]) => {
                    try {
                      const ah = await h.createSyncAccessHandle();
                      this.#mapSAHToName.set(ah, name);
                      if (clearFiles) {
                        ah.truncate(HEADER_OFFSET_DATA);
                        this.setAssociatedPath(ah, "", 0);
                      } else {
                        const path = this.getAssociatedPath(ah);
                        if (path) {
                          this.#mapFilenameToSAH.set(path, ah);
                        } else {
                          this.#availableSAH.add(ah);
                        }
                      }
                    } catch (e3) {
                      this.storeErr(e3);
                      this.releaseAccessHandles();
                      throw e3;
                    }
                  })
                );
              }
              getAssociatedPath(sah) {
                sah.read(this.#apBody, { at: 0 });
                const flags2 = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
                if (this.#apBody[0] && (flags2 & capi.SQLITE_OPEN_DELETEONCLOSE || (flags2 & PERSISTENT_FILE_TYPES) === 0)) {
                  warn3(
                    `Removing file with unexpected flags ${flags2.toString(16)}`,
                    this.#apBody
                  );
                  this.setAssociatedPath(sah, "", 0);
                  return "";
                }
                const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
                sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
                const compDigest = this.computeDigest(this.#apBody, flags2);
                if (fileDigest.every((v2, i) => v2 === compDigest[i])) {
                  const pathBytes = this.#apBody.findIndex((v2) => 0 === v2);
                  if (0 === pathBytes) {
                    sah.truncate(HEADER_OFFSET_DATA);
                  }
                  return pathBytes ? textDecoder.decode(this.#apBody.subarray(0, pathBytes)) : "";
                } else {
                  warn3("Disassociating file with bad digest.");
                  this.setAssociatedPath(sah, "", 0);
                  return "";
                }
              }
              setAssociatedPath(sah, path, flags2) {
                const enc = textEncoder.encodeInto(path, this.#apBody);
                if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
                  toss("Path too long:", path);
                }
                if (path && flags2) {
                  flags2 |= FLAG_COMPUTE_DIGEST_V2;
                }
                this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
                this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags2);
                const digest = this.computeDigest(this.#apBody, flags2);
                sah.write(this.#apBody, { at: 0 });
                sah.write(digest, { at: HEADER_OFFSET_DIGEST });
                sah.flush();
                if (path) {
                  this.#mapFilenameToSAH.set(path, sah);
                  this.#availableSAH.delete(sah);
                } else {
                  sah.truncate(HEADER_OFFSET_DATA);
                  this.#availableSAH.add(sah);
                }
              }
              computeDigest(byteArray, fileFlags) {
                if (fileFlags & FLAG_COMPUTE_DIGEST_V2) {
                  let h1 = 3735928559;
                  let h2 = 1103547991;
                  for (const v2 of byteArray) {
                    h1 = Math.imul(h1 ^ v2, 2654435761);
                    h2 = Math.imul(h2 ^ v2, 104729);
                  }
                  return new Uint32Array([h1 >>> 0, h2 >>> 0]);
                } else {
                  return new Uint32Array([0, 0]);
                }
              }
              async reset(clearFiles) {
                await this.isReady;
                let h = await navigator.storage.getDirectory();
                let prev, prevName;
                for (const d of this.vfsDir.split("/")) {
                  if (d) {
                    prev = h;
                    h = await h.getDirectoryHandle(d, { create: true });
                  }
                }
                this.#dhVfsRoot = h;
                this.#dhVfsParent = prev;
                this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
                  OPAQUE_DIR_NAME,
                  { create: true }
                );
                this.releaseAccessHandles();
                return this.acquireAccessHandles(clearFiles);
              }
              getPath(arg) {
                if (wasm2.isPtr(arg)) arg = wasm2.cstrToJs(arg);
                return (arg instanceof URL ? arg : new URL(arg, "file://localhost/")).pathname;
              }
              deletePath(path) {
                const sah = this.#mapFilenameToSAH.get(path);
                if (sah) {
                  this.#mapFilenameToSAH.delete(path);
                  this.setAssociatedPath(sah, "", 0);
                }
                return !!sah;
              }
              storeErr(e3, code) {
                if (e3) {
                  e3.sqlite3Rc = code || capi.SQLITE_IOERR;
                  this.error(e3);
                }
                this.$error = e3;
                return code;
              }
              popErr() {
                const rc = this.$error;
                this.$error = void 0;
                return rc;
              }
              nextAvailableSAH() {
                const [rc] = this.#availableSAH.keys();
                return rc;
              }
              getOFileForS3File(pFile) {
                return this.#mapS3FileToOFile_.get(pFile);
              }
              mapS3FileToOFile(pFile, file) {
                if (file) {
                  this.#mapS3FileToOFile_.set(pFile, file);
                  setPoolForPFile(pFile, this);
                } else {
                  this.#mapS3FileToOFile_.delete(pFile);
                  setPoolForPFile(pFile, false);
                }
              }
              hasFilename(name) {
                return this.#mapFilenameToSAH.has(name);
              }
              getSAHForPath(path) {
                return this.#mapFilenameToSAH.get(path);
              }
              async removeVfs() {
                if (!this.#cVfs.pointer || !this.#dhOpaque) return false;
                capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
                this.#cVfs.dispose();
                delete initPromises[this.vfsName];
                try {
                  this.releaseAccessHandles();
                  await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                    recursive: true
                  });
                  this.#dhOpaque = void 0;
                  await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                    recursive: true
                  });
                  this.#dhVfsRoot = this.#dhVfsParent = void 0;
                } catch (e3) {
                  sqlite3.config.error(
                    this.vfsName,
                    "removeVfs() failed with no recovery strategy:",
                    e3
                  );
                }
                return true;
              }
              pauseVfs() {
                if (this.#mapS3FileToOFile_.size > 0) {
                  sqlite3.SQLite3Error.toss(
                    capi.SQLITE_MISUSE,
                    "Cannot pause VFS",
                    this.vfsName,
                    "because it has opened files."
                  );
                }
                if (this.#mapSAHToName.size > 0) {
                  capi.sqlite3_vfs_unregister(this.vfsName);
                  this.releaseAccessHandles();
                }
                return this;
              }
              isPaused() {
                return 0 === this.#mapSAHToName.size;
              }
              async unpauseVfs() {
                if (0 === this.#mapSAHToName.size) {
                  return this.acquireAccessHandles(false).then(
                    () => capi.sqlite3_vfs_register(this.#cVfs, 0),
                    this
                  );
                }
                return this;
              }
              exportFile(name) {
                const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:", name);
                const n2 = sah.getSize() - HEADER_OFFSET_DATA;
                const b = new Uint8Array(n2 > 0 ? n2 : 0);
                if (n2 > 0) {
                  const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
                  if (nRead != n2) {
                    toss(
                      "Expected to read " + n2 + " bytes but read " + nRead + "."
                    );
                  }
                }
                return b;
              }
              async importDbChunked(name, callback) {
                const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
                sah.truncate(0);
                let nWrote = 0, chunk, checkedHeader = false, err2 = false;
                try {
                  while (void 0 !== (chunk = await callback())) {
                    if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
                    if (0 === nWrote && chunk.byteLength >= 15) {
                      util.affirmDbHeader(chunk);
                      checkedHeader = true;
                    }
                    sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                    nWrote += chunk.byteLength;
                  }
                  if (nWrote < 512 || 0 !== nWrote % 512) {
                    toss(
                      "Input size",
                      nWrote,
                      "is not correct for an SQLite database."
                    );
                  }
                  if (!checkedHeader) {
                    const header = new Uint8Array(20);
                    sah.read(header, { at: 0 });
                    util.affirmDbHeader(header);
                  }
                  sah.write(new Uint8Array([1, 1]), {
                    at: HEADER_OFFSET_DATA + 18
                  });
                } catch (e3) {
                  this.setAssociatedPath(sah, "", 0);
                  throw e3;
                }
                this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
                return nWrote;
              }
              importDb(name, bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                else if (bytes instanceof Function)
                  return this.importDbChunked(name, bytes);
                const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
                const n2 = bytes.byteLength;
                if (n2 < 512 || n2 % 512 != 0) {
                  toss("Byte array size is invalid for an SQLite db.");
                }
                const header = "SQLite format 3";
                for (let i = 0; i < header.length; ++i) {
                  if (header.charCodeAt(i) !== bytes[i]) {
                    toss("Input does not contain an SQLite database header.");
                  }
                }
                const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
                if (nWrote != n2) {
                  this.setAssociatedPath(sah, "", 0);
                  toss(
                    "Expected to write " + n2 + " bytes but wrote " + nWrote + "."
                  );
                } else {
                  sah.write(new Uint8Array([1, 1]), {
                    at: HEADER_OFFSET_DATA + 18
                  });
                  this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
                }
                return nWrote;
              }
            }
            class OpfsSAHPoolUtil {
              static {
                __name(this, "OpfsSAHPoolUtil");
              }
              #p;
              constructor(sahPool) {
                this.#p = sahPool;
                this.vfsName = sahPool.vfsName;
              }
              async addCapacity(n2) {
                return this.#p.addCapacity(n2);
              }
              async reduceCapacity(n2) {
                return this.#p.reduceCapacity(n2);
              }
              getCapacity() {
                return this.#p.getCapacity(this.#p);
              }
              getFileCount() {
                return this.#p.getFileCount();
              }
              getFileNames() {
                return this.#p.getFileNames();
              }
              async reserveMinimumCapacity(min) {
                const c2 = this.#p.getCapacity();
                return c2 < min ? this.#p.addCapacity(min - c2) : c2;
              }
              exportFile(name) {
                return this.#p.exportFile(name);
              }
              importDb(name, bytes) {
                return this.#p.importDb(name, bytes);
              }
              async wipeFiles() {
                return this.#p.reset(true);
              }
              unlink(filename) {
                return this.#p.deletePath(filename);
              }
              async removeVfs() {
                return this.#p.removeVfs();
              }
              pauseVfs() {
                this.#p.pauseVfs();
                return this;
              }
              async unpauseVfs() {
                return this.#p.unpauseVfs().then(() => this);
              }
              isPaused() {
                return this.#p.isPaused();
              }
            }
            const apiVersionCheck = /* @__PURE__ */ __name(async () => {
              const dh = await navigator.storage.getDirectory();
              const fn = ".opfs-sahpool-sync-check-" + getRandomName();
              const fh = await dh.getFileHandle(fn, { create: true });
              const ah = await fh.createSyncAccessHandle();
              const close = ah.close();
              await close;
              await dh.removeEntry(fn);
              if (close?.then) {
                toss(
                  "The local OPFS API is too old for opfs-sahpool:",
                  "it has an async FileSystemSyncAccessHandle.close() method."
                );
              }
              return true;
            }, "apiVersionCheck");
            sqlite3.installOpfsSAHPoolVfs = async function(options2 = /* @__PURE__ */ Object.create(null)) {
              options2 = Object.assign(
                /* @__PURE__ */ Object.create(null),
                optionDefaults,
                options2 || {}
              );
              const vfsName = options2.name;
              if (options2.$testThrowPhase1) {
                throw options2.$testThrowPhase1;
              }
              if (initPromises[vfsName]) {
                try {
                  const p = await initPromises[vfsName];
                  return p;
                } catch (e3) {
                  if (options2.forceReinitIfPreviouslyFailed) {
                    delete initPromises[vfsName];
                  } else {
                    throw e3;
                  }
                }
              }
              if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
                return initPromises[vfsName] = Promise.reject(
                  new Error("Missing required OPFS APIs.")
                );
              }
              return initPromises[vfsName] = apiVersionCheck().then(async function() {
                if (options2.$testThrowPhase2) {
                  throw options2.$testThrowPhase2;
                }
                const thePool = new OpfsSAHPool(options2);
                return thePool.isReady.then(async () => {
                  const poolUtil = new OpfsSAHPoolUtil(thePool);
                  if (sqlite3.oo1) {
                    const oo1 = sqlite3.oo1;
                    const theVfs = thePool.getVfs();
                    const OpfsSAHPoolDb = /* @__PURE__ */ __name(function(...args) {
                      const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                      opt.vfs = theVfs.$zName;
                      oo1.DB.dbCtorHelper.call(this, opt);
                    }, "OpfsSAHPoolDb");
                    OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
                    poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                  }
                  thePool.log("VFS initialized.");
                  return poolUtil;
                }).catch(async (e3) => {
                  await thePool.removeVfs().catch(() => {
                  });
                  throw e3;
                });
              }).catch((err2) => {
                return initPromises[vfsName] = Promise.reject(err2);
              });
            };
          });
          "use strict";
          if ("undefined" !== typeof Module) {
            const SABC = Object.assign(
              /* @__PURE__ */ Object.create(null),
              {
                exports: "undefined" === typeof wasmExports ? Module["asm"] : wasmExports,
                memory: Module.wasmMemory
              },
              globalThis.sqlite3ApiConfig || {}
            );
            globalThis.sqlite3ApiConfig = SABC;
            let sqlite3;
            try {
              sqlite3 = globalThis.sqlite3ApiBootstrap();
            } catch (e3) {
              console.error("sqlite3ApiBootstrap() error:", e3);
              throw e3;
            } finally {
              delete globalThis.sqlite3ApiBootstrap;
              delete globalThis.sqlite3ApiConfig;
            }
            Module.sqlite3 = sqlite3;
          } else {
            console.warn(
              "This is not running in an Emscripten module context, so",
              "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
              "of config info for the WASM environment.",
              "It must be called manually."
            );
          }
        };
        moduleRtn = readyPromise;
        return moduleRtn;
      };
    })();
    toExportForESM = function() {
      const originalInit = sqlite3InitModule;
      if (!originalInit) {
        throw new Error(
          "Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build."
        );
      }
      const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(
        /* @__PURE__ */ Object.create(null),
        {
          moduleScript: globalThis?.document?.currentScript,
          isWorker: "undefined" !== typeof WorkerGlobalScope,
          location: globalThis.location,
          urlParams: globalThis?.location?.href ? new URL(globalThis.location.href).searchParams : new URLSearchParams()
        }
      );
      initModuleState.debugModule = initModuleState.urlParams.has(
        "sqlite3.debugModule"
      ) ? (...args) => console.warn("sqlite3.debugModule:", ...args) : () => {
      };
      if (initModuleState.urlParams.has("sqlite3.dir")) {
        initModuleState.sqlite3Dir = initModuleState.urlParams.get("sqlite3.dir") + "/";
      } else if (initModuleState.moduleScript) {
        const li = initModuleState.moduleScript.src.split("/");
        li.pop();
        initModuleState.sqlite3Dir = li.join("/") + "/";
      }
      globalThis.sqlite3InitModule = /* @__PURE__ */ __name(function ff(...args) {
        return originalInit(...args).then((EmscriptenModule) => {
          EmscriptenModule.runSQLite3PostLoadInit(EmscriptenModule);
          const s3 = EmscriptenModule.sqlite3;
          s3.scriptInfo = initModuleState;
          if (ff.__isUnderTest) s3.__isUnderTest = true;
          const f = s3.asyncPostInit;
          delete s3.asyncPostInit;
          const rv = f();
          return rv;
        }).catch((e3) => {
          console.error("Exception loading sqlite3 module:", e3);
          throw e3;
        });
      }, "ff");
      globalThis.sqlite3InitModule.ready = originalInit.ready;
      if (globalThis.sqlite3InitModuleState.moduleScript) {
        const sim = globalThis.sqlite3InitModuleState;
        let src = sim.moduleScript.src.split("/");
        src.pop();
        sim.scriptDir = src.join("/") + "/";
      }
      initModuleState.debugModule("sqlite3InitModuleState =", initModuleState);
      if (0) {
        console.warn("Replaced sqlite3InitModule()");
        console.warn("globalThis.location.href =", globalThis.location.href);
        if ("undefined" !== typeof document) {
          console.warn(
            "document.currentScript.src =",
            document?.currentScript?.src
          );
        }
      }
      return globalThis.sqlite3InitModule;
    }();
    sqlite3InitModule = toExportForESM;
  }
});
var sqlite3_worker1_promiser_default;
var init_sqlite3_worker1_promiser = __esm({
  "node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.50.4-build1/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs"() {
    "use strict";
    globalThis.sqlite3Worker1Promiser = /* @__PURE__ */ __name(function callee(config2 = callee.defaultConfig) {
      if (1 === arguments.length && "function" === typeof arguments[0]) {
        const f = config2;
        config2 = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);
        config2.onready = f;
      } else {
        config2 = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config2);
      }
      const handlerMap = /* @__PURE__ */ Object.create(null);
      const noop2 = /* @__PURE__ */ __name(function() {
      }, "noop2");
      const err = config2.onerror || noop2;
      const debug3 = config2.debug || noop2;
      const idTypeMap = config2.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);
      const genMsgId = config2.generateMessageId || function(msg) {
        return msg.type + "#" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);
      };
      const toss = /* @__PURE__ */ __name((...args) => {
        throw new Error(args.join(" "));
      }, "toss");
      if (!config2.worker) config2.worker = callee.defaultConfig.worker;
      if ("function" === typeof config2.worker) config2.worker = config2.worker();
      let dbId;
      let promiserFunc;
      config2.worker.onmessage = function(ev) {
        ev = ev.data;
        debug3("worker1.onmessage", ev);
        let msgHandler = handlerMap[ev.messageId];
        if (!msgHandler) {
          if (ev && "sqlite3-api" === ev.type && "worker1-ready" === ev.result) {
            if (config2.onready) config2.onready(promiserFunc);
            return;
          }
          msgHandler = handlerMap[ev.type];
          if (msgHandler && msgHandler.onrow) {
            msgHandler.onrow(ev);
            return;
          }
          if (config2.onunhandled) config2.onunhandled(arguments[0]);
          else err("sqlite3Worker1Promiser() unhandled worker message:", ev);
          return;
        }
        delete handlerMap[ev.messageId];
        switch (ev.type) {
          case "error":
            msgHandler.reject(ev);
            return;
          case "open":
            if (!dbId) dbId = ev.dbId;
            break;
          case "close":
            if (ev.dbId === dbId) dbId = void 0;
            break;
          default:
            break;
        }
        try {
          msgHandler.resolve(ev);
        } catch (e3) {
          msgHandler.reject(e3);
        }
      };
      return promiserFunc = /* @__PURE__ */ __name(function() {
        let msg;
        if (1 === arguments.length) {
          msg = arguments[0];
        } else if (2 === arguments.length) {
          msg = /* @__PURE__ */ Object.create(null);
          msg.type = arguments[0];
          msg.args = arguments[1];
          msg.dbId = msg.args.dbId;
        } else {
          toss("Invalid arguments for sqlite3Worker1Promiser()-created factory.");
        }
        if (!msg.dbId && msg.type !== "open") msg.dbId = dbId;
        msg.messageId = genMsgId(msg);
        msg.departureTime = performance.now();
        const proxy2 = /* @__PURE__ */ Object.create(null);
        proxy2.message = msg;
        let rowCallbackId;
        if ("exec" === msg.type && msg.args) {
          if ("function" === typeof msg.args.callback) {
            rowCallbackId = msg.messageId + ":row";
            proxy2.onrow = msg.args.callback;
            msg.args.callback = rowCallbackId;
            handlerMap[rowCallbackId] = proxy2;
          } else if ("string" === typeof msg.args.callback) {
            toss(
              "exec callback may not be a string when using the Promise interface."
            );
          }
        }
        let p = new Promise(function(resolve2, reject) {
          proxy2.resolve = resolve2;
          proxy2.reject = reject;
          handlerMap[msg.messageId] = proxy2;
          debug3(
            "Posting",
            msg.type,
            "message to Worker dbId=" + (dbId || "default") + ":",
            msg
          );
          config2.worker.postMessage(msg);
        });
        if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);
        return p;
      }, "promiserFunc");
    }, "callee");
    globalThis.sqlite3Worker1Promiser.defaultConfig = {
      worker: /* @__PURE__ */ __name(function() {
        return new Worker(
          new URL("sqlite3-worker1-bundler-friendly.mjs", import.meta.url),
          {
            type: "module"
          }
        );
      }, "worker"),
      onerror: /* @__PURE__ */ __name((...args) => console.error("worker1 promiser error", ...args), "onerror")
    };
    sqlite3Worker1Promiser.v2 = function(config2) {
      let oldFunc;
      if ("function" == typeof config2) {
        oldFunc = config2;
        config2 = {};
      } else if ("function" === typeof config2?.onready) {
        oldFunc = config2.onready;
        delete config2.onready;
      }
      const promiseProxy = /* @__PURE__ */ Object.create(null);
      config2 = Object.assign(config2 || /* @__PURE__ */ Object.create(null), {
        onready: /* @__PURE__ */ __name(async function(func) {
          try {
            if (oldFunc) await oldFunc(func);
            promiseProxy.resolve(func);
          } catch (e3) {
            promiseProxy.reject(e3);
          }
        }, "onready")
      });
      const p = new Promise(function(resolve2, reject) {
        promiseProxy.resolve = resolve2;
        promiseProxy.reject = reject;
      });
      try {
        this.original(config2);
      } catch (e3) {
        promiseProxy.reject(e3);
      }
      return p;
    }.bind({
      original: sqlite3Worker1Promiser
    });
    sqlite3_worker1_promiser_default = sqlite3Worker1Promiser.v2;
  }
});
var sqlite3Worker1Promiser2;
var init_sqlite_wasm = __esm({
  "node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.50.4-build1/node_modules/@sqlite.org/sqlite-wasm/index.mjs"() {
    init_sqlite3_bundler_friendly();
    init_sqlite3_worker1_promiser();
    sqlite3Worker1Promiser2 = globalThis.sqlite3Worker1Promiser;
  }
});
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: /* @__PURE__ */ __name(() => _page, "default")
});
function onDestroy(fn) {
  ssr_context.r.on_destroy(fn);
}
__name(onDestroy, "onDestroy");
function _page($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    const AUTHOR_COLORS = [
      "#0ea5e9",
      "#ec4899",
      "#8b5cf6",
      "#22c55e",
      "#f97316",
      "#facc15",
      "#06b6d4",
      "#14b8a6"
    ];
    function formatTimestamp(value) {
      return new Date(value).toLocaleString();
    }
    __name(formatTimestamp, "formatTimestamp");
    function arrayFromString(value) {
      return Array.from(value);
    }
    __name(arrayFromString, "arrayFromString");
    function mergeAttribution(previous, nextChars, fallbackAuthor) {
      if (previous.length === 0) {
        return nextChars.map((char) => ({ char, author: fallbackAuthor }));
      }
      const prevChars = previous.map((item) => item.char);
      const prevLength = prevChars.length;
      const nextLength = nextChars.length;
      if (prevLength === 0) {
        return nextChars.map((char) => ({ char, author: fallbackAuthor }));
      }
      const dp = Array.from({ length: prevLength + 1 }, () => new Array(nextLength + 1).fill(0));
      for (let i2 = prevLength - 1; i2 >= 0; i2 -= 1) {
        for (let j2 = nextLength - 1; j2 >= 0; j2 -= 1) {
          if (prevChars[i2] === nextChars[j2]) {
            dp[i2][j2] = dp[i2 + 1][j2 + 1] + 1;
          } else {
            dp[i2][j2] = Math.max(dp[i2 + 1][j2], dp[i2][j2 + 1]);
          }
        }
      }
      const result = [];
      let i = 0;
      let j = 0;
      while (i < prevLength && j < nextLength) {
        if (prevChars[i] === nextChars[j]) {
          result.push({ char: nextChars[j], author: previous[i].author });
          i += 1;
          j += 1;
        } else if (dp[i + 1][j] >= dp[i][j + 1]) {
          i += 1;
        } else {
          result.push({ char: nextChars[j], author: fallbackAuthor });
          j += 1;
        }
      }
      while (j < nextLength) {
        result.push({ char: nextChars[j], author: fallbackAuthor });
        j += 1;
      }
      return result;
    }
    __name(mergeAttribution, "mergeAttribution");
    function computeCharAttribution(entries) {
      let attribution = [];
      for (const entry of entries) {
        if (!entry.content) {
          attribution = [];
          continue;
        }
        const chars2 = arrayFromString(entry.content);
        if (attribution.length === 0) {
          attribution = chars2.map((char) => ({ char, author: entry.user }));
          continue;
        }
        attribution = mergeAttribution(attribution, chars2, entry.user);
      }
      return attribution;
    }
    __name(computeCharAttribution, "computeCharAttribution");
    function ensureAttributionMatchesContent(base2, content, fallbackAuthor) {
      const contentChars = arrayFromString(content);
      if (base2.length === 0 && contentChars.length === 0) {
        return [];
      }
      return mergeAttribution(base2, contentChars, fallbackAuthor);
    }
    __name(ensureAttributionMatchesContent, "ensureAttributionMatchesContent");
    function toOverlayLines(attribution, fallbackAuthor) {
      if (attribution.length === 0) {
        return [[{ author: fallbackAuthor, text: "" }]];
      }
      const lines = [];
      let segments = [];
      let current2 = null;
      const flushSegment = /* @__PURE__ */ __name(() => {
        if (current2) {
          segments.push(current2);
          current2 = null;
        }
      }, "flushSegment");
      const flushLine = /* @__PURE__ */ __name((authorForEmpty) => {
        flushSegment();
        if (segments.length === 0) {
          segments.push({ author: authorForEmpty, text: "" });
        }
        lines.push(segments);
        segments = [];
      }, "flushLine");
      for (const { char, author } of attribution) {
        if (char === "\n") {
          flushLine(author);
          continue;
        }
        if (!current2 || current2.author !== author) {
          flushSegment();
          current2 = { author, text: char };
        } else {
          current2.text += char;
        }
      }
      flushLine(attribution.at(-1)?.author ?? fallbackAuthor);
      return lines;
    }
    __name(toOverlayLines, "toOverlayLines");
    let logs = [];
    let connectionStatus = "disconnected";
    let channels = [];
    let currentChannel = null;
    let userName = "";
    let joinAddressInput = "";
    let newChannelName = "";
    let documentContent = "";
    let documentHistory = [];
    let charAttribution = [];
    let authorColors = {};
    let authorColorIndex = 0;
    let historyLength = 0;
    let sliderMax = 0;
    let sliderValue = 0;
    let effectiveHistoryIndex = null;
    let selectedTimelineEntry = null;
    let textareaValue = "";
    let legendEntries = [];
    let fallbackUserName = "anonymous";
    let fallbackAttribution = [];
    let overlayAttribution = [];
    const registerAuthor = /* @__PURE__ */ __name((rawUser) => {
      const user = rawUser?.trim() || "anonymous";
      if (authorColors[user]) {
        return;
      }
      const color = AUTHOR_COLORS[authorColorIndex % AUTHOR_COLORS.length];
      authorColorIndex += 1;
      authorColors = { ...authorColors, [user]: color };
    }, "registerAuthor");
    onDestroy(() => {
    });
    {
      const fallbackUser = userName.trim() || "anonymous";
      if (!documentHistory.length) {
        if (documentContent.length === 0) {
          charAttribution = [];
        } else {
          registerAuthor(fallbackUser);
          charAttribution = ensureAttributionMatchesContent([], documentContent, fallbackUser);
        }
      } else {
        const maxIndex = documentHistory.length - 1;
        const targetIndex = maxIndex;
        const subset = documentHistory.slice(0, targetIndex + 1);
        subset.forEach((entry) => registerAuthor(entry.user));
        const baseAttribution = computeCharAttribution(subset);
        const targetContent = documentContent;
        const finalAttribution = ensureAttributionMatchesContent(baseAttribution, targetContent, fallbackUser);
        {
          registerAuthor(fallbackUser);
        }
        charAttribution = finalAttribution;
      }
    }
    historyLength = documentHistory.length;
    sliderMax = historyLength > 0 ? historyLength - 1 : 0;
    sliderValue = historyLength > 0 ? sliderMax : 0;
    effectiveHistoryIndex = historyLength > 0 ? sliderValue : null;
    selectedTimelineEntry = effectiveHistoryIndex !== null ? documentHistory[effectiveHistoryIndex] : null;
    textareaValue = documentContent;
    selectedTimelineEntry ? `${selectedTimelineEntry.user} \u2022 ${formatTimestamp(selectedTimelineEntry.timestamp)}` : "No commits yet";
    legendEntries = Object.entries(authorColors).sort((a, b) => a[0].localeCompare(b[0]));
    legendEntries.length > 0;
    fallbackUserName = userName.trim() || "anonymous";
    fallbackAttribution = arrayFromString(textareaValue).map((char) => ({ char, author: fallbackUserName }));
    overlayAttribution = charAttribution.length > 0 ? charAttribution : fallbackAttribution;
    toOverlayLines(overlayAttribution, fallbackUserName);
    $$renderer2.push(`<div class="app"><header><h1>CRDT Channel Chat</h1> <p>Real-time collaborative messaging with CRDT conflict resolution</p></header> <main><div class="chat-layout"><div class="channels-sidebar"><div class="channel-controls"><input type="text" placeholder="Your name"${attr("value", userName)} class="user-input"/> <div class="create-channel"><input type="text" placeholder="New channel name"${attr("value", newChannelName)} class="channel-input"/> <button class="create-button">+</button></div> <div class="join-channel"><input type="text" placeholder="Channel address"${attr("value", joinAddressInput)} class="channel-input"/> <button class="join-button">Join</button></div></div> <div class="channels-list"><h3>Channels (${escape_html(channels.length)})</h3> <!--[-->`);
    const each_array = ensure_array_like(channels);
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let channel2 = each_array[$$index];
      $$renderer2.push(`<div${attr_class("channel-item", void 0, { "active": currentChannel?.id === channel2.id })} role="button" tabindex="0"><div class="channel-name">#${escape_html(channel2.name)}</div> <div class="channel-meta">${escape_html(new Date(channel2.lastModified).toLocaleDateString())}</div> <div class="channel-address"><input type="text" readonly${attr("value", channel2.docId)}/> <button>Copy</button></div></div>`);
    }
    $$renderer2.push(`<!--]--></div></div> <div class="messages-area">`);
    {
      $$renderer2.push("<!--[!-->");
      $$renderer2.push(`<div class="welcome-screen"><h2>Welcome to CRDT Chat!</h2> <p>Select a channel from the sidebar to start chatting, or create a new one.</p> <div class="status"><span${attr_class(`status-indicator ${connectionStatus}`)}>Status: ${escape_html(connectionStatus)}</span> <span${attr_class(`status-indicator ${"error"}`)}>SQLite: ${escape_html("Initializing...")}</span></div></div>`);
    }
    $$renderer2.push(`<!--]--></div></div> <div class="logs-container"><h3>Activity Log</h3> <div class="logs">`);
    if (logs.length === 0) {
      $$renderer2.push("<!--[-->");
      $$renderer2.push(`<p class="empty-logs">Activity will appear here</p>`);
    } else {
      $$renderer2.push("<!--[!-->");
      $$renderer2.push(`<!--[-->`);
      const each_array_5 = ensure_array_like(logs);
      for (let index4 = 0, $$length = each_array_5.length; index4 < $$length; index4++) {
        let log3 = each_array_5[index4];
        $$renderer2.push(`<div class="log-entry">${escape_html(log3)}</div>`);
      }
      $$renderer2.push(`<!--]-->`);
    }
    $$renderer2.push(`<!--]--></div></div></main></div>`);
  });
}
__name(_page, "_page");
var init_page_svelte = __esm({
  async ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_chunks();
    init_context();
    await init_dist();
    init_sqlite_wasm();
  }
});
var __exports3 = {};
__export(__exports3, {
  component: /* @__PURE__ */ __name(() => component3, "component"),
  fonts: /* @__PURE__ */ __name(() => fonts3, "fonts"),
  imports: /* @__PURE__ */ __name(() => imports3, "imports"),
  index: /* @__PURE__ */ __name(() => index3, "index"),
  stylesheets: /* @__PURE__ */ __name(() => stylesheets3, "stylesheets"),
  universal: /* @__PURE__ */ __name(() => universal, "universal"),
  universal_id: /* @__PURE__ */ __name(() => universal_id, "universal_id")
});
var index3;
var component_cache3;
var component3;
var universal;
var universal_id;
var imports3;
var stylesheets3;
var fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    index3 = 2;
    component3 = /* @__PURE__ */ __name(async () => component_cache3 ??= (await init_page_svelte().then(() => page_svelte_exports)).default, "component3");
    universal = {
      "ssr": false
    };
    universal_id = "src/routes/+page.ts";
    imports3 = ["_app/immutable/nodes/2.qf5vTKH-.js", "_app/immutable/chunks/NZTpNUN0.js", "_app/immutable/chunks/J393zdJQ.js", "_app/immutable/chunks/D4DQbwrw.js", "_app/immutable/chunks/BuNyUiBZ.js", "_app/immutable/chunks/8HJfsTjg.js", "_app/immutable/chunks/BnGH0CUP.js"];
    stylesheets3 = [];
    fonts3 = [];
  }
});
var BROWSER = false;
var base = "";
var assets = base;
var app_dir = "_app";
var relative = true;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
__name(override, "override");
function reset() {
  base = initial.base;
  assets = initial.assets;
}
__name(reset, "reset");
init_internal();
var true_default = true;
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");
var text_encoder = new TextEncoder();
var text_decoder = new TextDecoder();
function error3(status, body2) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 400 || status > 599)) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
__name(error3, "error");
function json(data, init2) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", text_encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
__name(json, "json");
function text(body2, init2) {
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    const encoded = text_encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
__name(text, "text");
init_internal();
init_server();
init_utils();
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  static {
    __name(this, "DevalueError");
  }
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
__name(is_primitive, "is_primitive");
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
__name(is_plain_object, "is_plain_object");
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
__name(get_type, "get_type");
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
__name(get_escaped_char, "get_escaped_char");
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
__name(stringify_string, "stringify_string");
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
__name(enumerable_symbols, "enumerable_symbols");
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
__name(stringify_key, "stringify_key");
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
__name(encode64, "encode64");
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }
  return arraybuffer;
}
__name(decode64, "decode64");
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i = 0; i < data.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
__name(asciiToBinary, "asciiToBinary");
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}
__name(binaryToAscii, "binaryToAscii");
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
__name(parse, "parse");
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate2(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate2(index4, standalone = false) {
    if (index4 === UNDEFINED) return void 0;
    if (index4 === NAN) return NaN;
    if (index4 === POSITIVE_INFINITY) return Infinity;
    if (index4 === NEGATIVE_INFINITY) return -Infinity;
    if (index4 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index4 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index4 in hydrated) return hydrated[index4];
    const value = values[index4];
    if (!value || typeof value !== "object") {
      hydrated[index4] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          return hydrated[index4] = reviver(hydrate2(value[1]));
        }
        switch (type) {
          case "Date":
            hydrated[index4] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index4] = set2;
            for (let i = 1; i < value.length; i += 1) {
              set2.add(hydrate2(value[i]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index4] = map;
            for (let i = 1; i < value.length; i += 2) {
              map.set(hydrate2(value[i]), hydrate2(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated[index4] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index4] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index4] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index4] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate2(value[i + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate2(value[1]));
            hydrated[index4] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index4] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index4] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index4] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index4] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index4] = array2;
        for (let i = 0; i < value.length; i += 1) {
          const n2 = value[i];
          if (n2 === HOLE) continue;
          array2[i] = hydrate2(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index4] = object;
      for (const key2 in value) {
        if (key2 === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n2 = value[key2];
        object[key2] = hydrate2(n2);
      }
    }
    return hydrated[index4];
  }
  __name(hydrate2, "hydrate2");
  return hydrate2(0);
}
__name(unflatten, "unflatten");
function stringify$1(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  if (reducers) {
    for (const key2 of Object.getOwnPropertyNames(reducers)) {
      custom.push({ key: key2, fn: reducers[key2] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index22 = p++;
    indexes.set(thing, index22);
    for (const { key: key2, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index22] = `["${key2}",${flatten(value2)}]`;
        return index22;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source: source2, flags: flags2 } = thing;
          str = flags2 ? `["RegExp",${stringify_string(source2)},"${flags2}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a = thing.byteOffset;
          const b = a + thing.byteLength;
          if (a > 0 || b !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a / m},${b / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(stringify_key(key2));
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key2));
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index22] = str;
    return index22;
  }
  __name(flatten, "flatten");
  const index4 = flatten(value);
  if (index4 < 0) return `${index4}`;
  return `[${stringified.join(",")}]`;
}
__name(stringify$1, "stringify$1");
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
__name(stringify_primitive, "stringify_primitive");
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function stringify(data, transport) {
  const encoders = Object.fromEntries(Object.entries(transport).map(([k, v2]) => [k, v2.encode]));
  return stringify$1(data, encoders);
}
__name(stringify, "stringify");
function parse_remote_arg(string, transport) {
  if (!string) return void 0;
  const json_string = text_decoder2.decode(
    // no need to add back `=` characters, atob can handle it
    base64_decode(string.replaceAll("-", "+").replaceAll("_", "/"))
  );
  const decoders = Object.fromEntries(Object.entries(transport).map(([k, v2]) => [k, v2.decode]));
  return parse(json_string, decoders);
}
__name(parse_remote_arg, "parse_remote_arg");
function create_remote_cache_key(id, payload) {
  return id + "/" + payload;
}
__name(create_remote_cache_key, "create_remote_cache_key");
init_exports();
init_utils();
init_chunks();
init_utils2();
init_equality();
init_context();
var public_env = {};
function set_private_env(environment) {
}
__name(set_private_env, "set_private_env");
function set_public_env(environment) {
  public_env = environment;
}
__name(set_public_env, "set_public_env");
function effect_update_depth_exceeded() {
  {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function hydration_failed() {
  {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
__name(hydration_failed, "hydration_failed");
function state_descriptors_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
__name(state_descriptors_fixed, "state_descriptors_fixed");
function state_prototype_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
__name(state_prototype_fixed, "state_prototype_fixed");
function state_unsafe_mutation() {
  {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
function svelte_boundary_reset_onerror() {
  {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
__name(svelte_boundary_reset_onerror, "svelte_boundary_reset_onerror");
function hydration_mismatch(location) {
  {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
__name(hydration_mismatch, "hydration_mismatch");
function svelte_boundary_reset_noop() {
  {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
__name(svelte_boundary_reset_noop, "svelte_boundary_reset_noop");
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
__name(set_hydrating, "set_hydrating");
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(hydrate_node)
  );
}
__name(hydrate_next, "hydrate_next");
function next(count3 = 1) {
  if (hydrating) {
    var i = count3;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
__name(next, "next");
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
__name(skip_nodes, "skip_nodes");
var tracing_mode_flag = false;
var component_context = null;
function set_component_context(context22) {
  component_context = context22;
}
__name(set_component_context, "set_component_context");
function push2(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    s: props,
    x: null,
    l: null
  };
}
__name(push2, "push2");
function pop2(component4) {
  var context22 = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context22.e;
  if (effects !== null) {
    context22.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  component_context = context22.p;
  return (
    /** @type {T} */
    {}
  );
}
__name(pop2, "pop2");
function is_runes() {
  return true;
}
__name(is_runes, "is_runes");
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
__name(run_micro_tasks, "run_micro_tasks");
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
__name(queue_micro_task, "queue_micro_task");
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
__name(flush_tasks, "flush_tasks");
var adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error22) {
  var effect = active_effect;
  if (effect === null) {
    active_reaction.f |= ERROR_VALUE;
    return error22;
  }
  if ((effect.f & EFFECT_RAN) === 0) {
    if ((effect.f & BOUNDARY_EFFECT) === 0) {
      if (!effect.parent && error22 instanceof Error) {
        apply_adjustments(error22);
      }
      throw error22;
    }
    effect.b.error(error22);
  } else {
    invoke_error_boundary(error22, effect);
  }
}
__name(handle_error, "handle_error");
function invoke_error_boundary(error22, effect) {
  while (effect !== null) {
    if ((effect.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect.b.error(error22);
        return;
      } catch (e3) {
        error22 = e3;
      }
    }
    effect = effect.parent;
  }
  if (error22 instanceof Error) {
    apply_adjustments(error22);
  }
  throw error22;
}
__name(invoke_error_boundary, "invoke_error_boundary");
function apply_adjustments(error22) {
  const adjusted = adjustments.get(error22);
  if (adjusted) {
    define_property(error22, "message", {
      value: adjusted.message
    });
    define_property(error22, "stack", {
      value: adjusted.stack
    });
  }
}
__name(apply_adjustments, "apply_adjustments");
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var effect_pending_updates = /* @__PURE__ */ new Set();
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var Batch = class _Batch {
  static {
    __name(this, "_Batch");
  }
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  #previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #callbacks = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #pending = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #deferred = null;
  /**
   * Async effects inside a newly-created `<svelte:boundary>`
   * — these do not prevent the batch from committing
   * @type {Effect[]}
   */
  #boundary_async_effects = [];
  /**
   * Template effects and `$effect.pre` effects, which run when
   * a batch is committed
   * @type {Effect[]}
   */
  #render_effects = [];
  /**
   * The same as `#render_effects`, but for `$effect` (which runs after)
   * @type {Effect[]}
   */
  #effects = [];
  /**
   * Block effects, which may need to re-run on subsequent flushes
   * in order to update internal sources (e.g. each block items)
   * @type {Effect[]}
   */
  #block_effects = [];
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #dirty_effects = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #maybe_dirty_effects = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed — we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    var revert = _Batch.apply(this);
    for (const root2 of root_effects) {
      this.#traverse_effect_tree(root2);
    }
    if (this.#pending === 0) {
      this.#commit();
      var render_effects = this.#render_effects;
      var effects = this.#effects;
      this.#render_effects = [];
      this.#effects = [];
      this.#block_effects = [];
      current_batch = null;
      flush_queued_effects(render_effects);
      flush_queued_effects(effects);
      this.#deferred?.resolve();
    } else {
      this.#defer_effects(this.#render_effects);
      this.#defer_effects(this.#effects);
      this.#defer_effects(this.#block_effects);
    }
    revert();
    for (const effect of this.#boundary_async_effects) {
      update_effect(effect);
    }
    this.#boundary_async_effects = [];
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   */
  #traverse_effect_tree(root2) {
    root2.f ^= CLEAN;
    var effect = root2.first;
    while (effect !== null) {
      var flags2 = effect.f;
      var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
      var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
      var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect);
      if (!skip && effect.fn !== null) {
        if (is_branch) {
          effect.f ^= CLEAN;
        } else if ((flags2 & EFFECT) !== 0) {
          this.#effects.push(effect);
        } else if ((flags2 & CLEAN) === 0) {
          if ((flags2 & ASYNC) !== 0 && effect.b?.is_pending()) {
            this.#boundary_async_effects.push(effect);
          } else if (is_dirty(effect)) {
            if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect);
            update_effect(effect);
          }
        }
        var child = effect.first;
        if (child !== null) {
          effect = child;
          continue;
        }
      }
      var parent = effect.parent;
      effect = effect.next;
      while (effect === null && parent !== null) {
        effect = parent.next;
        parent = parent.parent;
      }
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #defer_effects(effects) {
    for (const e3 of effects) {
      const target = (e3.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
      target.push(e3);
      set_signal_status(e3, CLEAN);
    }
    effects.length = 0;
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!this.#previous.has(source2)) {
      this.#previous.set(source2, value);
    }
    this.current.set(source2, source2.v);
  }
  activate() {
    current_batch = this;
  }
  deactivate() {
    current_batch = null;
  }
  flush() {
    if (queued_root_effects.length > 0) {
      this.activate();
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (this.#pending === 0) {
      this.#commit();
    }
    this.deactivate();
    for (const update of effect_pending_updates) {
      effect_pending_updates.delete(update);
      update();
      if (current_batch !== null) {
        break;
      }
    }
  }
  /**
   * Append and remove branches to/from the DOM
   */
  #commit() {
    for (const fn of this.#callbacks) {
      fn();
    }
    this.#callbacks.clear();
    if (batches.size > 1) {
      this.#previous.clear();
      let is_earlier = true;
      for (const batch of batches) {
        if (batch === this) {
          is_earlier = false;
          continue;
        }
        for (const [source2, value] of this.current) {
          if (batch.current.has(source2)) {
            if (is_earlier) {
              batch.current.set(source2, value);
            } else {
              continue;
            }
          }
          mark_effects(source2);
        }
        if (queued_root_effects.length > 0) {
          current_batch = batch;
          const revert = _Batch.apply(batch);
          for (const root2 of queued_root_effects) {
            batch.#traverse_effect_tree(root2);
          }
          queued_root_effects = [];
          revert();
        }
      }
      current_batch = null;
    }
    batches.delete(this);
  }
  increment() {
    this.#pending += 1;
  }
  decrement() {
    this.#pending -= 1;
    for (const e3 of this.#dirty_effects) {
      set_signal_status(e3, DIRTY);
      schedule_effect(e3);
    }
    for (const e3 of this.#maybe_dirty_effects) {
      set_signal_status(e3, MAYBE_DIRTY);
      schedule_effect(e3);
    }
    this.flush();
  }
  /** @param {() => void} fn */
  add_callback(fn) {
    this.#callbacks.add(fn);
  }
  settled() {
    return (this.#deferred ??= deferred()).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  /**
   * @param {Batch} current_batch
   */
  static apply(current_batch2) {
    {
      return noop;
    }
  }
};
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) ;
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
__name(flushSync, "flushSync");
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        var updates, entry;
        if (BROWSER) ;
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
__name(flush_effects, "flush_effects");
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error22) {
    invoke_error_boundary(error22, last_scheduled_effect);
  }
}
__name(infinite_loop_guard, "infinite_loop_guard");
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect = effects[i++];
    if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
      eager_block_effects = [];
      update_effect(effect);
      if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
        if (effect.teardown === null && effect.ac === null) {
          unlink_effect(effect);
        } else {
          effect.fn = null;
        }
      }
      if (eager_block_effects?.length > 0) {
        old_values.clear();
        for (const e3 of eager_block_effects) {
          update_effect(e3);
        }
        eager_block_effects = [];
      }
    }
  }
  eager_block_effects = null;
}
__name(flush_queued_effects, "flush_queued_effects");
function mark_effects(value) {
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_effects, "mark_effects");
function schedule_effect(signal) {
  var effect = last_scheduled_effect = signal;
  while (effect.parent !== null) {
    effect = effect.parent;
    var flags2 = effect.f;
    if (is_flushing && effect === active_effect && (flags2 & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect);
}
__name(schedule_effect, "schedule_effect");
function createSubscriber(start) {
  let subscribers = 0;
  let version2 = source(0);
  let stop;
  return () => {
    if (effect_tracking()) {
      get(version2);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version2)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version2);
            }
          });
        };
      });
    }
  };
}
__name(createSubscriber, "createSubscriber");
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
__name(boundary, "boundary");
var Boundary = class {
  static {
    __name(this, "Boundary");
  }
  /** @type {Boundary | null} */
  parent;
  #pending = false;
  /** @type {TemplateNode} */
  #anchor;
  /** @type {TemplateNode | null} */
  #hydrate_open = hydrating ? hydrate_node : null;
  /** @type {BoundaryProps} */
  #props;
  /** @type {((anchor: Node) => void)} */
  #children;
  /** @type {Effect} */
  #effect;
  /** @type {Effect | null} */
  #main_effect = null;
  /** @type {Effect | null} */
  #pending_effect = null;
  /** @type {Effect | null} */
  #failed_effect = null;
  /** @type {DocumentFragment | null} */
  #offscreen_fragment = null;
  #local_pending_count = 0;
  #pending_count = 0;
  #is_creating_fallback = false;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #effect_pending = null;
  #effect_pending_update = /* @__PURE__ */ __name(() => {
    if (this.#effect_pending) {
      internal_set(this.#effect_pending, this.#local_pending_count);
    }
  }, "#effect_pending_update");
  #effect_pending_subscriber = createSubscriber(() => {
    this.#effect_pending = source(this.#local_pending_count);
    return () => {
      this.#effect_pending = null;
    };
  });
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    this.#anchor = node;
    this.#props = props;
    this.#children = children;
    this.parent = /** @type {Effect} */
    active_effect.b;
    this.#pending = !!this.#props.pending;
    this.#effect = block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment = this.#hydrate_open;
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          this.#hydrate_pending_content();
        } else {
          this.#hydrate_resolved_content();
        }
      } else {
        try {
          this.#main_effect = branch(() => children(this.#anchor));
        } catch (error22) {
          this.error(error22);
        }
        if (this.#pending_count > 0) {
          this.#show_pending_snippet();
        } else {
          this.#pending = false;
        }
      }
    }, flags);
    if (hydrating) {
      this.#anchor = hydrate_node;
    }
  }
  #hydrate_resolved_content() {
    try {
      this.#main_effect = branch(() => this.#children(this.#anchor));
    } catch (error22) {
      this.error(error22);
    }
    this.#pending = false;
  }
  #hydrate_pending_content() {
    const pending = this.#props.pending;
    if (!pending) {
      return;
    }
    this.#pending_effect = branch(() => pending(this.#anchor));
    Batch.enqueue(() => {
      this.#main_effect = this.#run(() => {
        Batch.ensure();
        return branch(() => this.#children(this.#anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        pause_effect(
          /** @type {Effect} */
          this.#pending_effect,
          () => {
            this.#pending_effect = null;
          }
        );
        this.#pending = false;
      }
    });
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#pending || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#props.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #run(fn) {
    var previous_effect = active_effect;
    var previous_reaction = active_reaction;
    var previous_ctx = component_context;
    set_active_effect(this.#effect);
    set_active_reaction(this.#effect);
    set_component_context(this.#effect.ctx);
    try {
      return fn();
    } catch (e3) {
      handle_error(e3);
      return null;
    } finally {
      set_active_effect(previous_effect);
      set_active_reaction(previous_reaction);
      set_component_context(previous_ctx);
    }
  }
  #show_pending_snippet() {
    const pending = (
      /** @type {(anchor: Node) => void} */
      this.#props.pending
    );
    if (this.#main_effect !== null) {
      this.#offscreen_fragment = document.createDocumentFragment();
      move_effect(this.#main_effect, this.#offscreen_fragment);
    }
    if (this.#pending_effect === null) {
      this.#pending_effect = branch(() => pending(this.#anchor));
    }
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #update_pending_count(d) {
    if (!this.has_pending_snippet()) {
      if (this.parent) {
        this.parent.#update_pending_count(d);
      }
      return;
    }
    this.#pending_count += d;
    if (this.#pending_count === 0) {
      this.#pending = false;
      if (this.#pending_effect) {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
      }
      if (this.#offscreen_fragment) {
        this.#anchor.before(this.#offscreen_fragment);
        this.#offscreen_fragment = null;
      }
      queue_micro_task(() => {
        Batch.ensure().flush();
      });
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    this.#update_pending_count(d);
    this.#local_pending_count += d;
    effect_pending_updates.add(this.#effect_pending_update);
  }
  get_effect_pending() {
    this.#effect_pending_subscriber();
    return get(
      /** @type {Source<number>} */
      this.#effect_pending
    );
  }
  /** @param {unknown} error */
  error(error22) {
    var onerror = this.#props.onerror;
    let failed = this.#props.failed;
    if (this.#is_creating_fallback || !onerror && !failed) {
      throw error22;
    }
    if (this.#main_effect) {
      destroy_effect(this.#main_effect);
      this.#main_effect = null;
    }
    if (this.#pending_effect) {
      destroy_effect(this.#pending_effect);
      this.#pending_effect = null;
    }
    if (this.#failed_effect) {
      destroy_effect(this.#failed_effect);
      this.#failed_effect = null;
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        this.#hydrate_open
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = /* @__PURE__ */ __name(() => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      this.#local_pending_count = 0;
      if (this.#failed_effect !== null) {
        pause_effect(this.#failed_effect, () => {
          this.#failed_effect = null;
        });
      }
      this.#pending = this.has_pending_snippet();
      this.#main_effect = this.#run(() => {
        this.#is_creating_fallback = false;
        return branch(() => this.#children(this.#anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        this.#pending = false;
      }
    }, "reset2");
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error22, reset2);
      calling_on_error = false;
    } catch (error222) {
      invoke_error_boundary(error222, this.#effect && this.#effect.parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        this.#failed_effect = this.#run(() => {
          this.#is_creating_fallback = true;
          try {
            return branch(() => {
              failed(
                this.#anchor,
                () => error22,
                () => reset2
              );
            });
          } catch (error222) {
            invoke_error_boundary(
              error222,
              /** @type {Effect} */
              this.#effect.parent
            );
            return null;
          } finally {
            this.#is_creating_fallback = false;
          }
        });
      });
    }
  }
};
function move_effect(effect, fragment) {
  var node = effect.nodes_start;
  var end = effect.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
__name(move_effect, "move_effect");
function destroy_derived_effects(derived) {
  var effects = derived.effects;
  if (effects !== null) {
    derived.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
__name(destroy_derived_effects, "destroy_derived_effects");
function get_derived_parent_effect(derived) {
  var parent = derived.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
__name(get_derived_parent_effect, "get_derived_parent_effect");
function execute_derived(derived) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived));
  {
    try {
      destroy_derived_effects(derived);
      value = update_reaction(derived);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
__name(execute_derived, "execute_derived");
function update_derived(derived) {
  var value = execute_derived(derived);
  if (!derived.equals(value)) {
    derived.v = value;
    derived.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  {
    var status = (skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived, status);
  }
}
__name(update_derived, "update_derived");
var old_values = /* @__PURE__ */ new Map();
function source(v2, stack) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return signal;
}
__name(source, "source");
// @__NO_SIDE_EFFECTS__
function state(v2, stack) {
  const s3 = source(v2);
  push_reaction_value(s3);
  return s3;
}
__name(state, "state");
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable2 = false, trackable = true) {
  const s3 = source(initial_value);
  if (!immutable2) {
    s3.equals = safe_equals;
  }
  return s3;
}
__name(mutable_source, "mutable_source");
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  return internal_set(source2, new_value);
}
__name(set, "set");
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
  }
  return value;
}
__name(internal_set, "internal_set");
function increment(source2) {
  set(source2, source2.v + 1);
}
__name(increment, "increment");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      mark_reactions(
        /** @type {Derived} */
        reaction,
        MAYBE_DIRTY
      );
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.push(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_reactions, "mark_reactions");
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version2 = /* @__PURE__ */ state(0);
  var parent_version = update_version;
  var with_parent = /* @__PURE__ */ __name((fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version22 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version22);
    return result;
  }, "with_parent");
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value.length
    ));
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          s3 = with_parent(() => {
            var s22 = /* @__PURE__ */ state(descriptor.value);
            sources.set(prop, s22);
            return s22;
          });
        } else {
          set(s3, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop) {
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          if (prop in target) {
            const s22 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
            sources.set(prop, s22);
            increment(version2);
          }
        } else {
          set(s3, UNINITIALIZED);
          increment(version2);
        }
        return true;
      },
      get(target, prop, receiver) {
        if (prop === STATE_SYMBOL) {
          return value;
        }
        var s3 = sources.get(prop);
        var exists = prop in target;
        if (s3 === void 0 && (!exists || get_descriptor(target, prop)?.writable)) {
          s3 = with_parent(() => {
            var p = proxy(exists ? target[prop] : UNINITIALIZED);
            var s22 = /* @__PURE__ */ state(p);
            return s22;
          });
          sources.set(prop, s3);
        }
        if (s3 !== void 0) {
          var v2 = get(s3);
          return v2 === UNINITIALIZED ? void 0 : v2;
        }
        return Reflect.get(target, prop, receiver);
      },
      getOwnPropertyDescriptor(target, prop) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor && "value" in descriptor) {
          var s3 = sources.get(prop);
          if (s3) descriptor.value = get(s3);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop) {
        if (prop === STATE_SYMBOL) {
          return true;
        }
        var s3 = sources.get(prop);
        var has = s3 !== void 0 && s3.v !== UNINITIALIZED || Reflect.has(target, prop);
        if (s3 !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
          if (s3 === void 0) {
            s3 = with_parent(() => {
              var p = has ? proxy(target[prop]) : UNINITIALIZED;
              var s22 = /* @__PURE__ */ state(p);
              return s22;
            });
            sources.set(prop, s3);
          }
          var value2 = get(s3);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop, value2, receiver) {
        var s3 = sources.get(prop);
        var has = prop in target;
        if (is_proxied_array && prop === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s3.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
              sources.set(i + "", other_s);
            }
          }
        }
        if (s3 === void 0) {
          if (!has || get_descriptor(target, prop)?.writable) {
            s3 = with_parent(() => /* @__PURE__ */ state(void 0));
            set(s3, proxy(value2));
            sources.set(prop, s3);
          }
        } else {
          has = s3.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s3, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n2 = Number(prop);
            if (Number.isInteger(n2) && n2 >= ls.v) {
              set(ls, n2 + 1);
            }
          }
          increment(version2);
        }
        return true;
      },
      ownKeys(target) {
        get(version2);
        var own_keys = Reflect.ownKeys(target).filter((key22) => {
          var source3 = sources.get(key22);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
__name(proxy, "proxy");
var $window;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
}
__name(init_operations, "init_operations");
function create_text(value = "") {
  return document.createTextNode(value);
}
__name(create_text, "create_text");
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
__name(get_first_child, "get_first_child");
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
__name(get_next_sibling, "get_next_sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(without_reactive_context, "without_reactive_context");
function push_effect(effect, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect;
  } else {
    parent_last.next = effect;
    effect.prev = parent_last;
    parent_effect.last = effect;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn, sync, push22 = true) {
  var parent = active_effect;
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (sync) {
    try {
      update_effect(effect);
      effect.f |= EFFECT_RAN;
    } catch (e22) {
      destroy_effect(effect);
      throw e22;
    }
  } else if (fn !== null) {
    schedule_effect(effect);
  }
  if (push22) {
    var e3 = effect;
    if (sync && e3.deps === null && e3.teardown === null && e3.nodes_start === null && e3.first === e3.last && // either `null`, or a singular child
    (e3.f & EFFECT_PRESERVED) === 0) {
      e3 = e3.first;
    }
    if (e3 !== null) {
      e3.parent = parent;
      if (parent !== null) {
        push_effect(e3, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
        var derived = (
          /** @type {Derived} */
          active_reaction
        );
        (derived.effects ??= []).push(e3);
      }
    }
  }
  return effect;
}
__name(create_effect, "create_effect");
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
__name(effect_tracking, "effect_tracking");
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
__name(create_user_effect, "create_user_effect");
function component_root(fn) {
  Batch.ensure();
  const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options2 = {}) => {
    return new Promise((fulfil) => {
      if (options2.outro) {
        pause_effect(effect, () => {
          destroy_effect(effect);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect);
        fulfil(void 0);
      }
    });
  };
}
__name(component_root, "component_root");
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
__name(render_effect, "render_effect");
function block(fn, flags2 = 0) {
  var effect = create_effect(BLOCK_EFFECT | flags2, fn, true);
  return effect;
}
__name(block, "block");
function branch(fn, push22 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push22);
}
__name(branch, "branch");
function execute_effect_teardown(effect) {
  var teardown = effect.teardown;
  if (teardown !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_children(signal, remove_dom = false) {
  var effect = signal.first;
  signal.first = signal.last = null;
  while (effect !== null) {
    const controller2 = effect.ac;
    if (controller2 !== null) {
      without_reactive_context(() => {
        controller2.abort(STALE_REACTION);
      });
    }
    var next2 = effect.next;
    if ((effect.f & ROOT_EFFECT) !== 0) {
      effect.parent = null;
    } else {
      destroy_effect(effect, remove_dom);
    }
    effect = next2;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect = signal.first;
  while (effect !== null) {
    var next2 = effect.next;
    if ((effect.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect);
    }
    effect = next2;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null && effect.nodes_end !== null) {
    remove_effect_dom(
      effect.nodes_start,
      /** @type {TemplateNode} */
      effect.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect, remove_dom && !removed);
  remove_reactions(effect, 0);
  set_signal_status(effect, DESTROYED);
  var transitions = effect.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect);
  var parent = effect.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect);
  }
  effect.next = effect.prev = effect.teardown = effect.ctx = effect.deps = effect.fn = effect.nodes_start = effect.nodes_end = effect.ac = null;
}
__name(destroy_effect, "destroy_effect");
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
__name(remove_effect_dom, "remove_effect_dom");
function unlink_effect(effect) {
  var parent = effect.parent;
  var prev = effect.prev;
  var next2 = effect.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect) parent.first = next2;
    if (parent.last === effect) parent.last = prev;
  }
}
__name(unlink_effect, "unlink_effect");
function pause_effect(effect, callback) {
  var transitions = [];
  pause_children(effect, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect);
    if (callback) callback();
  });
}
__name(pause_effect, "pause_effect");
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = /* @__PURE__ */ __name(() => --remaining || fn(), "check");
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn();
  }
}
__name(run_out_transitions, "run_out_transitions");
function pause_children(effect, transitions, local) {
  if ((effect.f & INERT) !== 0) return;
  effect.f ^= INERT;
  if (effect.transitions !== null) {
    for (const transition of effect.transitions) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child = effect.first;
  while (child !== null) {
    var sibling = child.next;
    var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
    pause_children(child, transitions, transparent ? local : false);
    child = sibling;
  }
}
__name(pause_children, "pause_children");
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
__name(set_is_updating_effect, "set_is_updating_effect");
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
__name(set_is_destroying_effect, "set_is_destroying_effect");
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
var active_effect = null;
function set_active_effect(effect) {
  active_effect = effect;
}
__name(set_active_effect, "set_active_effect");
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && true) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
__name(push_reaction_value, "push_reaction_value");
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
__name(set_untracked_writes, "set_untracked_writes");
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
__name(set_update_version, "set_update_version");
var skip_reaction = false;
function increment_write_version() {
  return ++write_version;
}
__name(increment_write_version, "increment_write_version");
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags2 & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags2 & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if ((is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0)) {
        var derived = (
          /** @type {Derived} */
          reaction
        );
        var parent = derived.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !dependency?.reactions?.includes(derived)) {
            (dependency.reactions ??= []).push(derived);
          }
        }
        if (is_disconnected) {
          derived.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(is_dirty, "is_dirty");
function schedule_possible_effect_self_invalidation(signal, effect, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect,
        false
      );
    } else if (effect === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(schedule_possible_effect_self_invalidation, "schedule_possible_effect_self_invalidation");
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags2 & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (flags2 & DERIVED) !== 0 && /** @type {import('#client').Derived} */
      reaction.reactions !== null) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error22) {
    return handle_error(error22);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index4 = index_of.call(reactions, signal);
    if (index4 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index4] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect) {
  var flags2 = effect.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect;
  is_updating_effect = true;
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect);
    } else {
      destroy_effect_children(effect);
    }
    execute_effect_teardown(effect);
    var teardown = update_reaction(effect);
    effect.teardown = typeof teardown === "function" ? teardown : null;
    effect.wv = write_version;
    var dep;
    if (BROWSER && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
  }
}
__name(update_effect, "update_effect");
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived = (
      /** @type {Derived} */
      signal
    );
    var parent = derived.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived.f ^= UNOWNED;
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived = /** @type {Derived} */
      signal;
      var value = derived.v;
      if ((derived.f & CLEAN) === 0 && derived.reactions !== null || depends_on_old_values(derived)) {
        value = execute_derived(derived);
      }
      old_values.set(derived, value);
      return value;
    }
  } else if (is_derived) {
    derived = /** @type {Derived} */
    signal;
    if (is_dirty(derived)) {
      update_derived(derived);
    }
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
__name(get, "get");
function depends_on_old_values(derived) {
  if (derived.v === UNINITIALIZED) return true;
  if (derived.deps === null) return false;
  for (const dep of derived.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
__name(depends_on_old_values, "depends_on_old_values");
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
__name(untrack, "untrack");
var STATUS_MASK = -7169;
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var last_propagated_event = null;
function handle_event_propagation(event) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event.type;
  var path = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event.target
  );
  last_propagated_event = event;
  var path_idx = 0;
  var handled_at = last_propagated_event === event && event.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event.target;
  if (current_target === handler_element) return;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event.target === current_target)) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event, ...data]);
          } else {
            delegated.call(current_target, event);
          }
        }
      } catch (error22) {
        if (throw_error) {
          other_errors.push(error22);
        } else {
          throw_error = error22;
        }
      }
      if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error22 of other_errors) {
        queueMicrotask(() => {
          throw error22;
        });
      }
      throw throw_error;
    }
  } finally {
    event.__root = handler_element;
    delete event.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function assign_nodes(start, end) {
  var effect = (
    /** @type {Effect} */
    active_effect
  );
  if (effect.nodes_start === null) {
    effect.nodes_start = start;
    effect.nodes_end = end;
  }
}
__name(assign_nodes, "assign_nodes");
function mount(component4, options2) {
  return _mount(component4, options2);
}
__name(mount, "mount");
function hydrate(component4, options2) {
  init_operations();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component4, { ...options2, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error22) {
    if (error22 instanceof Error && error22.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error22;
    }
    if (error22 !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error22);
    }
    if (options2.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component4, options2);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context: context22, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component4 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: /* @__PURE__ */ __name(() => {
        }, "pending")
      },
      (anchor_node2) => {
        if (context22) {
          push2({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context22;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        component4 = Component(anchor_node2, props) || {};
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context22) {
          pop2();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component4, unmount2);
  return component4;
}
__name(_mount, "_mount");
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component4, options2) {
  const fn = mounted_components.get(component4);
  if (fn) {
    mounted_components.delete(component4);
    return fn(options2);
  }
  return Promise.resolve();
}
__name(unmount, "unmount");
function asClassComponent$1(component4) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component4,
        ...options2
      });
    }
  };
}
__name(asClassComponent$1, "asClassComponent$1");
var Svelte4Component = class {
  static {
    __name(this, "Svelte4Component");
  }
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value) => {
      var s3 = /* @__PURE__ */ mutable_source(value, false, false);
      sources.set(key2, s3);
      return s3;
    }, "add_source");
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop) {
          return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
        },
        has(target, prop) {
          if (prop === LEGACY_PROPS) return true;
          get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
          return Reflect.has(target, prop);
        },
        set(target, prop, value) {
          set(sources.get(prop) ?? add_source(prop, value), value);
          return Reflect.set(target, prop, value);
        }
      }
    );
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      anchor: options2.anchor,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    });
    if (!options2?.props?.$$host || options2.sync === false) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = /* @__PURE__ */ __name((...args) => callback.call(this, ...args), "cb");
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
var read_implementation = null;
function set_read_implementation(fn) {
  read_implementation = fn;
}
__name(set_read_implementation, "set_read_implementation");
function asClassComponent(component4) {
  const component_constructor = asClassComponent$1(component4);
  const _render = /* @__PURE__ */ __name((props, { context: context22 } = {}) => {
    const result = render(component4, { props, context: context22 });
    const munged = Object.defineProperties(
      /** @type {LegacyRenderResult & PromiseLike<LegacyRenderResult>} */
      {},
      {
        css: {
          value: { code: "", map: null }
        },
        head: {
          get: /* @__PURE__ */ __name(() => result.head, "get")
        },
        html: {
          get: /* @__PURE__ */ __name(() => result.body, "get")
        },
        then: {
          /**
           * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
           *
           * @template TResult1
           * @template [TResult2=never]
           * @param { (value: LegacyRenderResult) => TResult1 } onfulfilled
           * @param { (reason: unknown) => TResult2 } onrejected
           */
          value: /* @__PURE__ */ __name((onfulfilled, onrejected) => {
            {
              experimental_async_ssr();
              const user_result = onfulfilled({
                css: munged.css,
                head: munged.head,
                html: munged.html
              });
              return Promise.resolve(user_result);
            }
          }, "value")
        }
      }
    );
    return munged;
  }, "_render");
  component_constructor.render = _render;
  return component_constructor;
}
__name(asClassComponent, "asClassComponent");
function Root($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let {
      stores: stores2,
      page: page2,
      constructors,
      components = [],
      form,
      data_0 = null,
      data_1 = null
    } = $$props;
    {
      setContext("__svelte__", stores2);
    }
    {
      stores2.page.set(page2);
    }
    const Pyramid_1 = constructors[1];
    if (constructors[1]) {
      $$renderer2.push("<!--[-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, {
        data: data_0,
        form,
        params: page2.params,
        children: /* @__PURE__ */ __name(($$renderer3) => {
          $$renderer3.push(`<!---->`);
          Pyramid_1($$renderer3, { data: data_1, form, params: page2.params });
          $$renderer3.push(`<!---->`);
        }, "children"),
        $$slots: { default: true }
      });
      $$renderer2.push(`<!---->`);
    } else {
      $$renderer2.push("<!--[!-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, { data: data_0, form, params: page2.params });
      $$renderer2.push(`<!---->`);
    }
    $$renderer2.push(`<!--]--> `);
    {
      $$renderer2.push("<!--[!-->");
    }
    $$renderer2.push(`<!--]-->`);
  });
}
__name(Root, "Root");
var root = asClassComponent(Root);
var options = {
  app_template_contains_nonce: false,
  async: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  csrf_trusted_origins: [],
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hash_routing: false,
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  service_worker_options: void 0,
  templates: {
    app: /* @__PURE__ */ __name(({ head, body: body2, assets: assets2, nonce, env: env2 }) => '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="icon" href="' + assets2 + '/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    ' + head + "\n  </head>\n  <body>\n    " + body2 + "\n  </body>\n</html>\n", "app"),
    error: /* @__PURE__ */ __name(({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n", "error")
  },
  version_hash: "18iy9dc"
};
async function get_hooks() {
  let handle2;
  let handleFetch;
  let handleError2;
  let handleValidationError;
  let init2;
  ({ handle: handle2, handleFetch, handleError: handleError2, handleValidationError, init: init2 } = await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports)));
  let reroute;
  let transport;
  return {
    handle: handle2,
    handleFetch,
    handleError: handleError2,
    handleValidationError,
    init: init2,
    reroute,
    transport
  };
}
__name(get_hooks, "get_hooks");
function with_resolvers() {
  let resolve2;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
__name(with_resolvers, "with_resolvers");
var NULL_BODY_STATUS = [101, 103, 204, 205, 304];
var IN_WEBCONTAINER2 = !!globalThis.process?.versions?.webcontainer;
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i) => {
    const match = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      parts.push({ type, subtype, q: +q, i });
    }
  });
  parts.sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
__name(negotiate, "negotiate");
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
__name(is_content_type, "is_content_type");
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
__name(is_form_content_type, "is_form_content_type");
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
__name(coalesce_to_error, "coalesce_to_error");
function normalize_error(error22) {
  return (
    /** @type {import('../exports/internal/index.js').Redirect | HttpError | SvelteKitError | Error} */
    error22
  );
}
__name(normalize_error, "normalize_error");
function get_status(error22) {
  return error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500;
}
__name(get_status, "get_status");
function get_message(error22) {
  return error22 instanceof SvelteKitError ? error22.text : "Internal Error";
}
__name(get_message, "get_message");
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
  // Svelte also escapes < because the escape function could be called inside a `noscript` there
  // https://github.com/sveltejs/svelte/security/advisories/GHSA-8266-84wp-wv5c
  // However, that doesn't apply in SvelteKit
};
var escape_html_dict = {
  "&": "&amp;",
  "<": "&lt;"
};
var surrogates = (
  // high surrogate without paired low surrogate
  "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]"
);
var escape_html_attr_regex = new RegExp(
  `[${Object.keys(escape_html_attr_dict).join("")}]|` + surrogates,
  "g"
);
var escape_html_regex = new RegExp(
  `[${Object.keys(escape_html_dict).join("")}]|` + surrogates,
  "g"
);
function escape_html2(str, is_attr) {
  const dict = is_attr ? escape_html_attr_dict : escape_html_dict;
  const escaped_str = str.replace(is_attr ? escape_html_attr_regex : escape_html_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return escaped_str;
}
__name(escape_html2, "escape_html2");
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
__name(method_not_allowed, "method_not_allowed");
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod && !("HEAD" in mod)) {
    allowed.push("HEAD");
  }
  return allowed;
}
__name(allowed_methods, "allowed_methods");
function get_global_name(options2) {
  return `__sveltekit_${options2.version_hash}`;
}
__name(get_global_name, "get_global_name");
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message: escape_html2(message) });
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
__name(static_error_page, "static_error_page");
async function handle_fatal_error(event, state2, options2, error22) {
  error22 = error22 instanceof HttpError ? error22 : coalesce_to_error(error22);
  const status = get_status(error22);
  const body2 = await handle_error_and_jsonify(event, state2, options2, error22);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
__name(handle_fatal_error, "handle_fatal_error");
async function handle_error_and_jsonify(event, state2, options2, error22) {
  if (error22 instanceof HttpError) {
    return { message: "Unknown Error", ...error22.body };
  }
  const status = get_status(error22);
  const message = get_message(error22);
  return await with_request_store(
    { event, state: state2 },
    () => options2.hooks.handleError({ error: error22, event, status, message })
  ) ?? { message };
}
__name(handle_error_and_jsonify, "handle_error_and_jsonify");
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
__name(redirect_response, "redirect_response");
function clarify_devalue_error(event, error22) {
  if (error22.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error22.message} (${error22.path}). If you need to serialize/deserialize custom types, use transport hooks: https://svelte.dev/docs/kit/hooks#Universal-hooks-transport.`;
  }
  if (error22.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error22.message;
}
__name(clarify_devalue_error, "clarify_devalue_error");
function serialize_uses(node) {
  const uses = {};
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.dependencies = Array.from(node.uses.dependencies);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.search_params = Array.from(node.uses.search_params);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.params = Array.from(node.uses.params);
  }
  if (node.uses?.parent) uses.parent = 1;
  if (node.uses?.route) uses.route = 1;
  if (node.uses?.url) uses.url = 1;
  return uses;
}
__name(serialize_uses, "serialize_uses");
function has_prerendered_path(manifest2, pathname) {
  return manifest2._.prerendered_routes.has(pathname) || pathname.at(-1) === "/" && manifest2._.prerendered_routes.has(pathname.slice(0, -1));
}
__name(has_prerendered_path, "has_prerendered_path");
function format_server_error(status, error22, event) {
  const formatted_text = `
\x1B[1;31m[${status}] ${event.request.method} ${event.url.pathname}\x1B[0m`;
  if (status === 404) {
    return formatted_text;
  }
  return `${formatted_text}
${error22.stack}`;
}
__name(format_server_error, "format_server_error");
function get_node_type(node_id) {
  const parts = node_id?.split("/");
  const filename = parts?.at(-1);
  if (!filename) return "unknown";
  const dot_parts = filename.split(".");
  return dot_parts.slice(0, -1).join(".");
}
__name(get_node_type, "get_node_type");
async function render_endpoint(event, event_state, mod, state2) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && !mod.HEAD && mod.GET) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state2.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state2.prerendering && !state2.prerendering.inside_reroute && !prerender) {
    if (state2.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  event_state.is_endpoint_request = true;
  try {
    const response = await with_request_store(
      { event, state: event_state },
      () => handler(
        /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
        event
      )
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state2.prerendering && (!state2.prerendering.inside_reroute || prerender)) {
      const cloned = new Response(response.clone().body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      cloned.headers.set("x-sveltekit-prerender", String(prerender));
      if (state2.prerendering.inside_reroute && prerender) {
        cloned.headers.set(
          "x-sveltekit-routeid",
          encodeURI(
            /** @type {string} */
            event.route.id
          )
        );
        state2.prerendering.dependencies.set(event.url.pathname, { response: cloned, body: null });
      } else {
        return cloned;
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
__name(render_endpoint, "render_endpoint");
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true") return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
__name(is_endpoint_request, "is_endpoint_request");
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
__name(compact, "compact");
var DATA_SUFFIX = "/__data.json";
var HTML_DATA_SUFFIX = ".html__data.json";
function has_data_suffix2(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
__name(has_data_suffix2, "has_data_suffix2");
function add_data_suffix2(pathname) {
  if (pathname.endsWith(".html")) return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
__name(add_data_suffix2, "add_data_suffix2");
function strip_data_suffix2(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
__name(strip_data_suffix2, "strip_data_suffix2");
var ROUTE_SUFFIX = "/__route.js";
function has_resolution_suffix2(pathname) {
  return pathname.endsWith(ROUTE_SUFFIX);
}
__name(has_resolution_suffix2, "has_resolution_suffix2");
function add_resolution_suffix2(pathname) {
  return pathname.replace(/\/$/, "") + ROUTE_SUFFIX;
}
__name(add_resolution_suffix2, "add_resolution_suffix2");
function strip_resolution_suffix2(pathname) {
  return pathname.slice(0, -ROUTE_SUFFIX.length);
}
__name(strip_resolution_suffix2, "strip_resolution_suffix2");
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  __name(walk, "walk");
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], get_name(i));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive2(thing);
    }
    if (custom.has(thing)) {
      return custom.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v2, i) => i in thing ? stringify2(v2) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array2 = new thing.constructor(thing.buffer);
          str2 += `([${array2}])`;
        } else {
          str2 += `([${stringify2(thing.buffer)}])`;
        }
        const a = thing.byteOffset;
        const b = a + thing.byteLength;
        if (a > 0 || b !== thing.buffer.byteLength) {
          const m = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a / m},${b / m})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify2(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  __name(stringify2, "stringify2");
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (custom.has(thing)) {
        values.push(
          /** @type {string} */
          custom.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive2(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v2, i) => {
            statements.push(`${name}[${i}]=${stringify2(v2)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v2) => `add(${stringify2(v2)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v2]) => `set(${stringify2(k)}, ${stringify2(v2)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify2(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
__name(uneval, "uneval");
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
__name(get_name, "get_name");
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
__name(escape_unsafe_char, "escape_unsafe_char");
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
__name(escape_unsafe_chars, "escape_unsafe_chars");
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
__name(safe_key, "safe_key");
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
__name(safe_prop, "safe_prop");
function stringify_primitive2(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}
__name(stringify_primitive2, "stringify_primitive2");
var noop_span = {
  spanContext() {
    return noop_span_context;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  }
};
var noop_span_context = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
async function record_span({ name, attributes: attributes2, fn }) {
  {
    return fn(noop_span);
  }
}
__name(record_span, "record_span");
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
__name(is_action_json_request, "is_action_json_request");
async function handle_action_json_request(event, event_state, options2, server2) {
  const actions = server2?.actions;
  if (!actions) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      `POST method not allowed. No form actions exist for ${"this page"}`
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, event_state, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(
          event,
          event_state,
          options2,
          check_incorrect_fail_use(err)
        )
      },
      {
        status: get_status(err)
      }
    );
  }
}
__name(handle_action_json_request, "handle_action_json_request");
function check_incorrect_fail_use(error22) {
  return error22 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error22;
}
__name(check_incorrect_fail_use, "check_incorrect_fail_use");
function action_json_redirect(redirect) {
  return action_json({
    type: "redirect",
    status: redirect.status,
    location: redirect.location
  });
}
__name(action_json_redirect, "action_json_redirect");
function action_json(data, init2) {
  return json(data, init2);
}
__name(action_json, "action_json");
function is_action_request(event) {
  return event.request.method === "POST";
}
__name(is_action_request, "is_action_request");
async function handle_action_request(event, event_state, server2) {
  const actions = server2?.actions;
  if (!actions) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
__name(handle_action_request, "handle_action_request");
function check_named_default_separate(actions) {
  if (actions.default && Object.keys(actions).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions"
    );
  }
}
__name(check_named_default_separate, "check_named_default_separate");
async function call_action(event, event_state, actions) {
  const url = new URL(event.request.url);
  let name = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name = param[0].slice(1);
      if (name === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions[name];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return record_span({
    name: "sveltekit.form_action",
    attributes: {
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      const result = await with_request_store(
        { event: traced_event, state: event_state },
        () => action(traced_event)
      );
      if (result instanceof ActionFailure) {
        current2.setAttributes({
          "sveltekit.form_action.result.type": "failure",
          "sveltekit.form_action.result.status": result.status
        });
      }
      return result;
    }, "fn")
  });
}
__name(call_action, "call_action");
function uneval_action_response(data, route_id, transport) {
  const replacer = /* @__PURE__ */ __name((thing) => {
    for (const key2 in transport) {
      const encoded = transport[key2].encode(thing);
      if (encoded) {
        return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
      }
    }
  }, "replacer");
  return try_serialize(data, (value) => uneval(value, replacer), route_id);
}
__name(uneval_action_response, "uneval_action_response");
function stringify_action_response(data, route_id, transport) {
  const encoders = Object.fromEntries(
    Object.entries(transport).map(([key2, value]) => [key2, value.encode])
  );
  return try_serialize(data, (value) => stringify$1(value, encoders), route_id);
}
__name(stringify_action_response, "stringify_action_response");
function try_serialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error22 = (
      /** @type {any} */
      e3
    );
    if (data instanceof Response) {
      throw new Error(
        `Data returned from action inside ${route_id} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`
      );
    }
    if ("path" in error22) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error22.message}`;
      if (error22.path !== "") message += ` (data.${error22.path})`;
      throw new Error(message);
    }
    throw error22;
  }
}
__name(try_serialize, "try_serialize");
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r3) => {
    fulfil = f;
    reject = r3;
  });
  return { promise, fulfil, reject };
}
__name(defer, "defer");
function create_async_iterator() {
  let count3 = 0;
  const deferred2 = [defer()];
  return {
    iterate: /* @__PURE__ */ __name((transform = (x) => x) => {
      return {
        [Symbol.asyncIterator]() {
          return {
            next: /* @__PURE__ */ __name(async () => {
              const next2 = await deferred2[0].promise;
              if (!next2.done) {
                deferred2.shift();
                return { value: transform(next2.value), done: false };
              }
              return next2;
            }, "next")
          };
        }
      };
    }, "iterate"),
    add: /* @__PURE__ */ __name((promise) => {
      count3 += 1;
      void promise.then((value) => {
        deferred2[deferred2.length - 1].fulfil({
          value,
          done: false
        });
        deferred2.push(defer());
        if (--count3 === 0) {
          deferred2[deferred2.length - 1].fulfil({ done: true });
        }
      });
    }, "add")
  };
}
__name(create_async_iterator, "create_async_iterator");
function server_data_serializer(event, event_state, options2) {
  let promise_id = 1;
  let max_nodes = -1;
  const iterator = create_async_iterator();
  const global2 = get_global_name(options2);
  function get_replacer(index4) {
    return /* @__PURE__ */ __name(function replacer(thing) {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        const promise = thing.then(
          /** @param {any} data */
          (data) => ({ data })
        ).catch(
          /** @param {any} error */
          async (error22) => ({
            error: await handle_error_and_jsonify(event, event_state, options2, error22)
          })
        ).then(
          /**
           * @param {{data: any; error: any}} result
           */
          async ({ data, error: error22 }) => {
            let str;
            try {
              str = uneval(error22 ? [, error22] : [data], replacer);
            } catch {
              error22 = await handle_error_and_jsonify(
                event,
                event_state,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              data = void 0;
              str = uneval([, error22], replacer);
            }
            return {
              index: index4,
              str: `${global2}.resolve(${id}, ${str.includes("app.decode") ? `(app) => ${str}` : `() => ${str}`})`
            };
          }
        );
        iterator.add(promise);
        return `${global2}.defer(${id})`;
      } else {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      }
    }, "replacer");
  }
  __name(get_replacer, "get_replacer");
  const strings = (
    /** @type {string[]} */
    []
  );
  return {
    set_max_nodes(i) {
      max_nodes = i;
    },
    add_node(i, node) {
      try {
        if (!node) {
          strings[i] = "null";
          return;
        }
        const payload = { type: "data", data: node.data, uses: serialize_uses(node) };
        if (node.slash) payload.slash = node.slash;
        strings[i] = uneval(payload, get_replacer(i));
      } catch (e3) {
        e3.path = e3.path.slice(1);
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e3
        ));
      }
    },
    get_data(csp) {
      const open = `<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>`;
      const close = `<\/script>
`;
      return {
        data: `[${compact(max_nodes > -1 ? strings.slice(0, max_nodes) : strings).join(",")}]`,
        chunks: promise_id > 1 ? iterator.iterate(({ index: index4, str }) => {
          if (max_nodes > -1 && index4 >= max_nodes) {
            return "";
          }
          return open + str + close;
        }) : null
      };
    }
  };
}
__name(server_data_serializer, "server_data_serializer");
function server_data_serializer_json(event, event_state, options2) {
  let promise_id = 1;
  const iterator = create_async_iterator();
  const reducers = {
    ...Object.fromEntries(
      Object.entries(options2.hooks.transport).map(([key2, value]) => [key2, value.encode])
    ),
    /** @param {any} thing */
    Promise: /* @__PURE__ */ __name((thing) => {
      if (typeof thing?.then !== "function") {
        return;
      }
      const id = promise_id++;
      let key2 = "data";
      const promise = thing.catch(
        /** @param {any} e */
        async (e3) => {
          key2 = "error";
          return handle_error_and_jsonify(
            event,
            event_state,
            options2,
            /** @type {any} */
            e3
          );
        }
      ).then(
        /** @param {any} value */
        async (value) => {
          let str;
          try {
            str = stringify$1(value, reducers);
          } catch {
            const error22 = await handle_error_and_jsonify(
              event,
              event_state,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            key2 = "error";
            str = stringify$1(error22, reducers);
          }
          return `{"type":"chunk","id":${id},"${key2}":${str}}
`;
        }
      );
      iterator.add(promise);
      return id;
    }, "Promise")
  };
  const strings = (
    /** @type {string[]} */
    []
  );
  return {
    add_node(i, node) {
      try {
        if (!node) {
          strings[i] = "null";
          return;
        }
        if (node.type === "error" || node.type === "skip") {
          strings[i] = JSON.stringify(node);
          return;
        }
        strings[i] = `{"type":"data","data":${stringify$1(node.data, reducers)},"uses":${JSON.stringify(
          serialize_uses(node)
        )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
      } catch (e3) {
        e3.path = "data" + e3.path;
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e3
        ));
      }
    },
    get_data() {
      return {
        data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
        chunks: promise_id > 1 ? iterator.iterate() : null
      };
    }
  };
}
__name(server_data_serializer_json, "server_data_serializer_json");
async function load_server_data({ event, event_state, state: state2, node, parent }) {
  if (!node?.server) return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const load = node.server.load;
  const slash = node.server.trailingSlash;
  if (!load) {
    return { type: "data", data: null, uses, slash };
  }
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state2.prerendering) {
    disable_search(url);
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.server_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.server_id),
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      const result2 = await with_request_store(
        { event: traced_event, state: event_state },
        () => load.call(null, {
          ...traced_event,
          fetch: /* @__PURE__ */ __name((info3, init2) => {
            new URL(info3 instanceof Request ? info3.url : info3, event.url);
            return event.fetch(info3, init2);
          }, "fetch"),
          /** @param {string[]} deps */
          depends: /* @__PURE__ */ __name((...deps) => {
            for (const dep of deps) {
              const { href } = new URL(dep, event.url);
              uses.dependencies.add(href);
            }
          }, "depends"),
          params: new Proxy(event.params, {
            get: /* @__PURE__ */ __name((target, key2) => {
              if (is_tracking) {
                uses.params.add(key2);
              }
              return target[
                /** @type {string} */
                key2
              ];
            }, "get")
          }),
          parent: /* @__PURE__ */ __name(async () => {
            if (is_tracking) {
              uses.parent = true;
            }
            return parent();
          }, "parent"),
          route: new Proxy(event.route, {
            get: /* @__PURE__ */ __name((target, key2) => {
              if (is_tracking) {
                uses.route = true;
              }
              return target[
                /** @type {'id'} */
                key2
              ];
            }, "get")
          }),
          url,
          untrack(fn) {
            is_tracking = false;
            try {
              return fn();
            } finally {
              is_tracking = true;
            }
          }
        })
      );
      return result2;
    }, "fn")
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash
  };
}
__name(load_server_data, "load_server_data");
async function load_data({
  event,
  event_state,
  fetched,
  node,
  parent,
  server_data_promise,
  state: state2,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  const load = node?.universal?.load;
  if (!load) {
    return server_data_node?.data ?? null;
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.universal_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.universal_id),
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      return await with_request_store(
        { event: traced_event, state: event_state },
        () => load.call(null, {
          url: event.url,
          params: event.params,
          data: server_data_node?.data ?? null,
          route: event.route,
          fetch: create_universal_fetch(event, state2, fetched, csr, resolve_opts),
          setHeaders: event.setHeaders,
          depends: /* @__PURE__ */ __name(() => {
          }, "depends"),
          parent,
          untrack: /* @__PURE__ */ __name((fn) => fn(), "untrack"),
          tracing: traced_event.tracing
        })
      );
    }, "fn")
  });
  return result ?? null;
}
__name(load_data, "load_data");
function create_universal_fetch(event, state2, fetched, csr, resolve_opts) {
  const universal_fetch = /* @__PURE__ */ __name(async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state2.prerendering) {
        dependency = { response, body: null };
        state2.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else if (url.protocol === "https:" || url.protocol === "http:") {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    let teed_body;
    const proxy2 = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        __name(push_fetched, "push_fetched");
        if (key2 === "body") {
          if (response2.body === null) {
            return null;
          }
          if (teed_body) {
            return teed_body;
          }
          const [a, b] = response2.body.tee();
          void (async () => {
            let result = new Uint8Array();
            for await (const chunk of a) {
              const combined = new Uint8Array(result.length + chunk.length);
              combined.set(result, 0);
              combined.set(chunk, result.length);
              result = combined;
            }
            if (dependency) {
              dependency.body = new Uint8Array(result);
            }
            void push_fetched(base64_encode(result), true);
          })();
          return teed_body = b;
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            if (dependency) {
              dependency.body = bytes;
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(base64_encode(bytes), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (body2 === "" && NULL_BODY_STATUS.includes(response2.status)) {
            await push_fetched(void 0, false);
            return void 0;
          }
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        __name(text2, "text2");
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            const body2 = await text2();
            return body2 ? JSON.parse(body2) : void 0;
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get2 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get2.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy2;
  }, "universal_fetch");
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_universal_fetch, "create_universal_fetch");
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += text_decoder2.decode(value);
  }
  return result;
}
__name(stream_to_string, "stream_to_string");
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i = value.length;
      while (i) hash2 = hash2 * 33 ^ value.charCodeAt(--i);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i = buffer.length;
      while (i) hash2 = hash2 * 33 ^ buffer[--i];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
__name(hash, "hash");
var replacements2 = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control") cache_control = value;
    else if (key2 === "age") age = value;
    else if (key2 === "vary" && value.trim() === "*") varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements2[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url="${escape_html2(fetched.url, true)}"`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
__name(serialize_data, "serialize_data");
var s = JSON.stringify;
function sha256(data) {
  if (!key[0]) precompute();
  const out = init.slice(0);
  const array2 = encode$1(data);
  for (let i = 0; i < array2.length; i += 16) {
    const w = array2.subarray(i, i + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        tmp = w[i2];
      } else {
        a = w[i2 + 1 & 15];
        b = w[i2 + 14 & 15];
        tmp = w[i2 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i2 & 15] + w[i2 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i2];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return btoa(String.fromCharCode(...bytes));
}
__name(sha256, "sha256");
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x) {
    return (x - Math.floor(x)) * 4294967296;
  }
  __name(frac, "frac");
  let prime = 2;
  for (let i = 0; i < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i < 8) {
        init[i] = frac(prime ** (1 / 2));
      }
      key[i] = frac(prime ** (1 / 3));
      i++;
    }
  }
}
__name(precompute, "precompute");
function reverse_endianness(bytes) {
  for (let i = 0; i < bytes.length; i += 4) {
    const a = bytes[i + 0];
    const b = bytes[i + 1];
    const c2 = bytes[i + 2];
    const d = bytes[i + 3];
    bytes[i + 0] = d;
    bytes[i + 1] = c2;
    bytes[i + 2] = b;
    bytes[i + 3] = a;
  }
}
__name(reverse_endianness, "reverse_endianness");
function encode$1(str) {
  const encoded = text_encoder2.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
__name(encode$1, "encode$1");
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return btoa(String.fromCharCode(...array));
}
__name(generate_nonce, "generate_nonce");
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  static {
    __name(this, "BaseProvider");
  }
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #script_src_needs_csp;
  /** @type {boolean} */
  #script_src_elem_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {boolean} */
  #style_src_needs_csp;
  /** @type {boolean} */
  #style_src_attr_needs_csp;
  /** @type {boolean} */
  #style_src_elem_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    const needs_csp = /* @__PURE__ */ __name((directive) => !!directive && !directive.some((value) => value === "unsafe-inline"), "needs_csp");
    this.#script_src_needs_csp = needs_csp(effective_script_src);
    this.#script_src_elem_needs_csp = needs_csp(script_src_elem);
    this.#style_src_needs_csp = needs_csp(effective_style_src);
    this.#style_src_attr_needs_csp = needs_csp(style_src_attr);
    this.#style_src_elem_needs_csp = needs_csp(style_src_elem);
    this.#script_needs_csp = this.#script_src_needs_csp || this.#script_src_elem_needs_csp;
    this.#style_needs_csp = this.#style_src_needs_csp || this.#style_src_attr_needs_csp || this.#style_src_elem_needs_csp;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (!this.#script_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#script_src_needs_csp) {
      this.#script_src.push(source2);
    }
    if (this.#script_src_elem_needs_csp) {
      this.#script_src_elem.push(source2);
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (!this.#style_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#style_src_needs_csp) {
      this.#style_src.push(source2);
    }
    if (this.#style_src_attr_needs_csp) {
      this.#style_src_attr.push(source2);
    }
    if (this.#style_src_elem_needs_csp) {
      const sha256_empty_comment_hash = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (d["style-src-elem"] && !d["style-src-elem"].includes(sha256_empty_comment_hash) && !this.#style_src_elem.includes(sha256_empty_comment_hash)) {
        this.#style_src_elem.push(sha256_empty_comment_hash);
      }
      if (source2 !== sha256_empty_comment_hash) {
        this.#style_src_elem.push(source2);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value) continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  static {
    __name(this, "CspProvider");
  }
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content="${escape_html2(content, true)}">`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  static {
    __name(this, "CspReportOnlyProvider");
  }
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v2) => !!v2).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  static {
    __name(this, "Csp");
  }
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i = 0; i < params.length; i += 1) {
    const param = params[i];
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest) result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered) return;
  return result;
}
__name(exec, "exec");
function generate_route_object(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  const nodes = [...errors, ...layouts.map((l) => l?.[1]), leaf[1]].filter((n2) => typeof n2 === "number").map((n2) => `'${n2}': () => ${create_client_import(manifest2._.client.nodes?.[n2], url)}`).join(",\n		");
  return [
    `{
	id: ${s(route.id)}`,
    `errors: ${s(route.errors)}`,
    `layouts: ${s(route.layouts)}`,
    `leaf: ${s(route.leaf)}`,
    `nodes: {
		${nodes}
	}
}`
  ].join(",\n	");
}
__name(generate_route_object, "generate_route_object");
function create_client_import(import_path, url) {
  if (!import_path) return "Promise.resolve({})";
  if (import_path[0] === "/") {
    return `import('${import_path}')`;
  }
  if (assets !== "") {
    return `import('${assets}/${import_path}')`;
  }
  let path = get_relative_path(url.pathname, `${base}/${import_path}`);
  if (path[0] !== ".") path = `./${path}`;
  return `import('${path}')`;
}
__name(create_client_import, "create_client_import");
async function resolve_route(resolved_path, url, manifest2) {
  if (!manifest2._.client.routes) {
    return text("Server-side route resolution disabled", { status: 400 });
  }
  let route = null;
  let params = {};
  const matchers = await manifest2._.matchers();
  for (const candidate of manifest2._.client.routes) {
    const match = candidate.pattern.exec(resolved_path);
    if (!match) continue;
    const matched = exec(match, candidate.params, matchers);
    if (matched) {
      route = candidate;
      params = decode_params(matched);
      break;
    }
  }
  return create_server_routing_response(route, params, url, manifest2).response;
}
__name(resolve_route, "resolve_route");
function create_server_routing_response(route, params, url, manifest2) {
  const headers2 = new Headers({
    "content-type": "application/javascript; charset=utf-8"
  });
  if (route) {
    const csr_route = generate_route_object(route, url, manifest2);
    const body2 = `${create_css_import(route, url, manifest2)}
export const route = ${csr_route}; export const params = ${JSON.stringify(params)};`;
    return { response: text(body2, { headers: headers2 }), body: body2 };
  } else {
    return { response: text("", { headers: headers2 }), body: "" };
  }
}
__name(create_server_routing_response, "create_server_routing_response");
function create_css_import(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  let css = "";
  for (const node of [...errors, ...layouts.map((l) => l?.[1]), leaf[1]]) {
    if (typeof node !== "number") continue;
    const node_css = manifest2._.client.css?.[node];
    for (const css_path of node_css ?? []) {
      css += `'${assets || base}/${css_path}',`;
    }
  }
  if (!css) return "";
  return `${create_client_import(
    /** @type {string} */
    manifest2._.client.start,
    url
  )}.then(x => x.load_css([${css}]));`;
}
__name(create_css_import, "create_css_import");
var updated = {
  ...readable(false),
  check: /* @__PURE__ */ __name(() => false, "check")
};
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state: state2,
  page_config,
  status,
  error: error22 = null,
  event,
  event_state,
  resolve_opts,
  action_result,
  data_serializer
}) {
  if (state2.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets4 = new Set(client.stylesheets);
  const fonts4 = new Set(client.fonts);
  const link_headers = /* @__PURE__ */ new Set();
  const link_tags = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  {
    if (!state2.prerendering?.fallback) {
      const segments = event.url.pathname.slice(base.length).split("/").slice(2);
      base$1 = segments.map(() => "..").join("/") || ".";
      base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
      if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
        assets$1 = base$1;
      }
    } else if (options2.hash_routing) {
      base_expression = "new URL('.', location).pathname.slice(0, -1)";
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(
        branch2.map(({ node }) => {
          if (!node.component) {
            throw new Error(`Missing +page.svelte component for route ${event.route.id}`);
          }
          return node.component();
        })
      ),
      form: form_value
    };
    let data2 = {};
    for (let i = 0; i < branch2.length; i += 1) {
      data2 = { ...data2, ...branch2[i].data };
      props[`data_${i}`] = data2;
    }
    props.page = {
      error: error22,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    const render_opts = {
      context: /* @__PURE__ */ new Map([
        [
          "__request__",
          {
            page: props.page
          }
        ]
      ])
    };
    const fetch2 = globalThis.fetch;
    try {
      if (BROWSER) ;
      rendered = await with_request_store({ event, state: event_state }, async () => {
        if (relative) override({ base: base$1, assets: assets$1 });
        const maybe_promise = options2.root.render(props, render_opts);
        const rendered2 = options2.async && "then" in maybe_promise ? (
          /** @type {ReturnType<typeof options.root.render> & Promise<any>} */
          maybe_promise.then((r3) => r3)
        ) : maybe_promise;
        if (options2.async) {
          reset();
        }
        const { head: head2, html: html2, css } = options2.async ? await rendered2 : rendered2;
        return { head: head2, html: html2, css };
      });
    } finally {
      reset();
    }
    for (const { node } of branch2) {
      for (const url of node.imports) modulepreloads.add(url);
      for (const url of node.stylesheets) stylesheets4.add(url);
      for (const url of node.fonts) fonts4.add(url);
      if (node.inline_styles && !client.inline) {
        Object.entries(await node.inline_styles()).forEach(([k, v2]) => inline_styles.set(k, v2));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state2.prerendering
  });
  const prefixed = /* @__PURE__ */ __name((path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  }, "prefixed");
  const style = client.inline ? client.inline?.style : Array.from(inline_styles.values()).join("\n");
  if (style) {
    const attributes2 = [];
    if (csp.style_needs_nonce) attributes2.push(` nonce="${csp.nonce}"`);
    csp.add_style(style);
    head += `
	<style${attributes2.join("")}>${style}</style>`;
  }
  for (const dep of stylesheets4) {
    const path = prefixed(dep);
    const attributes2 = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes2.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        link_headers.add(`<${encodeURI(path)}>; rel="preload"; as="style"; nopush`);
      }
    }
    head += `
		<link href="${path}" ${attributes2.join(" ")}>`;
  }
  for (const dep of fonts4) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      link_tags.add(`<link rel="preload" as="font" type="font/${ext}" href="${path}" crossorigin>`);
      link_headers.add(
        `<${encodeURI(path)}>; rel="preload"; as="font"; type="font/${ext}"; crossorigin; nopush`
      );
    }
  }
  const global2 = get_global_name(options2);
  const { data, chunks } = data_serializer.get_data(csp);
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state2.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const route = manifest2._.client.routes?.find((r3) => r3.id === event.route.id) ?? null;
    if (client.uses_env_dynamic_public && state2.prerendering) {
      modulepreloads.add(`${app_dir}/env.js`);
    }
    if (!client.inline) {
      const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
        (path) => resolve_opts.preload({ type: "js", path })
      );
      for (const path of included_modulepreloads) {
        link_headers.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
        if (options2.preload_strategy !== "modulepreload") {
          head += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
        } else {
          link_tags.add(`<link rel="modulepreload" href="${path}">`);
        }
      }
    }
    if (state2.prerendering && link_tags.size > 0) {
      head += Array.from(link_tags).map((tag) => `
		${tag}`).join("");
    }
    if (manifest2._.client.routes && state2.prerendering && !state2.prerendering.fallback) {
      const pathname = add_resolution_suffix2(event.url.pathname);
      state2.prerendering.dependencies.set(
        pathname,
        create_server_routing_response(route, event.params, new URL(pathname, event.url), manifest2)
      );
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state2.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      let app_declaration = "";
      if (Object.keys(options2.hooks.transport).length > 0) {
        if (client.inline) {
          app_declaration = `const app = __sveltekit_${options2.version_hash}.app.app;`;
        } else if (client.app) {
          app_declaration = `const app = await import(${s(prefixed(client.app))});`;
        } else {
          app_declaration = `const { app } = await import(${s(prefixed(client.start))});`;
        }
      }
      const prelude = app_declaration ? `${app_declaration}
							const [data, error] = fn(app);` : `const [data, error] = fn();`;
      properties.push(`resolve: async (id, fn) => {
							${prelude}

							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        );
      }
      if (error22) {
        serialized.error = uneval(error22);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        `data: ${data}`,
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (manifest2._.client.routes) {
        if (route) {
          const stringified = generate_route_object(route, event.url, manifest2).replaceAll(
            "\n",
            "\n							"
          );
          hydrate2.push(`params: ${uneval(event.params)}`, `server_route: ${stringified}`);
        }
      } else if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    const { remote_data: remote_cache } = event_state;
    let serialized_remote_data = "";
    if (remote_cache) {
      const remote = {};
      for (const [info3, cache] of remote_cache) {
        if (!info3.id) continue;
        for (const key2 in cache) {
          remote[create_remote_cache_key(info3.id, key2)] = await cache[key2];
        }
      }
      const replacer = /* @__PURE__ */ __name((thing) => {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      }, "replacer");
      serialized_remote_data = `${global2}.data = ${uneval(remote, replacer)};

						`;
    }
    const boot = client.inline ? `${client.inline.script}

					${serialized_remote_data}${global2}.app.start(${args.join(", ")});` : client.app ? `Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						${serialized_remote_data}kit.start(app, ${args.join(", ")});
					});` : `import(${s(prefixed(client.start))}).then((app) => {
						${serialized_remote_data}app.start(${args.join(", ")})
					});`;
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${app_dir}/env.js`)}).then(({ env }) => {
						${global2}.env = env;

						${boot.replace(/\n/g, "\n	")}
					});`);
    } else {
      blocks.push(boot);
    }
    if (options2.service_worker) {
      let opts = "";
      if (options2.service_worker_options != null) {
        const service_worker_options = { ...options2.service_worker_options };
        opts = `, ${s(service_worker_options)}`;
      }
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state2.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state2.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state2.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_headers.size) {
      headers2.set("link", Array.from(link_headers).join(", "));
    }
  }
  head += rendered.head;
  const html = options2.templates.app({
    head,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller2) {
        controller2.enqueue(text_encoder2.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller2.enqueue(text_encoder2.encode(chunk));
        }
        controller2.close();
      },
      type: "bytes"
    }),
    {
      headers: headers2
    }
  );
}
__name(render_response, "render_response");
var PageNodes = class {
  static {
    __name(this, "PageNodes");
  }
  data;
  /**
   * @param {Array<import('types').SSRNode | undefined>} nodes
   */
  constructor(nodes) {
    this.data = nodes;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const layout of this.layouts()) {
      if (layout) {
        validate_layout_server_exports(
          layout.server,
          /** @type {string} */
          layout.server_id
        );
        validate_layout_exports(
          layout.universal,
          /** @type {string} */
          layout.universal_id
        );
      }
    }
    const page2 = this.page();
    if (page2) {
      validate_page_server_exports(
        page2.server,
        /** @type {string} */
        page2.server_id
      );
      validate_page_exports(
        page2.universal,
        /** @type {string} */
        page2.universal_id
      );
    }
  }
  /**
   * @template {'prerender' | 'ssr' | 'csr' | 'trailingSlash'} Option
   * @param {Option} option
   * @returns {Value | undefined}
   */
  #get_option(option) {
    return this.data.reduce(
      (value, node) => {
        return node?.universal?.[option] ?? node?.server?.[option] ?? value;
      },
      /** @type {Value | undefined} */
      void 0
    );
  }
  csr() {
    return this.#get_option("csr") ?? true;
  }
  ssr() {
    return this.#get_option("ssr") ?? true;
  }
  prerender() {
    return this.#get_option("prerender") ?? false;
  }
  trailing_slash() {
    return this.#get_option("trailingSlash") ?? "never";
  }
  get_config() {
    let current2 = {};
    for (const node of this.data) {
      if (!node?.universal?.config && !node?.server?.config) continue;
      current2 = {
        ...current2,
        // TODO: should we override the server config value with the universal value similar to other page options?
        ...node?.universal?.config,
        ...node?.server?.config
      };
    }
    return Object.keys(current2).length ? current2 : void 0;
  }
  should_prerender_data() {
    return this.data.some(
      // prerender in case of trailingSlash because the client retrieves that value from the server
      (node) => node?.server?.load || node?.server?.trailingSlash !== void 0
    );
  }
};
async function respond_with_error({
  event,
  event_state,
  options: options2,
  manifest: manifest2,
  state: state2,
  status,
  error: error22,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error22.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const nodes = new PageNodes([default_layout]);
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    const data_serializer = server_data_serializer(event, event_state, options2);
    if (ssr) {
      state2.error = true;
      const server_data_promise = load_server_data({
        event,
        event_state,
        state: state2,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent")
      });
      const server_data = await server_data_promise;
      data_serializer.add_node(0, server_data);
      const data = await load_data({
        event,
        event_state,
        fetched,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent"),
        resolve_opts,
        server_data_promise,
        state: state2,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state: state2,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, event_state, options2, error22),
      branch: branch2,
      fetched,
      event,
      event_state,
      resolve_opts,
      data_serializer
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, event_state, options2, e3)).message
    );
  }
}
__name(respond_with_error, "respond_with_error");
async function handle_remote_call(event, state2, options2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.call",
    attributes: {},
    fn: /* @__PURE__ */ __name((current2) => {
      const traced_event = merge_tracing(event, current2);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_call_internal(traced_event, state2, options2, manifest2, id)
      );
    }, "fn")
  });
}
__name(handle_remote_call, "handle_remote_call");
async function handle_remote_call_internal(event, state2, options2, manifest2, id) {
  const [hash2, name, additional_args] = id.split("/");
  const remotes = manifest2._.remotes;
  if (!remotes[hash2]) error3(404);
  const module = await remotes[hash2]();
  const fn = module.default[name];
  if (!fn) error3(404);
  const info3 = fn.__;
  const transport = options2.hooks.transport;
  event.tracing.current.setAttributes({
    "sveltekit.remote.call.type": info3.type,
    "sveltekit.remote.call.name": info3.name
  });
  let form_client_refreshes;
  try {
    if (info3.type === "query_batch") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`query.batch\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      const { payloads } = await event.request.json();
      const args = payloads.map((payload2) => parse_remote_arg(payload2, transport));
      const get_result = await with_request_store({ event, state: state2 }, () => info3.run(args));
      const results = await Promise.all(
        args.map(async (arg, i) => {
          try {
            return { type: "result", data: get_result(arg, i) };
          } catch (error22) {
            return {
              type: "error",
              error: await handle_error_and_jsonify(event, state2, options2, error22),
              status: error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500
            };
          }
        })
      );
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify(results, transport)
        }
      );
    }
    if (info3.type === "form") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`form\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      if (!is_form_content_type(event.request)) {
        throw new SvelteKitError(
          415,
          "Unsupported Media Type",
          `\`form\` functions expect form-encoded data \u2014 received ${event.request.headers.get(
            "content-type"
          )}`
        );
      }
      const form_data = await event.request.formData();
      form_client_refreshes = /** @type {string[]} */
      JSON.parse(
        /** @type {string} */
        form_data.get("sveltekit:remote_refreshes") ?? "[]"
      );
      form_data.delete("sveltekit:remote_refreshes");
      if (additional_args) {
        form_data.set("sveltekit:id", decodeURIComponent(additional_args));
      }
      const fn2 = info3.fn;
      const data2 = await with_request_store({ event, state: state2 }, () => fn2(form_data));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify(data2, transport),
          refreshes: data2.issues ? {} : await serialize_refreshes(form_client_refreshes)
        }
      );
    }
    if (info3.type === "command") {
      const { payload: payload2, refreshes } = await event.request.json();
      const arg = parse_remote_arg(payload2, transport);
      const data2 = await with_request_store({ event, state: state2 }, () => fn(arg));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify(data2, transport),
          refreshes: await serialize_refreshes(refreshes)
        }
      );
    }
    const payload = info3.type === "prerender" ? additional_args : (
      /** @type {string} */
      // new URL(...) necessary because we're hiding the URL from the user in the event object
      new URL(event.request.url).searchParams.get("payload")
    );
    const data = await with_request_store(
      { event, state: state2 },
      () => fn(parse_remote_arg(payload, transport))
    );
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "result",
        result: stringify(data, transport)
      }
    );
  } catch (error22) {
    if (error22 instanceof Redirect) {
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "redirect",
          location: error22.location,
          refreshes: await serialize_refreshes(form_client_refreshes ?? [])
        }
      );
    }
    const status = error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500;
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "error",
        error: await handle_error_and_jsonify(event, state2, options2, error22),
        status
      },
      {
        // By setting a non-200 during prerendering we fail the prerender process (unless handleHttpError handles it).
        // Errors at runtime will be passed to the client and are handled there
        status: state2.prerendering ? status : void 0,
        headers: {
          "cache-control": "private, no-store"
        }
      }
    );
  }
  async function serialize_refreshes(client_refreshes) {
    const refreshes = state2.refreshes ?? {};
    for (const key2 of client_refreshes) {
      if (refreshes[key2] !== void 0) continue;
      const [hash3, name2, payload] = key2.split("/");
      const loader = manifest2._.remotes[hash3];
      const fn2 = (await loader?.())?.default?.[name2];
      if (!fn2) error3(400, "Bad Request");
      refreshes[key2] = with_request_store(
        { event, state: state2 },
        () => fn2(parse_remote_arg(payload, transport))
      );
    }
    if (Object.keys(refreshes).length === 0) {
      return void 0;
    }
    return stringify(
      Object.fromEntries(
        await Promise.all(
          Object.entries(refreshes).map(async ([key2, promise]) => [key2, await promise])
        )
      ),
      transport
    );
  }
  __name(serialize_refreshes, "serialize_refreshes");
}
__name(handle_remote_call_internal, "handle_remote_call_internal");
async function handle_remote_form_post(event, state2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.form.post",
    attributes: {},
    fn: /* @__PURE__ */ __name((current2) => {
      const traced_event = merge_tracing(event, current2);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_form_post_internal(traced_event, state2, manifest2, id)
      );
    }, "fn")
  });
}
__name(handle_remote_form_post, "handle_remote_form_post");
async function handle_remote_form_post_internal(event, state2, manifest2, id) {
  const [hash2, name, action_id] = id.split("/");
  const remotes = manifest2._.remotes;
  const module = await remotes[hash2]?.();
  let form = (
    /** @type {RemoteForm<any, any>} */
    module?.default[name]
  );
  if (!form) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  if (action_id) {
    form = with_request_store({ event, state: state2 }, () => form.for(JSON.parse(action_id)));
  }
  try {
    const form_data = await event.request.formData();
    const fn = (
      /** @type {RemoteInfo & { type: 'form' }} */
      /** @type {any} */
      form.__.fn
    );
    if (action_id && !form_data.has("id")) {
      form_data.set("sveltekit:id", decodeURIComponent(action_id));
    }
    await with_request_store({ event, state: state2 }, () => fn(form_data));
    return {
      type: "success",
      status: 200
    };
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
__name(handle_remote_form_post_internal, "handle_remote_form_post_internal");
function get_remote_id(url) {
  return url.pathname.startsWith(`${base}/${app_dir}/remote/`) && url.pathname.replace(`${base}/${app_dir}/remote/`, "");
}
__name(get_remote_id, "get_remote_id");
function get_remote_action(url) {
  return url.searchParams.get("/remote");
}
__name(get_remote_action, "get_remote_action");
var MAX_DEPTH = 10;
async function render_page(event, event_state, page2, options2, manifest2, state2, nodes, resolve_opts) {
  if (state2.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, event_state, options2, node?.server);
  }
  try {
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.page()
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      const remote_id = get_remote_action(event.url);
      if (remote_id) {
        action_result = await handle_remote_form_post(event, event_state, manifest2, remote_id);
      } else {
        action_result = await handle_action_request(event, event_state, leaf_node.server);
      }
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender = nodes.prerender();
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state2.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state2.prerender_default = should_prerender;
    const should_prerender_data = nodes.should_prerender_data();
    const data_pathname = add_data_suffix2(event.url.pathname);
    const fetched = [];
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    if (ssr === false && !(state2.prerendering && should_prerender_data)) {
      if (BROWSER && action_result && !event.request.headers.has("x-sveltekit-action")) ;
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr
        },
        status,
        error: null,
        event,
        event_state,
        options: options2,
        manifest: manifest2,
        state: state2,
        resolve_opts,
        data_serializer: server_data_serializer(event, event_state, options2)
      });
    }
    const branch2 = [];
    let load_error = null;
    const data_serializer = server_data_serializer(event, event_state, options2);
    const data_serializer_json = state2.prerendering && should_prerender_data ? server_data_serializer_json(event, event_state, options2) : null;
    const server_promises = nodes.data.map((node, i) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          const server_data = await load_server_data({
            event,
            event_state,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                const parent = await server_promises[j];
                if (parent) Object.assign(data, parent.data);
              }
              return data;
            }, "parent")
          });
          if (node) {
            data_serializer.add_node(i, server_data);
          }
          data_serializer_json?.add_node(i, server_data);
          return server_data;
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const load_promises = nodes.data.map((node, i) => {
      if (load_error) throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            event_state,
            fetched,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                Object.assign(data, await load_promises[j]);
              }
              return data;
            }, "parent"),
            resolve_opts,
            server_data_promise: server_promises[i],
            state: state2,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p of server_promises) p.catch(() => {
    });
    for (const p of load_promises) p.catch(() => {
    });
    for (let i = 0; i < nodes.data.length; i += 1) {
      const node = nodes.data[i];
      if (node) {
        try {
          const server_data = await server_promises[i];
          const data = await load_promises[i];
          branch2.push({ node, server_data, data });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state2.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state2.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error22 = await handle_error_and_jsonify(event, event_state, options2, err);
          while (i--) {
            if (page2.errors[i]) {
              const index4 = (
                /** @type {number} */
                page2.errors[i]
              );
              const node2 = await manifest2._.nodes[index4]();
              let j = i;
              while (!branch2[j]) j -= 1;
              data_serializer.set_max_nodes(j + 1);
              const layouts = compact(branch2.slice(0, j + 1));
              const nodes2 = new PageNodes(layouts.map((layout) => layout.node));
              return await render_response({
                event,
                event_state,
                options: options2,
                manifest: manifest2,
                state: state2,
                resolve_opts,
                page_config: {
                  ssr: nodes2.ssr(),
                  csr: nodes2.csr()
                },
                status: status2,
                error: error22,
                branch: layouts.concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched,
                data_serializer
              });
            }
          }
          return static_error_page(options2, status2, error22.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state2.prerendering && data_serializer_json) {
      let { data, chunks } = data_serializer_json.get_data();
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state2.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    return await render_response({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      resolve_opts,
      page_config: {
        csr,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch2),
      action_result,
      fetched,
      data_serializer: ssr === false ? server_data_serializer(event, event_state, options2) : data_serializer
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
__name(render_page, "render_page");
function once2(fn) {
  let done = false;
  let result;
  return () => {
    if (done) return result;
    done = true;
    return result = fn();
  };
}
__name(once2, "once");
async function render_data(event, event_state, route, options2, manifest2, state2, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n2, i) => {
      return once2(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            event_state,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data2 = {};
              for (let j = 0; j < i; j += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }, "parent")
          });
        } catch (e3) {
          aborted = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i) => {
      if (!invalidated[i]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p, i) => p.catch(async (error22) => {
          if (error22 instanceof Redirect) {
            throw error22;
          }
          length = Math.min(length, i + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, event_state, options2, error22),
              status: error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : void 0
            }
          );
        })
      )
    );
    const data_serializer = server_data_serializer_json(event, event_state, options2);
    for (let i = 0; i < nodes.length; i++) data_serializer.add_node(i, nodes[i]);
    const { data, chunks } = data_serializer.get_data();
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller2) {
          controller2.enqueue(text_encoder2.encode(data));
          for await (const chunk of chunks) {
            controller2.enqueue(text_encoder2.encode(chunk));
          }
          controller2.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error22 = normalize_error(e3);
    if (error22 instanceof Redirect) {
      return redirect_json_response(error22);
    } else {
      return json_response(await handle_error_and_jsonify(event, event_state, options2, error22), 500);
    }
  }
}
__name(render_data, "render_data");
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
__name(json_response, "json_response");
function redirect_json_response(redirect) {
  return json_response(
    /** @type {import('types').ServerRedirectNode} */
    {
      type: "redirect",
      location: redirect.location
    }
  );
}
__name(redirect_json_response, "redirect_json_response");
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode;
  var index4 = 0;
  while (index4 < str.length) {
    var eqIdx = str.indexOf("=", index4);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index4);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index4 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str.slice(index4, eqIdx).trim();
    if (void 0 === obj[key2]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index4 = endIdx + 1;
  }
  return obj;
}
__name(parse$1, "parse$1");
function serialize(name, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
__name(serialize, "serialize");
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
__name(decode, "decode");
function encode(val) {
  return encodeURIComponent(val);
}
__name(encode, "encode");
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
__name(isDate, "isDate");
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e3) {
    return str;
  }
}
__name(tryDecode, "tryDecode");
var INVALID_COOKIE_CHARACTER_REGEX = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
__name(validate_options, "validate_options");
function generate_cookie_key(domain2, path, name) {
  return `${domain2 || ""}${path}?${encodeURIComponent(name)}`;
}
__name(generate_cookie_key, "generate_cookie_key");
function get_cookies(request, url) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = parse_1(header, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
  let normalized_url;
  const new_cookies = /* @__PURE__ */ new Map();
  const defaults = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    get(name, opts) {
      const best_match = Array.from(new_cookies.values()).filter((c2) => {
        return c2.name === name && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path);
      }).sort((a, b) => b.options.path.length - a.options.path.length)[0];
      if (best_match) {
        return best_match.options.maxAge === 0 ? void 0 : best_match.value;
      }
      const req_cookies = parse_1(header, { decode: opts?.decode });
      const cookie = req_cookies[name];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    getAll(opts) {
      const cookies2 = parse_1(header, { decode: opts?.decode });
      const lookup = /* @__PURE__ */ new Map();
      for (const c2 of new_cookies.values()) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          const existing = lookup.get(c2.name);
          if (!existing || c2.options.path.length > existing.options.path.length) {
            lookup.set(c2.name, c2);
          }
        }
      }
      for (const c2 of lookup.values()) {
        cookies2[c2.name] = c2.value;
      }
      return Object.entries(cookies2).map(([name, value]) => ({ name, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name, value, options2) {
      const illegal_characters = name.match(INVALID_COOKIE_CHARACTER_REGEX);
      if (illegal_characters) {
        console.warn(
          `The cookie name "${name}" will be invalid in SvelteKit 3.0 as it contains ${illegal_characters.join(
            " and "
          )}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`
        );
      }
      validate_options(options2);
      set_internal(name, value, { ...defaults, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name, options2) {
      validate_options(options2);
      cookies.set(name, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name, value, options2) {
      validate_options(options2);
      let path = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        if (!normalized_url) {
          throw new Error("Cannot serialize cookies until after the route is determined");
        }
        path = resolve(normalized_url, path);
      }
      return serialize_1(name, value, { ...defaults, ...options2, path });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const cookie of new_cookies.values()) {
      if (!domain_matches(destination.hostname, cookie.options.domain)) continue;
      if (!path_matches(destination.pathname, cookie.options.path)) continue;
      const encoder = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder(cookie.value);
    }
    if (header2) {
      const parsed = parse_1(header2, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
      for (const name in parsed) {
        combined_cookies[name] = parsed[name];
      }
    }
    return Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
  }
  __name(get_cookie_header, "get_cookie_header");
  const internal_queue = [];
  function set_internal(name, value, options2) {
    if (!normalized_url) {
      internal_queue.push(() => set_internal(name, value, options2));
      return;
    }
    let path = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path = resolve(normalized_url, path);
    }
    const cookie_key = generate_cookie_key(options2.domain, path, name);
    const cookie = { name, value, options: { ...options2, path } };
    new_cookies.set(cookie_key, cookie);
  }
  __name(set_internal, "set_internal");
  function set_trailing_slash(trailing_slash) {
    normalized_url = normalize_path(url.pathname, trailing_slash);
    internal_queue.forEach((fn) => fn());
  }
  __name(set_trailing_slash, "set_trailing_slash");
  return { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash };
}
__name(get_cookies, "get_cookies");
function domain_matches(hostname, constraint) {
  if (!constraint) return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized) return true;
  return hostname.endsWith("." + normalized);
}
__name(domain_matches, "domain_matches");
function path_matches(path, constraint) {
  if (!constraint) return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized) return true;
  return path.startsWith(normalized + "/");
}
__name(path_matches, "path_matches");
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", serialize_1(name, value, options2));
    if (options2.path.endsWith(".html")) {
      const path = add_data_suffix2(options2.path);
      headers2.append("set-cookie", serialize_1(name, value, { ...options2, path }));
    }
  }
}
__name(add_cookies_to_headers, "add_cookies_to_headers");
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
__name(isNonEmptyString, "isNonEmptyString");
function parseString(setCookieValue, options2) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name = parsed.name;
  var value = parsed.value;
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  try {
    value = options2.decodeValues ? decodeURIComponent(value) : value;
  } catch (e3) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
      e3
    );
  }
  var cookie = {
    name,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key2 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key2 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key2 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key2 === "secure") {
      cookie.secure = true;
    } else if (key2 === "httponly") {
      cookie.httpOnly = true;
    } else if (key2 === "samesite") {
      cookie.sameSite = value2;
    } else if (key2 === "partitioned") {
      cookie.partitioned = true;
    } else {
      cookie[key2] = value2;
    }
  });
  return cookie;
}
__name(parseString, "parseString");
function parseNameValuePair(nameValuePairStr) {
  var name = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name, value };
}
__name(parseNameValuePair, "parseNameValuePair");
function parse2(input, options2) {
  options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
  if (!input) {
    if (!options2.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      input = input.headers["set-cookie"];
    } else {
      var sch = input.headers[Object.keys(input.headers).find(function(key2) {
        return key2.toLowerCase() === "set-cookie";
      })];
      if (!sch && input.headers.cookie && !options2.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!options2.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options2);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options2);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
__name(parse2, "parse2");
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  __name(skipWhitespace, "skipWhitespace");
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  __name(notSpecialChar, "notSpecialChar");
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
__name(splitCookiesString, "splitCookiesString");
setCookie.exports = parse2;
setCookie.exports.parse = parse2;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function create_fetch({ event, options: options2, manifest: manifest2, state: state2, get_cookie_header, set_internal }) {
  const server_fetch = /* @__PURE__ */ __name(async (info3, init2) => {
    const original_request = normalize_fetch_input(info3, init2, event.url);
    let mode = (info3 instanceof Request ? info3.mode : init2?.mode) ?? "cors";
    let credentials = (info3 instanceof Request ? info3.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: /* @__PURE__ */ __name(async (info22, init3) => {
        const request = normalize_fetch_input(info22, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info22 !== original_request) {
          mode = (info22 instanceof Request ? info22.mode : init3?.mode) ?? "cors";
          credentials = (info22 instanceof Request ? info22.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie) request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename) || filename in manifest2._.server_assets;
        const is_asset_html = manifest2.assets.has(filename_html) || filename_html in manifest2._.server_assets;
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state2.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state2.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else if (read_implementation && file in manifest2._.server_assets) {
            const length = manifest2._.server_assets[file];
            const type = manifest2.mimeTypes[file.slice(file.lastIndexOf("."))];
            return new Response(read_implementation(file), {
              headers: {
                "Content-Length": "" + length,
                "Content-Type": type
              }
            });
          }
          return await fetch(request);
        }
        if (has_prerendered_path(manifest2, base + decoded)) {
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await internal_fetch(request, options2, manifest2, state2);
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of splitCookiesString_1(set_cookie)) {
            const { name, value, ...options3 } = parseString_1(str, {
              decodeValues: false
            });
            const path = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name, value, {
              path,
              encode: /* @__PURE__ */ __name((value2) => value2, "encode"),
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }, "fetch")
    });
  }, "server_fetch");
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_fetch, "create_fetch");
function normalize_fetch_input(info3, init2, url) {
  if (info3 instanceof Request) {
    return info3;
  }
  return new Request(typeof info3 === "string" ? new URL(info3, url) : info3, init2);
}
__name(normalize_fetch_input, "normalize_fetch_input");
async function internal_fetch(request, options2, manifest2, state2) {
  if (request.signal) {
    if (request.signal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    let remove_abort_listener = /* @__PURE__ */ __name(() => {
    }, "remove_abort_listener");
    const abort_promise = new Promise((_, reject) => {
      const on_abort = /* @__PURE__ */ __name(() => {
        reject(new DOMException("The operation was aborted.", "AbortError"));
      }, "on_abort");
      request.signal.addEventListener("abort", on_abort, { once: true });
      remove_abort_listener = /* @__PURE__ */ __name(() => request.signal.removeEventListener("abort", on_abort), "remove_abort_listener");
    });
    const result = await Promise.race([
      respond(request, options2, manifest2, {
        ...state2,
        depth: state2.depth + 1
      }),
      abort_promise
    ]);
    remove_abort_listener();
    return result;
  } else {
    return await respond(request, options2, manifest2, {
      ...state2,
      depth: state2.depth + 1
    });
  }
}
__name(internal_fetch, "internal_fetch");
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
__name(get_public_env, "get_public_env");
var default_transform = /* @__PURE__ */ __name(({ html }) => html, "default_transform");
var default_filter = /* @__PURE__ */ __name(() => false, "default_filter");
var default_preload = /* @__PURE__ */ __name(({ type }) => type === "js" || type === "css", "default_preload");
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var respond = propagate_context(internal_respond);
async function internal_respond(request, options2, manifest2, state2) {
  const url = new URL(request.url);
  const is_route_resolution_request = has_resolution_suffix2(url.pathname);
  const is_data_request = has_data_suffix2(url.pathname);
  const remote_id = get_remote_id(url);
  {
    const request_origin = request.headers.get("origin");
    if (remote_id) {
      if (request.method !== "GET" && request_origin !== url.origin) {
        const message = "Cross-site remote requests are forbidden";
        return json({ message }, { status: 403 });
      }
    } else if (options2.csrf_check_origin) {
      const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request_origin !== url.origin && (!request_origin || !options2.csrf_trusted_origins.includes(request_origin));
      if (forbidden) {
        const message = `Cross-site ${request.method} form submissions are forbidden`;
        const opts = { status: 403 };
        if (request.headers.get("accept") === "application/json") {
          return json({ message }, opts);
        }
        return text(message, opts);
      }
    }
  }
  if (options2.hash_routing && url.pathname !== base + "/" && url.pathname !== "/[fallback]") {
    return text("Not found", { status: 404 });
  }
  let invalidated_data_nodes;
  if (is_route_resolution_request) {
    url.pathname = strip_resolution_suffix2(url.pathname);
  } else if (is_data_request) {
    url.pathname = strip_data_suffix2(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  } else if (remote_id) {
    url.pathname = request.headers.get("x-sveltekit-pathname") ?? base;
    url.search = request.headers.get("x-sveltekit-search") ?? "";
  }
  const headers2 = {};
  const { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash } = get_cookies(
    request,
    url
  );
  const event_state = {
    prerendering: state2.prerendering,
    transport: options2.hooks.transport,
    handleValidationError: options2.hooks.handleValidationError,
    tracing: {
      record_span
    },
    is_in_remote_function: false
  };
  const event = {
    cookies,
    // @ts-expect-error `fetch` needs to be created after the `event` itself
    fetch: null,
    getClientAddress: state2.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params: {},
    platform: state2.platform,
    request,
    route: { id: null },
    setHeaders: /* @__PURE__ */ __name((new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state2.prerendering && lower === "cache-control") {
            state2.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    }, "setHeaders"),
    url,
    isDataRequest: is_data_request,
    isSubRequest: state2.depth > 0,
    isRemoteRequest: !!remote_id
  };
  event.fetch = create_fetch({
    event,
    options: options2,
    manifest: manifest2,
    state: state2,
    get_cookie_header,
    set_internal
  });
  if (state2.emulator?.platform) {
    event.platform = await state2.emulator.platform({
      config: {},
      prerender: !!state2.prerendering?.fallback
    });
  }
  let resolved_path = url.pathname;
  if (!remote_id) {
    const prerendering_reroute_state = state2.prerendering?.inside_reroute;
    try {
      if (state2.prerendering) state2.prerendering.inside_reroute = true;
      resolved_path = await options2.hooks.reroute({ url: new URL(url), fetch: event.fetch }) ?? url.pathname;
    } catch {
      return text("Internal Server Error", {
        status: 500
      });
    } finally {
      if (state2.prerendering) state2.prerendering.inside_reroute = prerendering_reroute_state;
    }
  }
  try {
    resolved_path = decode_pathname(resolved_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  if (resolved_path !== url.pathname && !state2.prerendering?.fallback && has_prerendered_path(manifest2, resolved_path)) {
    const url2 = new URL(request.url);
    url2.pathname = is_data_request ? add_data_suffix2(resolved_path) : is_route_resolution_request ? add_resolution_suffix2(resolved_path) : resolved_path;
    const response = await fetch(url2, request);
    const headers22 = new Headers(response.headers);
    if (headers22.has("content-encoding")) {
      headers22.delete("content-encoding");
      headers22.delete("content-length");
    }
    return new Response(response.body, {
      headers: headers22,
      status: response.status,
      statusText: response.statusText
    });
  }
  let route = null;
  if (base && !state2.prerendering?.fallback) {
    if (!resolved_path.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    resolved_path = resolved_path.slice(base.length) || "/";
  }
  if (is_route_resolution_request) {
    return resolve_route(resolved_path, new URL(request.url), manifest2);
  }
  if (resolved_path === `/${app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (!remote_id && resolved_path.startsWith(`/${app_dir}`)) {
    const headers22 = new Headers();
    headers22.set("cache-control", "public, max-age=0, must-revalidate");
    return text("Not found", { status: 404, headers: headers22 });
  }
  if (!state2.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(resolved_path);
      if (!match) continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        event.route = { id: route.id };
        event.params = decode_params(matched);
        break;
      }
    }
  }
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  let trailing_slash = "never";
  try {
    const page_nodes = route?.page ? new PageNodes(await load_page_nodes(route.page, manifest2)) : void 0;
    if (route && !remote_id) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (page_nodes) {
        if (BROWSER) ;
        trailing_slash = page_nodes.trailing_slash();
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash ?? "never";
        if (BROWSER) ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash);
        if (normalized !== url.pathname && !state2.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state2.before_handle || state2.emulator?.platform) {
        let config2 = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config2 = node.config ?? config2;
          prerender = node.prerender ?? prerender;
        } else if (page_nodes) {
          config2 = page_nodes.get_config() ?? config2;
          prerender = page_nodes.prerender();
        }
        if (state2.before_handle) {
          state2.before_handle(event, config2, prerender);
        }
        if (state2.emulator?.platform) {
          event.platform = await state2.emulator.platform({ config: config2, prerender });
        }
      }
    }
    set_trailing_slash(trailing_slash);
    if (state2.prerendering && !state2.prerendering.fallback && !state2.prerendering.inside_reroute) {
      disable_search(url);
    }
    const response = await record_span({
      name: "sveltekit.handle.root",
      attributes: {
        "http.route": event.route.id || "unknown",
        "http.method": event.request.method,
        "http.url": event.url.href,
        "sveltekit.is_data_request": is_data_request,
        "sveltekit.is_sub_request": event.isSubRequest
      },
      fn: /* @__PURE__ */ __name(async (root_span) => {
        const traced_event = {
          ...event,
          tracing: {
            enabled: false,
            root: root_span,
            current: root_span
          }
        };
        return await with_request_store(
          { event: traced_event, state: event_state },
          () => options2.hooks.handle({
            event: traced_event,
            resolve: /* @__PURE__ */ __name((event2, opts) => {
              return record_span({
                name: "sveltekit.resolve",
                attributes: {
                  "http.route": event2.route.id || "unknown"
                },
                fn: /* @__PURE__ */ __name((resolve_span) => {
                  return with_request_store(
                    null,
                    () => resolve2(merge_tracing(event2, resolve_span), page_nodes, opts).then(
                      (response2) => {
                        for (const key2 in headers2) {
                          const value = headers2[key2];
                          response2.headers.set(
                            key2,
                            /** @type {string} */
                            value
                          );
                        }
                        add_cookies_to_headers(response2.headers, new_cookies.values());
                        if (state2.prerendering && event2.route.id !== null) {
                          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
                        }
                        resolve_span.setAttributes({
                          "http.response.status_code": response2.status,
                          "http.response.body.size": response2.headers.get("content-length") || "unknown"
                        });
                        return response2;
                      }
                    )
                  );
                }, "fn")
              });
            }, "resolve")
          })
        );
      }, "fn")
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value) headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request || remote_id ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, new_cookies.values());
      return response;
    }
    return await handle_fatal_error(event, event_state, options2, e3);
  }
  async function resolve2(event2, page_nodes, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (options2.hash_routing || state2.prerendering?.fallback) {
        return await render_response({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts,
          data_serializer: server_data_serializer(event2, event_state, options2)
        });
      }
      if (remote_id) {
        return await handle_remote_call(event2, event_state, options2, manifest2, remote_id);
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response2;
        if (is_data_request) {
          response2 = await render_data(
            event2,
            event_state,
            route,
            options2,
            manifest2,
            state2,
            invalidated_data_nodes,
            trailing_slash
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response2 = await render_endpoint(event2, event_state, await route.endpoint(), state2);
        } else if (route.page) {
          if (!page_nodes) {
            throw new Error("page_nodes not found. This should never happen");
          } else if (page_methods.has(method)) {
            response2 = await render_page(
              event2,
              event_state,
              route.page,
              options2,
              manifest2,
              state2,
              page_nodes,
              resolve_opts
            );
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response2 = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response2 = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("Route is neither page nor endpoint. This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response2.headers.get("vary")?.split(",")?.map((v2) => v2.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response2 = new Response(response2.body, {
              status: response2.status,
              statusText: response2.statusText,
              headers: new Headers(response2.headers)
            });
            response2.headers.append("Vary", "Accept");
          }
        }
        return response2;
      }
      if (state2.error && event2.isSubRequest) {
        const headers22 = new Headers(request.headers);
        headers22.set("x-sveltekit-error", "true");
        return await fetch(request, { headers: headers22 });
      }
      if (state2.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state2.depth === 0) {
        if (BROWSER && event2.url.pathname === "/.well-known/appspecific/com.chrome.devtools.json") ;
        return await respond_with_error({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state2.prerendering) {
        return text("not found", { status: 404 });
      }
      const response = await fetch(request);
      return new Response(response.body, response);
    } catch (e3) {
      return await handle_fatal_error(event2, event_state, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
  __name(resolve2, "resolve2");
}
__name(internal_respond, "internal_respond");
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
__name(load_page_nodes, "load_page_nodes");
function propagate_context(fn) {
  return async (req, ...rest) => {
    {
      return fn(req, ...rest);
    }
  };
}
__name(propagate_context, "propagate_context");
function filter_env(env2, allowed, disallowed) {
  return Object.fromEntries(
    Object.entries(env2).filter(
      ([k]) => k.startsWith(allowed) && (disallowed === "" || !k.startsWith(disallowed))
    )
  );
}
__name(filter_env, "filter_env");
function set_app(value) {
}
__name(set_app, "set_app");
var init_promise;
var current = null;
var Server = class {
  static {
    __name(this, "Server");
  }
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
    if (IN_WEBCONTAINER2) {
      const respond2 = this.respond.bind(this);
      this.respond = async (...args) => {
        const { promise, resolve: resolve2 } = (
          /** @type {PromiseWithResolvers<void>} */
          with_resolvers()
        );
        const previous = current;
        current = promise;
        await previous;
        return respond2(...args).finally(resolve2);
      };
    }
  }
  /**
   * @param {import('@sveltejs/kit').ServerInitOptions} opts
   */
  async init({ env: env2, read }) {
    const { env_public_prefix, env_private_prefix } = this.#options;
    set_private_env(filter_env(env2, env_private_prefix, env_public_prefix));
    set_public_env(filter_env(env2, env_public_prefix, env_private_prefix));
    if (read) {
      const wrapped_read = /* @__PURE__ */ __name((file) => {
        const result = read(file);
        if (result instanceof ReadableStream) {
          return result;
        } else {
          return new ReadableStream({
            async start(controller2) {
              try {
                const stream = await Promise.resolve(result);
                if (!stream) {
                  controller2.close();
                  return;
                }
                const reader = stream.getReader();
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  controller2.enqueue(value);
                }
                controller2.close();
              } catch (error22) {
                controller2.error(error22);
              }
            }
          });
        }
      }, "wrapped_read");
      set_read_implementation(wrapped_read);
    }
    await (init_promise ??= (async () => {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ status, error: error22, event }) => {
            const error_message = format_server_error(
              status,
              /** @type {Error} */
              error22,
              event
            );
            console.error(error_message);
          }),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          handleValidationError: module.handleValidationError || (({ issues }) => {
            console.error("Remote function schema validation failed:", issues);
            return { message: "Bad Request" };
          }),
          reroute: module.reroute || (() => {
          }),
          transport: module.transport || {}
        };
        set_app({
          decoders: module.transport ? Object.fromEntries(Object.entries(module.transport).map(([k, v2]) => [k, v2.decode])) : {}
        });
        if (module.init) {
          await module.init();
        }
      } catch (e3) {
        {
          throw e3;
        }
      }
    })());
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  __name(__memo, "__memo");
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set([]),
    mimeTypes: {},
    _: {
      client: { start: "_app/immutable/entry/start.eCpOeaoY.js", app: "_app/immutable/entry/app.NGxsE6VI.js", imports: ["_app/immutable/entry/start.eCpOeaoY.js", "_app/immutable/chunks/C222IYg3.js", "_app/immutable/chunks/BuNyUiBZ.js", "_app/immutable/chunks/D4DQbwrw.js", "_app/immutable/entry/app.NGxsE6VI.js", "_app/immutable/chunks/D4DQbwrw.js", "_app/immutable/chunks/BuNyUiBZ.js", "_app/immutable/chunks/NZTpNUN0.js", "_app/immutable/chunks/8HJfsTjg.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3)))
      ],
      remotes: {},
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: /* @__PURE__ */ __name(async () => {
        return {};
      }, "matchers"),
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r3 = await e3.match(t2);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
__name(e, "e");
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r2(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
__name(t, "t");
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r2(e3) {
  if (!n.has(e3.status)) return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
__name(r2, "r2");
function o(n2) {
  return async function(r3, o2) {
    let a = await e(n2, r3);
    if (a) return a;
    o2.defer((e3) => {
      t(n2, r3, e3, o2);
    });
  };
}
__name(o, "o");
var s2 = caches.default;
var c = t.bind(0, s2);
var r22 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker = {
  async fetch(req, env2, context22) {
    await server.init({ env: env2 });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env2.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search) location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env: env2, context: context22, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context22) : res;
  }
};
var worker_default = worker;

// src/lib/security-headers.js
var SECURITY_HEADERS2 = {
  "Cross-Origin-Opener-Policy": "same-origin",
  "Cross-Origin-Embedder-Policy": "require-corp",
  "Cross-Origin-Resource-Policy": "same-origin",
  "Origin-Agent-Cluster": "?1"
};
var SECURITY_HEADER_ENTRIES2 = Object.entries(SECURITY_HEADERS2);

// ../test-wasm/subduction_wasm.js
var wasm;
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
__name(getUint8ArrayMemory0, "getUint8ArrayMemory0");
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var MAX_SAFARI_DECODE_BYTES = 2146435072;
var numBytesDecoded = 0;
function decodeText(ptr, len) {
  numBytesDecoded += len;
  if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
    cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    numBytesDecoded = len;
  }
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
__name(decodeText, "decodeText");
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return decodeText(ptr, len);
}
__name(getStringFromWasm0, "getStringFromWasm0");
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_2.set(idx, obj);
  return idx;
}
__name(addToExternrefTable0, "addToExternrefTable0");
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e3) {
    const idx = addToExternrefTable0(e3);
    wasm.__wbindgen_exn_store(idx);
  }
}
__name(handleError, "handleError");
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
__name(getArrayU8FromWasm0, "getArrayU8FromWasm0");
function isLikeNone(x) {
  return x === void 0 || x === null;
}
__name(isLikeNone, "isLikeNone");
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
__name(getDataViewMemory0, "getDataViewMemory0");
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug3 = "[";
    if (length > 0) {
      debug3 += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug3 += ", " + debugString(val[i]);
    }
    debug3 += "]";
    return debug3;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
__name(debugString, "debugString");
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder();
if (!("encodeInto" in cachedTextEncoder)) {
  cachedTextEncoder.encodeInto = function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = cachedTextEncoder.encodeInto(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
__name(passStringToWasm0, "passStringToWasm0");
var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (state2) => {
    wasm.__wbindgen_export_5.get(state2.dtor)(state2.a, state2.b);
  }
);
function makeMutClosure(arg0, arg1, dtor, f) {
  const state2 = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name((...args) => {
    state2.cnt++;
    const a = state2.a;
    state2.a = 0;
    try {
      return f(a, state2.b, ...args);
    } finally {
      if (--state2.cnt === 0) {
        wasm.__wbindgen_export_5.get(state2.dtor)(a, state2.b);
        CLOSURE_DTORS.unregister(state2);
      } else {
        state2.a = a;
      }
    }
  }, "real");
  real.original = state2;
  CLOSURE_DTORS.register(real, state2, state2);
  return real;
}
__name(makeMutClosure, "makeMutClosure");
function __wbg_adapter_14(arg0, arg1, arg2) {
  wasm.closure50_externref_shim(arg0, arg1, arg2);
}
__name(__wbg_adapter_14, "__wbg_adapter_14");
function __wbg_adapter_79(arg0, arg1, arg2, arg3) {
  wasm.closure96_externref_shim(arg0, arg1, arg2, arg3);
}
__name(__wbg_adapter_79, "__wbg_adapter_79");
var BeelayFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_beelay_free(ptr >>> 0, 1));
var Beelay = class _Beelay {
  static {
    __name(this, "Beelay");
  }
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Beelay.prototype);
    obj.__wbg_ptr = ptr;
    BeelayFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BeelayFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_beelay_free(ptr, 0);
  }
  /**
   * Mimics the original `Beelay.load` entrypoint and returns a handle to the runtime.
   * @param {any} _config
   * @returns {Promise<Beelay>}
   */
  static load(_config) {
    const ret = wasm.beelay_load(_config);
    return ret;
  }
  /**
   * Create a new document with the provided initial commit.
   * @param {any} args
   * @returns {Promise<any>}
   */
  createDoc(args) {
    const ret = wasm.beelay_createDoc(this.__wbg_ptr, args);
    return ret;
  }
  /**
   * Load all commits for a document.
   * @param {string} doc_id
   * @returns {Promise<any>}
   */
  loadDocument(doc_id) {
    const ptr0 = passStringToWasm0(doc_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.beelay_loadDocument(this.__wbg_ptr, ptr0, len0);
    return ret;
  }
  /**
   * Add commits produced by a client.
   * @param {any} args
   * @returns {Promise<any>}
   */
  addCommits(args) {
    const ret = wasm.beelay_addCommits(this.__wbg_ptr, args);
    return ret;
  }
  /**
   * Graceful shutdown.
   */
  stop() {
    wasm.beelay_stop(this.__wbg_ptr);
  }
  /**
   * Mock contact card support for compatibility with existing worker code.
   * @returns {string}
   */
  createContactCard() {
    let deferred1_0;
    let deferred1_1;
    try {
      const ret = wasm.beelay_createContactCard(this.__wbg_ptr);
      deferred1_0 = ret[0];
      deferred1_1 = ret[1];
      return getStringFromWasm0(ret[0], ret[1]);
    } finally {
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Wait until synced – no-op in the single-node WASM runtime.
   * @param {string} _peer_id
   * @returns {Promise<any>}
   */
  waitUntilSynced(_peer_id) {
    const ptr0 = passStringToWasm0(_peer_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.beelay_waitUntilSynced(this.__wbg_ptr, ptr0, len0);
    return ret;
  }
};
if (Symbol.dispose) Beelay.prototype[Symbol.dispose] = Beelay.prototype.free;
var MemorySignerFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_memorysigner_free(ptr >>> 0, 1));
var MemorySigner = class {
  static {
    __name(this, "MemorySigner");
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MemorySignerFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_memorysigner_free(ptr, 0);
  }
  constructor() {
    const ret = wasm.createMemoryStorageAdapter();
    this.__wbg_ptr = ret >>> 0;
    MemorySignerFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {Uint8Array}
   */
  verifyingKey() {
    const ret = wasm.memorysigner_verifyingKey(this.__wbg_ptr);
    return ret;
  }
  /**
   * @param {Uint8Array} message
   * @returns {Promise<Uint8Array>}
   */
  sign(message) {
    const ret = wasm.memorysigner_sign(this.__wbg_ptr, message);
    return ret;
  }
};
if (Symbol.dispose) MemorySigner.prototype[Symbol.dispose] = MemorySigner.prototype.free;
var MemoryStorageAdapterFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_memorystorageadapter_free(ptr >>> 0, 1));
var MemoryStorageAdapter = class _MemoryStorageAdapter {
  static {
    __name(this, "MemoryStorageAdapter");
  }
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_MemoryStorageAdapter.prototype);
    obj.__wbg_ptr = ptr;
    MemoryStorageAdapterFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MemoryStorageAdapterFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_memorystorageadapter_free(ptr, 0);
  }
  constructor() {
    const ret = wasm.createMemoryStorageAdapter();
    this.__wbg_ptr = ret >>> 0;
    MemoryStorageAdapterFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
};
if (Symbol.dispose) MemoryStorageAdapter.prototype[Symbol.dispose] = MemoryStorageAdapter.prototype.free;
var EXPECTED_RESPONSE_TYPES = /* @__PURE__ */ new Set(["basic", "cors", "default"]);
async function __wbg_load(module, imports4) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports4);
      } catch (e3) {
        const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);
        if (validResponse && module.headers.get("Content-Type") !== "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e3);
        } else {
          throw e3;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports4);
  } else {
    const instance = await WebAssembly.instantiate(module, imports4);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
__name(__wbg_load, "__wbg_load");
function __wbg_get_imports() {
  const imports4 = {};
  imports4.wbg = {};
  imports4.wbg.__wbg_Error_e17e777aac105295 = function(arg0, arg1) {
    const ret = Error(getStringFromWasm0(arg0, arg1));
    return ret;
  };
  imports4.wbg.__wbg_Number_998bea33bd87c3e0 = function(arg0) {
    const ret = Number(arg0);
    return ret;
  };
  imports4.wbg.__wbg_beelay_new = function(arg0) {
    const ret = Beelay.__wrap(arg0);
    return ret;
  };
  imports4.wbg.__wbg_call_13410aac570ffff7 = function() {
    return handleError(function(arg0, arg1) {
      const ret = arg0.call(arg1);
      return ret;
    }, arguments);
  };
  imports4.wbg.__wbg_call_a5400b25a865cfd8 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = arg0.call(arg1, arg2);
      return ret;
    }, arguments);
  };
  imports4.wbg.__wbg_done_75ed0ee6dd243d9d = function(arg0) {
    const ret = arg0.done;
    return ret;
  };
  imports4.wbg.__wbg_entries_2be2f15bd5554996 = function(arg0) {
    const ret = Object.entries(arg0);
    return ret;
  };
  imports4.wbg.__wbg_get_0da715ceaecea5c8 = function(arg0, arg1) {
    const ret = arg0[arg1 >>> 0];
    return ret;
  };
  imports4.wbg.__wbg_get_458e874b43b18b25 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(arg0, arg1);
      return ret;
    }, arguments);
  };
  imports4.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
    const ret = arg0[arg1];
    return ret;
  };
  imports4.wbg.__wbg_instanceof_ArrayBuffer_67f3012529f6a2dd = function(arg0) {
    let result;
    try {
      result = arg0 instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports4.wbg.__wbg_instanceof_Map_ebb01a5b6b5ffd0b = function(arg0) {
    let result;
    try {
      result = arg0 instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports4.wbg.__wbg_instanceof_Uint8Array_9a8378d955933db7 = function(arg0) {
    let result;
    try {
      result = arg0 instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports4.wbg.__wbg_isArray_030cce220591fb41 = function(arg0) {
    const ret = Array.isArray(arg0);
    return ret;
  };
  imports4.wbg.__wbg_isSafeInteger_1c0d1af5542e102a = function(arg0) {
    const ret = Number.isSafeInteger(arg0);
    return ret;
  };
  imports4.wbg.__wbg_iterator_f370b34483c71a1c = function() {
    const ret = Symbol.iterator;
    return ret;
  };
  imports4.wbg.__wbg_length_186546c51cd61acd = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports4.wbg.__wbg_length_6bb7e81f9d7713e4 = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports4.wbg.__wbg_new_19c25a3f2fa63a02 = function() {
    const ret = new Object();
    return ret;
  };
  imports4.wbg.__wbg_new_1f3a344cf3123716 = function() {
    const ret = new Array();
    return ret;
  };
  imports4.wbg.__wbg_new_2e3c58a15f39f5f9 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = /* @__PURE__ */ __name((arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_79(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      }, "cb0");
      const ret = new Promise(cb0);
      return ret;
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports4.wbg.__wbg_new_2ff1f68f3676ea53 = function() {
    const ret = /* @__PURE__ */ new Map();
    return ret;
  };
  imports4.wbg.__wbg_new_638ebfaedbf32a5e = function(arg0) {
    const ret = new Uint8Array(arg0);
    return ret;
  };
  imports4.wbg.__wbg_newnoargs_254190557c45b4ec = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return ret;
  };
  imports4.wbg.__wbg_newwithlength_a167dcc7aaa3ba77 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return ret;
  };
  imports4.wbg.__wbg_next_5b3530e612fde77d = function(arg0) {
    const ret = arg0.next;
    return ret;
  };
  imports4.wbg.__wbg_next_692e82279131b03c = function() {
    return handleError(function(arg0) {
      const ret = arg0.next();
      return ret;
    }, arguments);
  };
  imports4.wbg.__wbg_prototypesetcall_3d4a26c1ed734349 = function(arg0, arg1, arg2) {
    Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), arg2);
  };
  imports4.wbg.__wbg_queueMicrotask_25d0739ac89e8c88 = function(arg0) {
    queueMicrotask(arg0);
  };
  imports4.wbg.__wbg_queueMicrotask_4488407636f5bf24 = function(arg0) {
    const ret = arg0.queueMicrotask;
    return ret;
  };
  imports4.wbg.__wbg_random_7ed63a0b38ee3b75 = function() {
    const ret = Math.random();
    return ret;
  };
  imports4.wbg.__wbg_resolve_4055c623acdd6a1b = function(arg0) {
    const ret = Promise.resolve(arg0);
    return ret;
  };
  imports4.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    arg0[arg1] = arg2;
  };
  imports4.wbg.__wbg_set_90f6c0f7bd8c0415 = function(arg0, arg1, arg2) {
    arg0[arg1 >>> 0] = arg2;
  };
  imports4.wbg.__wbg_set_b7f1cf4fae26fe2a = function(arg0, arg1, arg2) {
    const ret = arg0.set(arg1, arg2);
    return ret;
  };
  imports4.wbg.__wbg_static_accessor_GLOBAL_8921f820c2ce3f12 = function() {
    const ret = typeof global === "undefined" ? null : global;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports4.wbg.__wbg_static_accessor_GLOBAL_THIS_f0a4409105898184 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports4.wbg.__wbg_static_accessor_SELF_995b214ae681ff99 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports4.wbg.__wbg_static_accessor_WINDOW_cde3890479c675ea = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
  };
  imports4.wbg.__wbg_then_e22500defe16819f = function(arg0, arg1) {
    const ret = arg0.then(arg1);
    return ret;
  };
  imports4.wbg.__wbg_value_dd9372230531eade = function(arg0) {
    const ret = arg0.value;
    return ret;
  };
  imports4.wbg.__wbg_wbindgenbigintgetasi64_ac743ece6ab9bba1 = function(arg0, arg1) {
    const v2 = arg1;
    const ret = typeof v2 === "bigint" ? v2 : void 0;
    getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports4.wbg.__wbg_wbindgenbooleanget_3fe6f642c7d97746 = function(arg0) {
    const v2 = arg0;
    const ret = typeof v2 === "boolean" ? v2 : void 0;
    return isLikeNone(ret) ? 16777215 : ret ? 1 : 0;
  };
  imports4.wbg.__wbg_wbindgencbdrop_eb10308566512b88 = function(arg0) {
    const obj = arg0.original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports4.wbg.__wbg_wbindgendebugstring_99ef257a3ddda34d = function(arg0, arg1) {
    const ret = debugString(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports4.wbg.__wbg_wbindgenin_d7a1ee10933d2d55 = function(arg0, arg1) {
    const ret = arg0 in arg1;
    return ret;
  };
  imports4.wbg.__wbg_wbindgenisbigint_ecb90cc08a5a9154 = function(arg0) {
    const ret = typeof arg0 === "bigint";
    return ret;
  };
  imports4.wbg.__wbg_wbindgenisfunction_8cee7dce3725ae74 = function(arg0) {
    const ret = typeof arg0 === "function";
    return ret;
  };
  imports4.wbg.__wbg_wbindgenisobject_307a53c6bd97fbf8 = function(arg0) {
    const val = arg0;
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports4.wbg.__wbg_wbindgenisstring_d4fa939789f003b0 = function(arg0) {
    const ret = typeof arg0 === "string";
    return ret;
  };
  imports4.wbg.__wbg_wbindgenisundefined_c4b71d073b92f3c5 = function(arg0) {
    const ret = arg0 === void 0;
    return ret;
  };
  imports4.wbg.__wbg_wbindgenjsvaleq_e6f2ad59ccae1b58 = function(arg0, arg1) {
    const ret = arg0 === arg1;
    return ret;
  };
  imports4.wbg.__wbg_wbindgenjsvallooseeq_9bec8c9be826bed1 = function(arg0, arg1) {
    const ret = arg0 == arg1;
    return ret;
  };
  imports4.wbg.__wbg_wbindgennumberget_f74b4c7525ac05cb = function(arg0, arg1) {
    const obj = arg1;
    const ret = typeof obj === "number" ? obj : void 0;
    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports4.wbg.__wbg_wbindgenstringget_0f16a6ddddef376f = function(arg0, arg1) {
    const obj = arg1;
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports4.wbg.__wbg_wbindgenthrow_451ec1a8469d7eb6 = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports4.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports4.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return ret;
  };
  imports4.wbg.__wbindgen_cast_9ae0607507abb057 = function(arg0) {
    const ret = arg0;
    return ret;
  };
  imports4.wbg.__wbindgen_cast_cfd578dc132ebaa8 = function(arg0, arg1) {
    const ret = makeMutClosure(arg0, arg1, 49, __wbg_adapter_14);
    return ret;
  };
  imports4.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {
    const ret = arg0;
    return ret;
  };
  imports4.wbg.__wbindgen_init_externref_table = function() {
    const table3 = wasm.__wbindgen_export_2;
    const offset = table3.grow(4);
    table3.set(0, void 0);
    table3.set(offset + 0, void 0);
    table3.set(offset + 1, null);
    table3.set(offset + 2, true);
    table3.set(offset + 3, false);
    ;
  };
  return imports4;
}
__name(__wbg_get_imports, "__wbg_get_imports");
function __wbg_init_memory(imports4, memory) {
}
__name(__wbg_init_memory, "__wbg_init_memory");
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
__name(__wbg_finalize_init, "__wbg_finalize_init");
function initSync(module) {
  if (wasm !== void 0) return wasm;
  if (typeof module !== "undefined") {
    if (Object.getPrototypeOf(module) === Object.prototype) {
      ({ module } = module);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports4 = __wbg_get_imports();
  __wbg_init_memory(imports4);
  if (!(module instanceof WebAssembly.Module)) {
    module = new WebAssembly.Module(module);
  }
  const instance = new WebAssembly.Instance(module, imports4);
  return __wbg_finalize_init(instance, module);
}
__name(initSync, "initSync");
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("subduction_wasm_bg.wasm", import.meta.url);
  }
  const imports4 = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  __wbg_init_memory(imports4);
  const { instance, module } = await __wbg_load(await module_or_path, imports4);
  return __wbg_finalize_init(instance, module);
}
__name(__wbg_init, "__wbg_init");
var subduction_wasm_default = __wbg_init;

// ../beelay-worker/worker.ts
import wasmModule from "./115b18dabd2e7b52e74ea5a43e73b9787d6af790-subduction_wasm_bg.wasm";

// ../capnweb/dist/index.js
if (!Symbol.dispose) {
  Symbol.dispose = Symbol.for("dispose");
}
if (!Symbol.asyncDispose) {
  Symbol.asyncDispose = Symbol.for("asyncDispose");
}
var workersModuleName2 = true ? "cloudflare:workers" : null;
var workersModule2;
if (workersModuleName2) {
  workersModule2 = await import(
    /* @vite-ignore */
    workersModuleName2
  );
}
var RpcTarget2 = workersModule2 ? workersModule2.RpcTarget : class {
};
function typeForRpc2(value) {
  switch (typeof value) {
    case "boolean":
    case "number":
    case "string":
      return "primitive";
    case "undefined":
      return "undefined";
    case "object":
    case "function":
      break;
    case "bigint":
      return "bigint";
    default:
      return "unsupported";
  }
  if (value === null) {
    return "primitive";
  }
  let prototype = Object.getPrototypeOf(value);
  switch (prototype) {
    case Object.prototype:
      return "object";
    case Function.prototype:
      return "function";
    case Array.prototype:
      return "array";
    case Date.prototype:
      return "date";
    case Uint8Array.prototype:
      return "bytes";
    // TODO: All other structured clone types.
    case RpcStub2.prototype:
      return "stub";
    case RpcPromise2.prototype:
      return "rpc-promise";
    // TODO: Promise<T> or thenable
    default:
      if (workersModule2) {
        if (prototype == workersModule2.RpcStub.prototype || value instanceof workersModule2.ServiceStub) {
          return "rpc-target";
        } else if (prototype == workersModule2.RpcPromise.prototype || prototype == workersModule2.RpcProperty.prototype) {
          return "rpc-thenable";
        }
      }
      if (value instanceof RpcTarget2) {
        return "rpc-target";
      }
      if (value instanceof Error) {
        return "error";
      }
      return "unsupported";
  }
}
__name(typeForRpc2, "typeForRpc");
function mapNotLoaded2() {
  throw new Error("RPC map() implementation was not loaded.");
}
__name(mapNotLoaded2, "mapNotLoaded");
var mapImpl2 = { applyMap: mapNotLoaded2, sendMap: mapNotLoaded2 };
var StubHook2 = class {
  static {
    __name(this, "StubHook");
  }
};
var ErrorStubHook2 = class extends StubHook2 {
  static {
    __name(this, "ErrorStubHook");
  }
  constructor(error4) {
    super();
    this.error = error4;
  }
  call(path, args) {
    return this;
  }
  map(path, captures, instructions) {
    return this;
  }
  get(path) {
    return this;
  }
  dup() {
    return this;
  }
  pull() {
    return Promise.reject(this.error);
  }
  ignoreUnhandledRejections() {
  }
  dispose() {
  }
  onBroken(callback) {
    try {
      callback(this.error);
    } catch (err) {
      Promise.resolve(err);
    }
  }
};
var DISPOSED_HOOK2 = new ErrorStubHook2(
  new Error("Attempted to use RPC stub after it has been disposed.")
);
var doCall2 = /* @__PURE__ */ __name((hook, path, params) => {
  return hook.call(path, params);
}, "doCall");
function withCallInterceptor2(interceptor, callback) {
  let oldValue = doCall2;
  doCall2 = interceptor;
  try {
    return callback();
  } finally {
    doCall2 = oldValue;
  }
}
__name(withCallInterceptor2, "withCallInterceptor");
var RAW_STUB2 = Symbol("realStub");
var PROXY_HANDLERS2 = {
  apply(target, thisArg, argumentsList) {
    let stub = target.raw;
    return new RpcPromise2(doCall2(
      stub.hook,
      stub.pathIfPromise || [],
      RpcPayload2.fromAppParams(argumentsList)
    ), []);
  },
  get(target, prop, receiver) {
    let stub = target.raw;
    if (prop === RAW_STUB2) {
      return stub;
    } else if (prop in RpcPromise2.prototype) {
      return stub[prop];
    } else if (typeof prop === "string") {
      return new RpcPromise2(
        stub.hook,
        stub.pathIfPromise ? [...stub.pathIfPromise, prop] : [prop]
      );
    } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {
      return () => {
        stub.hook.dispose();
        stub.hook = DISPOSED_HOOK2;
      };
    } else {
      return void 0;
    }
  },
  has(target, prop) {
    let stub = target.raw;
    if (prop === RAW_STUB2) {
      return true;
    } else if (prop in RpcPromise2.prototype) {
      return prop in stub;
    } else if (typeof prop === "string") {
      return true;
    } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {
      return true;
    } else {
      return false;
    }
  },
  construct(target, args) {
    throw new Error("An RPC stub cannot be used as a constructor.");
  },
  defineProperty(target, property, attributes2) {
    throw new Error("Can't define properties on RPC stubs.");
  },
  deleteProperty(target, p) {
    throw new Error("Can't delete properties on RPC stubs.");
  },
  getOwnPropertyDescriptor(target, p) {
    return void 0;
  },
  getPrototypeOf(target) {
    return Object.getPrototypeOf(target.raw);
  },
  isExtensible(target) {
    return false;
  },
  ownKeys(target) {
    return [];
  },
  preventExtensions(target) {
    return true;
  },
  set(target, p, newValue, receiver) {
    throw new Error("Can't assign properties on RPC stubs.");
  },
  setPrototypeOf(target, v2) {
    throw new Error("Can't override prototype of RPC stubs.");
  }
};
var RpcStub2 = class _RpcStub extends RpcTarget2 {
  static {
    __name(this, "_RpcStub");
  }
  // Although `hook` and `path` are declared `public` here, they are effectively hidden by the
  // proxy.
  constructor(hook, pathIfPromise) {
    super();
    if (!(hook instanceof StubHook2)) {
      let value = hook;
      if (value instanceof RpcTarget2 || value instanceof Function) {
        hook = TargetStubHook2.create(value, void 0);
      } else {
        hook = new PayloadStubHook2(RpcPayload2.fromAppReturn(value));
      }
      if (pathIfPromise) {
        throw new TypeError("RpcStub constructor expected one argument, received two.");
      }
    }
    this.hook = hook;
    this.pathIfPromise = pathIfPromise;
    let func = /* @__PURE__ */ __name(() => {
    }, "func");
    func.raw = this;
    return new Proxy(func, PROXY_HANDLERS2);
  }
  hook;
  pathIfPromise;
  dup() {
    let target = this[RAW_STUB2];
    if (target.pathIfPromise) {
      return new _RpcStub(target.hook.get(target.pathIfPromise));
    } else {
      return new _RpcStub(target.hook.dup());
    }
  }
  onRpcBroken(callback) {
    this[RAW_STUB2].hook.onBroken(callback);
  }
  map(func) {
    let { hook, pathIfPromise } = this[RAW_STUB2];
    return mapImpl2.sendMap(hook, pathIfPromise || [], func);
  }
};
var RpcPromise2 = class extends RpcStub2 {
  static {
    __name(this, "RpcPromise");
  }
  // TODO: Support passing target value or promise to constructor.
  constructor(hook, pathIfPromise) {
    super(hook, pathIfPromise);
  }
  then(onfulfilled, onrejected) {
    return pullPromise2(this).then(...arguments);
  }
  catch(onrejected) {
    return pullPromise2(this).catch(...arguments);
  }
  finally(onfinally) {
    return pullPromise2(this).finally(...arguments);
  }
};
function unwrapStubTakingOwnership2(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB2];
  if (pathIfPromise && pathIfPromise.length > 0) {
    return hook.get(pathIfPromise);
  } else {
    return hook;
  }
}
__name(unwrapStubTakingOwnership2, "unwrapStubTakingOwnership");
function unwrapStubAndDup2(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB2];
  if (pathIfPromise) {
    return hook.get(pathIfPromise);
  } else {
    return hook.dup();
  }
}
__name(unwrapStubAndDup2, "unwrapStubAndDup");
function unwrapStubNoProperties2(stub) {
  let { hook, pathIfPromise } = stub[RAW_STUB2];
  if (pathIfPromise && pathIfPromise.length > 0) {
    return void 0;
  }
  return hook;
}
__name(unwrapStubNoProperties2, "unwrapStubNoProperties");
function unwrapStubOrParent2(stub) {
  return stub[RAW_STUB2].hook;
}
__name(unwrapStubOrParent2, "unwrapStubOrParent");
function unwrapStubAndPath2(stub) {
  return stub[RAW_STUB2];
}
__name(unwrapStubAndPath2, "unwrapStubAndPath");
async function pullPromise2(promise) {
  let { hook, pathIfPromise } = promise[RAW_STUB2];
  if (pathIfPromise.length > 0) {
    hook = hook.get(pathIfPromise);
  }
  let payload = await hook.pull();
  return payload.deliverResolve();
}
__name(pullPromise2, "pullPromise");
var RpcPayload2 = class _RpcPayload {
  static {
    __name(this, "_RpcPayload");
  }
  // Private constructor; use factory functions above to construct.
  constructor(value, source2, stubs, promises) {
    this.value = value;
    this.source = source2;
    this.stubs = stubs;
    this.promises = promises;
  }
  // Create a payload from a value passed as params to an RPC from the app.
  //
  // The payload does NOT take ownership of any stubs in `value`, and but promises not to modify
  // `value`. If the payload is delivered locally, `value` will be deep-copied first, so as not
  // to have the sender and recipient end up sharing the same mutable object. `value` will not be
  // touched again after the call returns synchronously (returns a promise) -- by that point,
  // the value has either been copied or serialized to the wire.
  static fromAppParams(value) {
    return new _RpcPayload(value, "params");
  }
  // Create a payload from a value return from an RPC implementation by the app.
  //
  // Unlike fromAppParams(), in this case the payload takes ownership of all stubs in `value`, and
  // may hold onto `value` for an arbitrarily long time (e.g. to serve pipelined requests). It
  // will still avoid modifying `value` and will make a deep copy if it is delivered locally.
  static fromAppReturn(value) {
    return new _RpcPayload(value, "return");
  }
  // Combine an array of payloads into a single payload whose value is an array. Ownership of all
  // stubs is transferred from the inputs to the outputs, hence if the output is disposed, the
  // inputs should not be. (In case of exception, nothing is disposed, though.)
  static fromArray(array2) {
    let stubs = [];
    let promises = [];
    let resultArray = [];
    for (let payload of array2) {
      payload.ensureDeepCopied();
      for (let stub of payload.stubs) {
        stubs.push(stub);
      }
      for (let promise of payload.promises) {
        if (promise.parent === payload) {
          promise = {
            parent: resultArray,
            property: resultArray.length,
            promise: promise.promise
          };
        }
        promises.push(promise);
      }
      resultArray.push(payload.value);
    }
    return new _RpcPayload(resultArray, "owned", stubs, promises);
  }
  // Create a payload from a value parsed off the wire using Evaluator.evaluate().
  //
  // A payload is constructed with a null value and the given stubs and promises arrays. The value
  // is expected to be filled in by the evaluator, and the stubs and promises arrays are expected
  // to be extended with stubs found during parsing. (This weird usage model is necessary so that
  // if the root value turns out to be a promise, its `parent` in `promises` can be the payload
  // object itself.)
  //
  // When done, the payload takes ownership of the final value and all the stubs within. It may
  // modify the value in preparation for delivery, and may deliver the value directly to the app
  // without copying.
  static forEvaluate(stubs, promises) {
    return new _RpcPayload(null, "owned", stubs, promises);
  }
  // Deep-copy the given value, including dup()ing all stubs.
  //
  // If `value` is a function, it should be bound to `oldParent` as its `this`.
  //
  // If deep-copying from a branch of some other RpcPayload, it must be provided, to make sure
  // RpcTargets found within don't get duplicate stubs.
  static deepCopyFrom(value, oldParent, owner) {
    let result = new _RpcPayload(null, "owned", [], []);
    result.value = result.deepCopy(
      value,
      oldParent,
      "value",
      result,
      /*dupStubs=*/
      true,
      owner
    );
    return result;
  }
  // For `source === "return"` payloads only, this tracks any StubHooks created around RpcTargets
  // found in the payload at the time that it is serialized (or deep-copied) for return, so that we
  // can make sure they are not disposed before the pipeline ends.
  //
  // This is initialized on first use.
  rpcTargets;
  // Get the StubHook representing the given RpcTarget found inside this payload.
  getHookForRpcTarget(target, parent, dupStubs = true) {
    if (this.source === "params") {
      return TargetStubHook2.create(target, parent);
    } else if (this.source === "return") {
      let hook = this.rpcTargets?.get(target);
      if (hook) {
        if (dupStubs) {
          return hook.dup();
        } else {
          this.rpcTargets?.delete(target);
          return hook;
        }
      } else {
        hook = TargetStubHook2.create(target, parent);
        if (dupStubs) {
          if (!this.rpcTargets) {
            this.rpcTargets = /* @__PURE__ */ new Map();
          }
          this.rpcTargets.set(target, hook);
          return hook.dup();
        } else {
          return hook;
        }
      }
    } else {
      throw new Error("owned payload shouldn't contain raw RpcTargets");
    }
  }
  deepCopy(value, oldParent, property, parent, dupStubs, owner) {
    let kind = typeForRpc2(value);
    switch (kind) {
      case "unsupported":
        return value;
      case "primitive":
      case "bigint":
      case "date":
      case "bytes":
      case "error":
      case "undefined":
        return value;
      case "array": {
        let array2 = value;
        let len = array2.length;
        let result = new Array(len);
        for (let i = 0; i < len; i++) {
          result[i] = this.deepCopy(array2[i], array2, i, result, dupStubs, owner);
        }
        return result;
      }
      case "object": {
        let result = {};
        let object = value;
        for (let i in object) {
          result[i] = this.deepCopy(object[i], object, i, result, dupStubs, owner);
        }
        return result;
      }
      case "stub":
      case "rpc-promise": {
        let stub = value;
        let hook;
        if (dupStubs) {
          hook = unwrapStubAndDup2(stub);
        } else {
          hook = unwrapStubTakingOwnership2(stub);
        }
        if (stub instanceof RpcPromise2) {
          let promise = new RpcPromise2(hook, []);
          this.promises.push({ parent, property, promise });
          return promise;
        } else {
          let newStub = new RpcStub2(hook);
          this.stubs.push(newStub);
          return newStub;
        }
      }
      case "function":
      case "rpc-target": {
        let target = value;
        let stub;
        if (owner) {
          stub = new RpcStub2(owner.getHookForRpcTarget(target, oldParent, dupStubs));
        } else {
          stub = new RpcStub2(TargetStubHook2.create(target, oldParent));
        }
        this.stubs.push(stub);
        return stub;
      }
      case "rpc-thenable": {
        let target = value;
        let promise;
        if (owner) {
          promise = new RpcPromise2(owner.getHookForRpcTarget(target, oldParent, dupStubs), []);
        } else {
          promise = new RpcPromise2(TargetStubHook2.create(target, oldParent), []);
        }
        this.promises.push({ parent, property, promise });
        return promise;
      }
      default:
        throw new Error("unreachable");
    }
  }
  // Ensures that if the value originally came from an unowned source, we have replaced it with a
  // deep copy.
  ensureDeepCopied() {
    if (this.source !== "owned") {
      let dupStubs = this.source === "params";
      this.stubs = [];
      this.promises = [];
      try {
        this.value = this.deepCopy(this.value, void 0, "value", this, dupStubs, this);
      } catch (err) {
        this.stubs = void 0;
        this.promises = void 0;
        throw err;
      }
      this.source = "owned";
      if (this.rpcTargets && this.rpcTargets.size > 0) {
        throw new Error("Not all rpcTargets were accounted for in deep-copy?");
      }
      this.rpcTargets = void 0;
    }
  }
  // Resolve all promises in this payload and then assign the final value into `parent[property]`.
  deliverTo(parent, property, promises) {
    this.ensureDeepCopied();
    if (this.value instanceof RpcPromise2) {
      _RpcPayload.deliverRpcPromiseTo(this.value, parent, property, promises);
    } else {
      parent[property] = this.value;
      for (let record of this.promises) {
        _RpcPayload.deliverRpcPromiseTo(record.promise, record.parent, record.property, promises);
      }
    }
  }
  static deliverRpcPromiseTo(promise, parent, property, promises) {
    let hook = unwrapStubNoProperties2(promise);
    if (!hook) {
      throw new Error("property promises should have been resolved earlier");
    }
    let inner = hook.pull();
    if (inner instanceof _RpcPayload) {
      inner.deliverTo(parent, property, promises);
    } else {
      promises.push(inner.then((payload) => {
        let subPromises = [];
        payload.deliverTo(parent, property, subPromises);
        if (subPromises.length > 0) {
          return Promise.all(subPromises);
        }
      }));
    }
  }
  // Call the given function with the payload as an argument. The call is made synchronously if
  // possible, in order to maintain e-order. However, if any RpcPromises exist in the payload,
  // they are awaited and substituted before calling the function. The result of the call is
  // wrapped into another payload.
  //
  // The payload is automatically disposed after the call completes. The caller should not call
  // dispose().
  async deliverCall(func, thisArg) {
    try {
      let promises = [];
      this.deliverTo(this, "value", promises);
      if (promises.length > 0) {
        await Promise.all(promises);
      }
      let result = Function.prototype.apply.call(func, thisArg, this.value);
      if (result instanceof RpcPromise2) {
        return _RpcPayload.fromAppReturn(result);
      } else {
        return _RpcPayload.fromAppReturn(await result);
      }
    } finally {
      this.dispose();
    }
  }
  // Produce a promise for this payload for return to the application. Any RpcPromises in the
  // payload are awaited and substituted with their results first.
  //
  // The returned object will have a disposer which disposes the payload. The caller should not
  // separately dispose it.
  async deliverResolve() {
    try {
      let promises = [];
      this.deliverTo(this, "value", promises);
      if (promises.length > 0) {
        await Promise.all(promises);
      }
      let result = this.value;
      if (result instanceof Object) {
        if (!(Symbol.dispose in result)) {
          Object.defineProperty(result, Symbol.dispose, {
            // NOTE: Using `this.dispose.bind(this)` here causes Playwright's build of
            //   Chromium 140.0.7339.16 to fail when the object is assigned to a `using` variable,
            //   with the error:
            //       TypeError: Symbol(Symbol.dispose) is not a function
            //   I cannot reproduce this problem in Chrome 140.0.7339.127 nor in Node or workerd,
            //   so maybe it was a short-lived V8 bug or something. To be safe, though, we use
            //   `() => this.dispose()`, which seems to always work.
            value: /* @__PURE__ */ __name(() => this.dispose(), "value"),
            writable: true,
            enumerable: false,
            configurable: true
          });
        }
      }
      return result;
    } catch (err) {
      this.dispose();
      throw err;
    }
  }
  dispose() {
    if (this.source === "owned") {
      this.stubs.forEach((stub) => stub[Symbol.dispose]());
      this.promises.forEach((promise) => promise.promise[Symbol.dispose]());
    } else if (this.source === "return") {
      this.disposeImpl(this.value, void 0);
      if (this.rpcTargets && this.rpcTargets.size > 0) {
        throw new Error("Not all rpcTargets were accounted for in disposeImpl()?");
      }
    } else ;
    this.source = "owned";
    this.stubs = [];
    this.promises = [];
  }
  // Recursive dispose, called only when `source` is "return".
  disposeImpl(value, parent) {
    let kind = typeForRpc2(value);
    switch (kind) {
      case "unsupported":
      case "primitive":
      case "bigint":
      case "bytes":
      case "date":
      case "error":
      case "undefined":
        return;
      case "array": {
        let array2 = value;
        let len = array2.length;
        for (let i = 0; i < len; i++) {
          this.disposeImpl(array2[i], array2);
        }
        return;
      }
      case "object": {
        let object = value;
        for (let i in object) {
          this.disposeImpl(object[i], object);
        }
        return;
      }
      case "stub":
      case "rpc-promise": {
        let stub = value;
        let hook = unwrapStubNoProperties2(stub);
        if (hook) {
          hook.dispose();
        }
        return;
      }
      case "function":
      case "rpc-target": {
        let target = value;
        let hook = this.rpcTargets?.get(target);
        if (hook) {
          hook.dispose();
          this.rpcTargets.delete(target);
        } else {
          disposeRpcTarget2(target);
        }
        return;
      }
      case "rpc-thenable":
        return;
      default:
        return;
    }
  }
  // Ignore unhandled rejections in all promises in this payload -- that is, all promises that
  // *would* be awaited if this payload were to be delivered. See the similarly-named method of
  // StubHook for explanation.
  ignoreUnhandledRejections() {
    if (this.stubs) {
      this.stubs.forEach((stub) => {
        unwrapStubOrParent2(stub).ignoreUnhandledRejections();
      });
      this.promises.forEach(
        (promise) => unwrapStubOrParent2(promise.promise).ignoreUnhandledRejections()
      );
    } else {
      this.ignoreUnhandledRejectionsImpl(this.value);
    }
  }
  ignoreUnhandledRejectionsImpl(value) {
    let kind = typeForRpc2(value);
    switch (kind) {
      case "unsupported":
      case "primitive":
      case "bigint":
      case "bytes":
      case "date":
      case "error":
      case "undefined":
      case "function":
      case "rpc-target":
        return;
      case "array": {
        let array2 = value;
        let len = array2.length;
        for (let i = 0; i < len; i++) {
          this.ignoreUnhandledRejectionsImpl(array2[i]);
        }
        return;
      }
      case "object": {
        let object = value;
        for (let i in object) {
          this.ignoreUnhandledRejectionsImpl(object[i]);
        }
        return;
      }
      case "stub":
      case "rpc-promise":
        unwrapStubOrParent2(value).ignoreUnhandledRejections();
        return;
      case "rpc-thenable":
        value.then((_) => {
        }, (_) => {
        });
        return;
      default:
        return;
    }
  }
};
function followPath2(value, parent, path, owner) {
  for (let i = 0; i < path.length; i++) {
    parent = value;
    let part = path[i];
    if (part in Object.prototype) {
      value = void 0;
      continue;
    }
    let kind = typeForRpc2(value);
    switch (kind) {
      case "object":
      case "function":
        if (Object.hasOwn(value, part)) {
          value = value[part];
        } else {
          value = void 0;
        }
        break;
      case "array":
        if (Number.isInteger(part) && part >= 0) {
          value = value[part];
        } else {
          value = void 0;
        }
        break;
      case "rpc-target":
      case "rpc-thenable": {
        if (Object.hasOwn(value, part)) {
          value = void 0;
        } else {
          value = value[part];
        }
        owner = null;
        break;
      }
      case "stub":
      case "rpc-promise": {
        let { hook, pathIfPromise } = unwrapStubAndPath2(value);
        return { hook, remainingPath: pathIfPromise ? pathIfPromise.concat(path.slice(i)) : path.slice(i) };
      }
      case "primitive":
      case "bigint":
      case "bytes":
      case "date":
      case "error":
        value = void 0;
        break;
      case "undefined":
        value = value[part];
        break;
      case "unsupported": {
        if (i === 0) {
          throw new TypeError(`RPC stub points at a non-serializable type.`);
        } else {
          let prefix = path.slice(0, i).join(".");
          let remainder = path.slice(0, i).join(".");
          throw new TypeError(
            `'${prefix}' is not a serializable type, so property ${remainder} cannot be accessed.`
          );
        }
      }
      default:
        throw new TypeError("unreachable");
    }
  }
  if (value instanceof RpcPromise2) {
    let { hook, pathIfPromise } = unwrapStubAndPath2(value);
    return { hook, remainingPath: pathIfPromise || [] };
  }
  return {
    value,
    parent,
    owner
  };
}
__name(followPath2, "followPath");
var ValueStubHook2 = class extends StubHook2 {
  static {
    __name(this, "ValueStubHook");
  }
  call(path, args) {
    try {
      let { value, owner } = this.getValue();
      let followResult = followPath2(value, void 0, path, owner);
      if (followResult.hook) {
        return followResult.hook.call(followResult.remainingPath, args);
      }
      if (typeof followResult.value != "function") {
        throw new TypeError(`'${path.join(".")}' is not a function.`);
      }
      let promise = args.deliverCall(followResult.value, followResult.parent);
      return new PromiseStubHook2(promise.then((payload) => {
        return new PayloadStubHook2(payload);
      }));
    } catch (err) {
      return new ErrorStubHook2(err);
    }
  }
  map(path, captures, instructions) {
    try {
      let followResult;
      try {
        let { value, owner } = this.getValue();
        followResult = followPath2(value, void 0, path, owner);
        ;
      } catch (err) {
        for (let cap of captures) {
          cap.dispose();
        }
        throw err;
      }
      if (followResult.hook) {
        return followResult.hook.map(followResult.remainingPath, captures, instructions);
      }
      return mapImpl2.applyMap(
        followResult.value,
        followResult.parent,
        followResult.owner,
        captures,
        instructions
      );
    } catch (err) {
      return new ErrorStubHook2(err);
    }
  }
  get(path) {
    try {
      let { value, owner } = this.getValue();
      if (path.length === 0 && owner === null) {
        throw new Error("Can't dup an RpcTarget stub as a promise.");
      }
      let followResult = followPath2(value, void 0, path, owner);
      if (followResult.hook) {
        return followResult.hook.get(followResult.remainingPath);
      }
      return new PayloadStubHook2(RpcPayload2.deepCopyFrom(
        followResult.value,
        followResult.parent,
        followResult.owner
      ));
    } catch (err) {
      return new ErrorStubHook2(err);
    }
  }
};
var PayloadStubHook2 = class _PayloadStubHook extends ValueStubHook2 {
  static {
    __name(this, "_PayloadStubHook");
  }
  constructor(payload) {
    super();
    this.payload = payload;
  }
  payload;
  // cleared when disposed
  getPayload() {
    if (this.payload) {
      return this.payload;
    } else {
      throw new Error("Attempted to use an RPC StubHook after it was disposed.");
    }
  }
  getValue() {
    let payload = this.getPayload();
    return { value: payload.value, owner: payload };
  }
  dup() {
    let thisPayload = this.getPayload();
    return new _PayloadStubHook(RpcPayload2.deepCopyFrom(
      thisPayload.value,
      void 0,
      thisPayload
    ));
  }
  pull() {
    return this.getPayload();
  }
  ignoreUnhandledRejections() {
    if (this.payload) {
      this.payload.ignoreUnhandledRejections();
    }
  }
  dispose() {
    if (this.payload) {
      this.payload.dispose();
      this.payload = void 0;
    }
  }
  onBroken(callback) {
    if (this.payload) {
      if (this.payload.value instanceof RpcStub2) {
        this.payload.value.onRpcBroken(callback);
      }
    }
  }
};
function disposeRpcTarget2(target) {
  if (Symbol.dispose in target) {
    try {
      target[Symbol.dispose]();
    } catch (err) {
      Promise.reject(err);
    }
  }
}
__name(disposeRpcTarget2, "disposeRpcTarget");
var TargetStubHook2 = class _TargetStubHook extends ValueStubHook2 {
  static {
    __name(this, "_TargetStubHook");
  }
  // Constructs a TargetStubHook that is not duplicated from an existing hook.
  //
  // If `value` is a function, `parent` is bound as its "this".
  static create(value, parent) {
    if (typeof value !== "function") {
      parent = void 0;
    }
    return new _TargetStubHook(value, parent);
  }
  constructor(target, parent, dupFrom) {
    super();
    this.target = target;
    this.parent = parent;
    if (dupFrom) {
      if (dupFrom.refcount) {
        this.refcount = dupFrom.refcount;
        ++this.refcount.count;
      }
    } else if (Symbol.dispose in target) {
      this.refcount = { count: 1 };
    }
  }
  target;
  // cleared when disposed
  parent;
  // `this` parameter when calling `target`
  refcount;
  // undefined if not needed (because target has no disposer)
  getTarget() {
    if (this.target) {
      return this.target;
    } else {
      throw new Error("Attempted to use an RPC StubHook after it was disposed.");
    }
  }
  getValue() {
    return { value: this.getTarget(), owner: null };
  }
  dup() {
    return new _TargetStubHook(this.getTarget(), this.parent, this);
  }
  pull() {
    let target = this.getTarget();
    if ("then" in target) {
      return Promise.resolve(target).then((resolution) => {
        return RpcPayload2.fromAppReturn(resolution);
      });
    } else {
      return Promise.reject(new Error("Tried to resolve a non-promise stub."));
    }
  }
  ignoreUnhandledRejections() {
  }
  dispose() {
    if (this.target) {
      if (this.refcount) {
        if (--this.refcount.count == 0) {
          disposeRpcTarget2(this.target);
        }
      }
      this.target = void 0;
    }
  }
  onBroken(callback) {
  }
};
var PromiseStubHook2 = class _PromiseStubHook extends StubHook2 {
  static {
    __name(this, "_PromiseStubHook");
  }
  promise;
  resolution;
  constructor(promise) {
    super();
    this.promise = promise.then((res) => {
      this.resolution = res;
      return res;
    });
  }
  call(path, args) {
    args.ensureDeepCopied();
    return new _PromiseStubHook(this.promise.then((hook) => hook.call(path, args)));
  }
  map(path, captures, instructions) {
    return new _PromiseStubHook(this.promise.then(
      (hook) => hook.map(path, captures, instructions),
      (err) => {
        for (let cap of captures) {
          cap.dispose();
        }
        throw err;
      }
    ));
  }
  get(path) {
    return new _PromiseStubHook(this.promise.then((hook) => hook.get(path)));
  }
  dup() {
    if (this.resolution) {
      return this.resolution.dup();
    } else {
      return new _PromiseStubHook(this.promise.then((hook) => hook.dup()));
    }
  }
  pull() {
    if (this.resolution) {
      return this.resolution.pull();
    } else {
      return this.promise.then((hook) => hook.pull());
    }
  }
  ignoreUnhandledRejections() {
    if (this.resolution) {
      this.resolution.ignoreUnhandledRejections();
    } else {
      this.promise.then((res) => {
        res.ignoreUnhandledRejections();
      }, (err) => {
      });
    }
  }
  dispose() {
    if (this.resolution) {
      this.resolution.dispose();
    } else {
      this.promise.then((hook) => {
        hook.dispose();
      }, (err) => {
      });
    }
  }
  onBroken(callback) {
    if (this.resolution) {
      this.resolution.onBroken(callback);
    } else {
      this.promise.then((hook) => {
        hook.onBroken(callback);
      }, callback);
    }
  }
};
var NullExporter2 = class {
  static {
    __name(this, "NullExporter");
  }
  exportStub(stub) {
    throw new Error("Cannot serialize RPC stubs without an RPC session.");
  }
  exportPromise(stub) {
    throw new Error("Cannot serialize RPC stubs without an RPC session.");
  }
  getImport(hook) {
    return void 0;
  }
  unexport(ids) {
  }
  onSendError(error4) {
  }
};
var NULL_EXPORTER2 = new NullExporter2();
var ERROR_TYPES2 = {
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError
  // TODO: DOMError? Others?
};
var Devaluator2 = class _Devaluator {
  static {
    __name(this, "_Devaluator");
  }
  constructor(exporter, source2) {
    this.exporter = exporter;
    this.source = source2;
  }
  // Devaluate the given value.
  // * value: The value to devaluate.
  // * parent: The value's parent object, which would be used as `this` if the value were called
  //     as a function.
  // * exporter: Callbacks to the RPC session for exporting capabilities found in this message.
  // * source: The RpcPayload which contains the value, and therefore owns stubs within.
  //
  // Returns: The devaluated value, ready to be JSON-serialized.
  static devaluate(value, parent, exporter = NULL_EXPORTER2, source2) {
    let devaluator = new _Devaluator(exporter, source2);
    try {
      return devaluator.devaluateImpl(value, parent, 0);
    } catch (err) {
      if (devaluator.exports) {
        try {
          exporter.unexport(devaluator.exports);
        } catch (err2) {
        }
      }
      throw err;
    }
  }
  exports;
  devaluateImpl(value, parent, depth) {
    if (depth >= 64) {
      throw new Error(
        "Serialization exceeded maximum allowed depth. (Does the message contain cycles?)"
      );
    }
    let kind = typeForRpc2(value);
    switch (kind) {
      case "unsupported": {
        let msg;
        try {
          msg = `Cannot serialize value: ${value}`;
        } catch (err) {
          msg = "Cannot serialize value: (couldn't stringify value)";
        }
        throw new TypeError(msg);
      }
      case "primitive":
        return value;
      case "object": {
        let object = value;
        let result = {};
        for (let key2 in object) {
          result[key2] = this.devaluateImpl(object[key2], object, depth + 1);
        }
        return result;
      }
      case "array": {
        let array2 = value;
        let len = array2.length;
        let result = new Array(len);
        for (let i = 0; i < len; i++) {
          result[i] = this.devaluateImpl(array2[i], array2, depth + 1);
        }
        return [result];
      }
      case "bigint":
        return ["bigint", value.toString()];
      case "date":
        return ["date", value.getTime()];
      case "bytes": {
        let bytes = value;
        if (bytes.toBase64) {
          return ["bytes", bytes.toBase64({ omitPadding: true })];
        } else {
          return [
            "bytes",
            btoa(String.fromCharCode.apply(null, bytes).replace(/=*$/, ""))
          ];
        }
      }
      case "error": {
        let e3 = value;
        let rewritten = this.exporter.onSendError(e3);
        if (rewritten) {
          e3 = rewritten;
        }
        let result = ["error", e3.name, e3.message];
        if (rewritten && rewritten.stack) {
          result.push(rewritten.stack);
        }
        return result;
      }
      case "undefined":
        return ["undefined"];
      case "stub":
      case "rpc-promise": {
        if (!this.source) {
          throw new Error("Can't serialize RPC stubs in this context.");
        }
        let { hook, pathIfPromise } = unwrapStubAndPath2(value);
        let importId = this.exporter.getImport(hook);
        if (importId !== void 0) {
          if (pathIfPromise) {
            if (pathIfPromise.length > 0) {
              return ["pipeline", importId, pathIfPromise];
            } else {
              return ["pipeline", importId];
            }
          } else {
            return ["import", importId];
          }
        }
        if (pathIfPromise) {
          hook = hook.get(pathIfPromise);
        } else {
          hook = hook.dup();
        }
        return this.devaluateHook(pathIfPromise ? "promise" : "export", hook);
      }
      case "function":
      case "rpc-target": {
        if (!this.source) {
          throw new Error("Can't serialize RPC stubs in this context.");
        }
        let hook = this.source.getHookForRpcTarget(value, parent);
        return this.devaluateHook("export", hook);
      }
      case "rpc-thenable": {
        if (!this.source) {
          throw new Error("Can't serialize RPC stubs in this context.");
        }
        let hook = this.source.getHookForRpcTarget(value, parent);
        return this.devaluateHook("promise", hook);
      }
      default:
        throw new Error("unreachable");
    }
  }
  devaluateHook(type, hook) {
    if (!this.exports) this.exports = [];
    let exportId = type === "promise" ? this.exporter.exportPromise(hook) : this.exporter.exportStub(hook);
    this.exports.push(exportId);
    return [type, exportId];
  }
};
var NullImporter2 = class {
  static {
    __name(this, "NullImporter");
  }
  importStub(idx) {
    throw new Error("Cannot deserialize RPC stubs without an RPC session.");
  }
  importPromise(idx) {
    throw new Error("Cannot deserialize RPC stubs without an RPC session.");
  }
  getExport(idx) {
    return void 0;
  }
};
var NULL_IMPORTER2 = new NullImporter2();
var Evaluator2 = class _Evaluator {
  static {
    __name(this, "_Evaluator");
  }
  constructor(importer) {
    this.importer = importer;
  }
  stubs = [];
  promises = [];
  evaluate(value) {
    let payload = RpcPayload2.forEvaluate(this.stubs, this.promises);
    try {
      payload.value = this.evaluateImpl(value, payload, "value");
      return payload;
    } catch (err) {
      payload.dispose();
      throw err;
    }
  }
  // Evaluate the value without destroying it.
  evaluateCopy(value) {
    return this.evaluate(structuredClone(value));
  }
  evaluateImpl(value, parent, property) {
    if (value instanceof Array) {
      if (value.length == 1 && value[0] instanceof Array) {
        let result = value[0];
        for (let i = 0; i < result.length; i++) {
          result[i] = this.evaluateImpl(result[i], result, i);
        }
        return result;
      } else switch (value[0]) {
        case "bigint":
          if (typeof value[1] == "string") {
            return BigInt(value[1]);
          }
          break;
        case "date":
          if (typeof value[1] == "number") {
            return new Date(value[1]);
          }
          break;
        case "bytes": {
          let b64 = Uint8Array;
          if (typeof value[1] == "string") {
            if (b64.fromBase64) {
              return b64.fromBase64(value[1]);
            } else {
              let bs = atob(value[1]);
              let len = bs.length;
              let bytes = new Uint8Array(len);
              for (let i = 0; i < len; i++) {
                bytes[i] = bs.charCodeAt(i);
              }
              return bytes;
            }
          }
          break;
        }
        case "error":
          if (value.length >= 3 && typeof value[1] === "string" && typeof value[2] === "string") {
            let cls = ERROR_TYPES2[value[1]] || Error;
            let result = new cls(value[2]);
            if (typeof value[3] === "string") {
              result.stack = value[3];
            }
            return result;
          }
          break;
        case "undefined":
          if (value.length === 1) {
            return void 0;
          }
          break;
        case "import":
        case "pipeline": {
          if (value.length < 2 || value.length > 4) {
            break;
          }
          if (typeof value[1] != "number") {
            break;
          }
          let hook = this.importer.getExport(value[1]);
          if (!hook) {
            throw new Error(`no such entry on exports table: ${value[1]}`);
          }
          let isPromise = value[0] == "pipeline";
          let addStub = /* @__PURE__ */ __name((hook2) => {
            if (isPromise) {
              let promise = new RpcPromise2(hook2, []);
              this.promises.push({ promise, parent, property });
              return promise;
            } else {
              let stub = new RpcPromise2(hook2, []);
              this.stubs.push(stub);
              return stub;
            }
          }, "addStub");
          if (value.length == 2) {
            if (isPromise) {
              return addStub(hook.get([]));
            } else {
              return addStub(hook.dup());
            }
          }
          let path = value[2];
          if (!(path instanceof Array)) {
            break;
          }
          if (!path.every(
            (part) => {
              return typeof part == "string" || typeof part == "number";
            }
          )) {
            break;
          }
          if (value.length == 3) {
            return addStub(hook.get(path));
          }
          let args = value[3];
          if (!(args instanceof Array)) {
            break;
          }
          let subEval = new _Evaluator(this.importer);
          args = subEval.evaluate([args]);
          return addStub(hook.call(path, args));
        }
        case "remap": {
          if (value.length !== 5 || typeof value[1] !== "number" || !(value[2] instanceof Array) || !(value[3] instanceof Array) || !(value[4] instanceof Array)) {
            break;
          }
          let hook = this.importer.getExport(value[1]);
          if (!hook) {
            throw new Error(`no such entry on exports table: ${value[1]}`);
          }
          let path = value[2];
          if (!path.every(
            (part) => {
              return typeof part == "string" || typeof part == "number";
            }
          )) {
            break;
          }
          let captures = value[3].map((cap) => {
            if (!(cap instanceof Array) || cap.length !== 2 || cap[0] !== "import" && cap[0] !== "export" || typeof cap[1] !== "number") {
              throw new TypeError(`unknown map capture: ${JSON.stringify(cap)}`);
            }
            if (cap[0] === "export") {
              return this.importer.importStub(cap[1]);
            } else {
              let exp = this.importer.getExport(cap[1]);
              if (!exp) {
                throw new Error(`no such entry on exports table: ${cap[1]}`);
              }
              return exp.dup();
            }
          });
          let instructions = value[4];
          let resultHook = hook.map(path, captures, instructions);
          let promise = new RpcPromise2(resultHook, []);
          this.promises.push({ promise, parent, property });
          return promise;
        }
        case "export":
        case "promise":
          if (typeof value[1] == "number") {
            if (value[0] == "promise") {
              let hook = this.importer.importPromise(value[1]);
              let promise = new RpcPromise2(hook, []);
              this.promises.push({ parent, property, promise });
              return promise;
            } else {
              let hook = this.importer.importStub(value[1]);
              let stub = new RpcStub2(hook);
              this.stubs.push(stub);
              return stub;
            }
          }
          break;
      }
      throw new TypeError(`unknown special value: ${JSON.stringify(value)}`);
    } else if (value instanceof Object) {
      let result = value;
      for (let key2 in result) {
        if (key2 in Object.prototype || key2 === "toJSON") {
          this.evaluateImpl(result[key2], result, key2);
          delete result[key2];
        } else {
          result[key2] = this.evaluateImpl(result[key2], result, key2);
        }
      }
      return result;
    } else {
      return value;
    }
  }
};
var ImportTableEntry = class {
  static {
    __name(this, "ImportTableEntry");
  }
  constructor(session, importId, pulling) {
    this.session = session;
    this.importId = importId;
    if (pulling) {
      this.activePull = Promise.withResolvers();
    }
  }
  localRefcount = 0;
  remoteRefcount = 1;
  activePull;
  resolution;
  // List of integer indexes into session.onBrokenCallbacks which are callbacks registered on
  // this import. Initialized on first use (so `undefined` is the same as an empty list).
  onBrokenRegistrations;
  resolve(resolution) {
    if (this.localRefcount == 0) {
      resolution.dispose();
      return;
    }
    this.resolution = resolution;
    this.sendRelease();
    if (this.onBrokenRegistrations) {
      for (let i of this.onBrokenRegistrations) {
        let callback = this.session.onBrokenCallbacks[i];
        let endIndex = this.session.onBrokenCallbacks.length;
        resolution.onBroken(callback);
        if (this.session.onBrokenCallbacks[endIndex] === callback) {
          delete this.session.onBrokenCallbacks[endIndex];
        } else {
          delete this.session.onBrokenCallbacks[i];
        }
      }
      this.onBrokenRegistrations = void 0;
    }
    if (this.activePull) {
      this.activePull.resolve();
      this.activePull = void 0;
    }
  }
  async awaitResolution() {
    if (!this.activePull) {
      this.session.sendPull(this.importId);
      this.activePull = Promise.withResolvers();
    }
    await this.activePull.promise;
    return this.resolution.pull();
  }
  dispose() {
    if (this.resolution) {
      this.resolution.dispose();
    } else {
      this.abort(new Error("RPC was canceled because the RpcPromise was disposed."));
      this.sendRelease();
    }
  }
  abort(error4) {
    if (!this.resolution) {
      this.resolution = new ErrorStubHook2(error4);
      if (this.activePull) {
        this.activePull.reject(error4);
        this.activePull = void 0;
      }
      this.onBrokenRegistrations = void 0;
    }
  }
  onBroken(callback) {
    if (this.resolution) {
      this.resolution.onBroken(callback);
    } else {
      let index4 = this.session.onBrokenCallbacks.length;
      this.session.onBrokenCallbacks.push(callback);
      if (!this.onBrokenRegistrations) this.onBrokenRegistrations = [];
      this.onBrokenRegistrations.push(index4);
    }
  }
  sendRelease() {
    if (this.remoteRefcount > 0) {
      this.session.sendRelease(this.importId, this.remoteRefcount);
      this.remoteRefcount = 0;
    }
  }
};
var RpcImportHook = class _RpcImportHook extends StubHook2 {
  static {
    __name(this, "_RpcImportHook");
  }
  // undefined when we're disposed
  // `pulling` is true if we already expect that this import is going to be resolved later, and
  // null if this import is not allowed to be pulled (i.e. it's a stub not a promise).
  constructor(isPromise, entry) {
    super();
    this.isPromise = isPromise;
    ++entry.localRefcount;
    this.entry = entry;
  }
  entry;
  collectPath(path) {
    return this;
  }
  getEntry() {
    if (this.entry) {
      return this.entry;
    } else {
      throw new Error("This RpcImportHook was already disposed.");
    }
  }
  // -------------------------------------------------------------------------------------
  // implements StubHook
  call(path, args) {
    let entry = this.getEntry();
    if (entry.resolution) {
      return entry.resolution.call(path, args);
    } else {
      return entry.session.sendCall(entry.importId, path, args);
    }
  }
  map(path, captures, instructions) {
    let entry;
    try {
      entry = this.getEntry();
    } catch (err) {
      for (let cap of captures) {
        cap.dispose();
      }
      throw err;
    }
    if (entry.resolution) {
      return entry.resolution.map(path, captures, instructions);
    } else {
      return entry.session.sendMap(entry.importId, path, captures, instructions);
    }
  }
  get(path) {
    let entry = this.getEntry();
    if (entry.resolution) {
      return entry.resolution.get(path);
    } else {
      return entry.session.sendCall(entry.importId, path);
    }
  }
  dup() {
    return new _RpcImportHook(false, this.getEntry());
  }
  pull() {
    let entry = this.getEntry();
    if (!this.isPromise) {
      throw new Error("Can't pull this hook because it's not a promise hook.");
    }
    if (entry.resolution) {
      return entry.resolution.pull();
    }
    return entry.awaitResolution();
  }
  ignoreUnhandledRejections() {
  }
  dispose() {
    let entry = this.entry;
    this.entry = void 0;
    if (entry) {
      if (--entry.localRefcount === 0) {
        entry.dispose();
      }
    }
  }
  onBroken(callback) {
    if (this.entry) {
      this.entry.onBroken(callback);
    }
  }
};
var RpcMainHook = class extends RpcImportHook {
  static {
    __name(this, "RpcMainHook");
  }
  session;
  constructor(entry) {
    super(false, entry);
    this.session = entry.session;
  }
  dispose() {
    if (this.session) {
      let session = this.session;
      this.session = void 0;
      session.shutdown();
    }
  }
};
var RpcSessionImpl = class {
  static {
    __name(this, "RpcSessionImpl");
  }
  constructor(transport, mainHook, options2) {
    this.transport = transport;
    this.options = options2;
    this.exports.push({ hook: mainHook, refcount: 1 });
    this.imports.push(new ImportTableEntry(this, 0, false));
    let rejectFunc;
    let abortPromise = new Promise((resolve2, reject) => {
      rejectFunc = reject;
    });
    this.cancelReadLoop = rejectFunc;
    this.readLoop(abortPromise).catch((err) => this.abort(err));
  }
  exports = [];
  reverseExports = /* @__PURE__ */ new Map();
  imports = [];
  abortReason;
  cancelReadLoop;
  // We assign positive numbers to imports we initiate, and negative numbers to exports we
  // initiate. So the next import ID is just `imports.length`, but the next export ID needs
  // to be tracked explicitly.
  nextExportId = -1;
  // If set, call this when all incoming calls are complete.
  onBatchDone;
  // How many promises is our peer expecting us to resolve?
  pullCount = 0;
  // Sparse array of onBrokenCallback registrations. Items are strictly appended to the end but
  // may be deleted from the middle (hence leaving the array sparse).
  onBrokenCallbacks = [];
  // Should only be called once immediately after construction.
  getMainImport() {
    return new RpcMainHook(this.imports[0]);
  }
  shutdown() {
    this.abort(new Error("RPC session was shut down by disposing the main stub"), false);
  }
  exportStub(hook) {
    if (this.abortReason) throw this.abortReason;
    let existingExportId = this.reverseExports.get(hook);
    if (existingExportId !== void 0) {
      ++this.exports[existingExportId].refcount;
      return existingExportId;
    } else {
      let exportId = this.nextExportId--;
      this.exports[exportId] = { hook, refcount: 1 };
      this.reverseExports.set(hook, exportId);
      return exportId;
    }
  }
  exportPromise(hook) {
    if (this.abortReason) throw this.abortReason;
    let exportId = this.nextExportId--;
    this.exports[exportId] = { hook, refcount: 1 };
    this.reverseExports.set(hook, exportId);
    this.ensureResolvingExport(exportId);
    return exportId;
  }
  unexport(ids) {
    for (let id of ids) {
      this.releaseExport(id, 1);
    }
  }
  releaseExport(exportId, refcount) {
    let entry = this.exports[exportId];
    if (!entry) {
      throw new Error(`no such export ID: ${exportId}`);
    }
    if (entry.refcount < refcount) {
      throw new Error(`refcount would go negative: ${entry.refcount} < ${refcount}`);
    }
    entry.refcount -= refcount;
    if (entry.refcount === 0) {
      delete this.exports[exportId];
      this.reverseExports.delete(entry.hook);
      entry.hook.dispose();
    }
  }
  onSendError(error4) {
    if (this.options.onSendError) {
      return this.options.onSendError(error4);
    }
  }
  ensureResolvingExport(exportId) {
    let exp = this.exports[exportId];
    if (!exp) {
      throw new Error(`no such export ID: ${exportId}`);
    }
    if (!exp.pull) {
      let resolve2 = /* @__PURE__ */ __name(async () => {
        let hook = exp.hook;
        for (; ; ) {
          let payload = await hook.pull();
          if (payload.value instanceof RpcStub2) {
            let { hook: inner, pathIfPromise } = unwrapStubAndPath2(payload.value);
            if (pathIfPromise && pathIfPromise.length == 0) {
              if (this.getImport(hook) === void 0) {
                hook = inner;
                continue;
              }
            }
          }
          return payload;
        }
      }, "resolve");
      ++this.pullCount;
      exp.pull = resolve2().then(
        (payload) => {
          let value = Devaluator2.devaluate(payload.value, void 0, this, payload);
          this.send(["resolve", exportId, value]);
        },
        (error4) => {
          this.send(["reject", exportId, Devaluator2.devaluate(error4, void 0, this)]);
        }
      ).catch(
        (error4) => {
          try {
            this.send(["reject", exportId, Devaluator2.devaluate(error4, void 0, this)]);
          } catch (error22) {
            this.abort(error22);
          }
        }
      ).finally(() => {
        if (--this.pullCount === 0) {
          if (this.onBatchDone) {
            this.onBatchDone.resolve();
          }
        }
      });
    }
  }
  getImport(hook) {
    if (hook instanceof RpcImportHook && hook.entry && hook.entry.session === this) {
      return hook.entry.importId;
    } else {
      return void 0;
    }
  }
  importStub(idx) {
    if (this.abortReason) throw this.abortReason;
    let entry = this.imports[idx];
    if (!entry) {
      entry = new ImportTableEntry(this, idx, false);
      this.imports[idx] = entry;
    }
    return new RpcImportHook(
      /*isPromise=*/
      false,
      entry
    );
  }
  importPromise(idx) {
    if (this.abortReason) throw this.abortReason;
    if (this.imports[idx]) {
      return new ErrorStubHook2(new Error(
        "Bug in RPC system: The peer sent a promise reusing an existing export ID."
      ));
    }
    let entry = new ImportTableEntry(this, idx, true);
    this.imports[idx] = entry;
    return new RpcImportHook(
      /*isPromise=*/
      true,
      entry
    );
  }
  getExport(idx) {
    return this.exports[idx]?.hook;
  }
  send(msg) {
    if (this.abortReason !== void 0) {
      return;
    }
    let msgText;
    try {
      msgText = JSON.stringify(msg);
    } catch (err) {
      try {
        this.abort(err);
      } catch (err2) {
      }
      throw err;
    }
    this.transport.send(msgText).catch((err) => this.abort(err, false));
  }
  sendCall(id, path, args) {
    if (this.abortReason) throw this.abortReason;
    let value = ["pipeline", id, path];
    if (args) {
      let devalue = Devaluator2.devaluate(args.value, void 0, this, args);
      value.push(devalue[0]);
    }
    this.send(["push", value]);
    let entry = new ImportTableEntry(this, this.imports.length, false);
    this.imports.push(entry);
    return new RpcImportHook(
      /*isPromise=*/
      true,
      entry
    );
  }
  sendMap(id, path, captures, instructions) {
    if (this.abortReason) {
      for (let cap of captures) {
        cap.dispose();
      }
      throw this.abortReason;
    }
    let devaluedCaptures = captures.map((hook) => {
      let importId = this.getImport(hook);
      if (importId !== void 0) {
        return ["import", importId];
      } else {
        return ["export", this.exportStub(hook)];
      }
    });
    let value = ["remap", id, path, devaluedCaptures, instructions];
    this.send(["push", value]);
    let entry = new ImportTableEntry(this, this.imports.length, false);
    this.imports.push(entry);
    return new RpcImportHook(
      /*isPromise=*/
      true,
      entry
    );
  }
  sendPull(id) {
    if (this.abortReason) throw this.abortReason;
    this.send(["pull", id]);
  }
  sendRelease(id, remoteRefcount) {
    if (this.abortReason) return;
    this.send(["release", id, remoteRefcount]);
    delete this.imports[id];
  }
  abort(error4, trySendAbortMessage = true) {
    if (this.abortReason !== void 0) return;
    this.cancelReadLoop(error4);
    if (trySendAbortMessage) {
      try {
        this.transport.send(JSON.stringify(["abort", Devaluator2.devaluate(error4, void 0, this)])).catch((err) => {
        });
      } catch (err) {
      }
    }
    if (error4 === void 0) {
      error4 = "undefined";
    }
    this.abortReason = error4;
    if (this.onBatchDone) {
      this.onBatchDone.reject(error4);
    }
    if (this.transport.abort) {
      try {
        this.transport.abort(error4);
      } catch (err) {
        Promise.resolve(err);
      }
    }
    for (let i in this.onBrokenCallbacks) {
      try {
        this.onBrokenCallbacks[i](error4);
      } catch (err) {
        Promise.resolve(err);
      }
    }
    for (let i in this.imports) {
      this.imports[i].abort(error4);
    }
    for (let i in this.exports) {
      this.exports[i].hook.dispose();
    }
  }
  async readLoop(abortPromise) {
    while (!this.abortReason) {
      let msg = JSON.parse(await Promise.race([this.transport.receive(), abortPromise]));
      if (this.abortReason) break;
      if (msg instanceof Array) {
        switch (msg[0]) {
          case "push":
            if (msg.length > 1) {
              let payload = new Evaluator2(this).evaluate(msg[1]);
              let hook = new PayloadStubHook2(payload);
              hook.ignoreUnhandledRejections();
              this.exports.push({ hook, refcount: 1 });
              continue;
            }
            break;
          case "pull": {
            let exportId = msg[1];
            if (typeof exportId == "number") {
              this.ensureResolvingExport(exportId);
              continue;
            }
            break;
          }
          case "resolve":
          // ["resolve", ExportId, Expression]
          case "reject": {
            let importId = msg[1];
            if (typeof importId == "number" && msg.length > 2) {
              let imp = this.imports[importId];
              if (imp) {
                if (msg[0] == "resolve") {
                  imp.resolve(new PayloadStubHook2(new Evaluator2(this).evaluate(msg[2])));
                } else {
                  let payload = new Evaluator2(this).evaluate(msg[2]);
                  payload.dispose();
                  imp.resolve(new ErrorStubHook2(payload.value));
                }
              } else {
                if (msg[0] == "resolve") {
                  new Evaluator2(this).evaluate(msg[2]).dispose();
                }
              }
              continue;
            }
            break;
          }
          case "release": {
            let exportId = msg[1];
            let refcount = msg[2];
            if (typeof exportId == "number" && typeof refcount == "number") {
              this.releaseExport(exportId, refcount);
              continue;
            }
            break;
          }
          case "abort": {
            let payload = new Evaluator2(this).evaluate(msg[1]);
            payload.dispose();
            this.abort(payload, false);
            break;
          }
        }
      }
      throw new Error(`bad RPC message: ${JSON.stringify(msg)}`);
    }
  }
  async drain() {
    if (this.abortReason) {
      throw this.abortReason;
    }
    if (this.pullCount > 0) {
      let { promise, resolve: resolve2, reject } = Promise.withResolvers();
      this.onBatchDone = { resolve: resolve2, reject };
      await promise;
    }
  }
  getStats() {
    let result = { imports: 0, exports: 0 };
    for (let i in this.imports) {
      ++result.imports;
    }
    for (let i in this.exports) {
      ++result.exports;
    }
    return result;
  }
};
var RpcSession = class {
  static {
    __name(this, "RpcSession");
  }
  #session;
  #mainStub;
  constructor(transport, localMain, options2 = {}) {
    let mainHook;
    if (localMain) {
      mainHook = new PayloadStubHook2(RpcPayload2.fromAppReturn(localMain));
    } else {
      mainHook = new ErrorStubHook2(new Error("This connection has no main object."));
    }
    this.#session = new RpcSessionImpl(transport, mainHook, options2);
    this.#mainStub = new RpcStub2(this.#session.getMainImport());
  }
  getRemoteMain() {
    return this.#mainStub;
  }
  getStats() {
    return this.#session.getStats();
  }
  drain() {
    return this.#session.drain();
  }
};
function newWebSocketRpcSession(webSocket, localMain, options2) {
  if (typeof webSocket === "string") {
    webSocket = new WebSocket(webSocket);
  }
  let transport = new WebSocketTransport(webSocket);
  let rpc = new RpcSession(transport, localMain, options2);
  return rpc.getRemoteMain();
}
__name(newWebSocketRpcSession, "newWebSocketRpcSession");
var WebSocketTransport = class {
  static {
    __name(this, "WebSocketTransport");
  }
  constructor(webSocket) {
    this.#webSocket = webSocket;
    if (webSocket.readyState === WebSocket.CONNECTING) {
      this.#sendQueue = [];
      webSocket.addEventListener("open", (event) => {
        try {
          for (let message of this.#sendQueue) {
            webSocket.send(message);
          }
        } catch (err) {
          this.#receivedError(err);
        }
        this.#sendQueue = void 0;
      });
    }
    webSocket.addEventListener("message", (event) => {
      if (this.#error) ;
      else if (typeof event.data === "string") {
        if (this.#receiveResolver) {
          this.#receiveResolver(event.data);
          this.#receiveResolver = void 0;
          this.#receiveRejecter = void 0;
        } else {
          this.#receiveQueue.push(event.data);
        }
      } else {
        this.#receivedError(new TypeError("Received non-string message from WebSocket."));
      }
    });
    webSocket.addEventListener("close", (event) => {
      this.#receivedError(new Error(`Peer closed WebSocket: ${event.code} ${event.reason}`));
    });
    webSocket.addEventListener("error", (event) => {
      this.#receivedError(new Error(`WebSocket connection failed.`));
    });
  }
  #webSocket;
  #sendQueue;
  // only if not opened yet
  #receiveResolver;
  #receiveRejecter;
  #receiveQueue = [];
  #error;
  async send(message) {
    if (this.#sendQueue === void 0) {
      this.#webSocket.send(message);
    } else {
      this.#sendQueue.push(message);
    }
  }
  async receive() {
    if (this.#receiveQueue.length > 0) {
      return this.#receiveQueue.shift();
    } else if (this.#error) {
      throw this.#error;
    } else {
      return new Promise((resolve2, reject) => {
        this.#receiveResolver = resolve2;
        this.#receiveRejecter = reject;
      });
    }
  }
  abort(reason) {
    let message;
    if (reason instanceof Error) {
      message = reason.message;
    } else {
      message = `${reason}`;
    }
    this.#webSocket.close(3e3, message);
    if (!this.#error) {
      this.#error = reason;
    }
  }
  #receivedError(reason) {
    if (!this.#error) {
      this.#error = reason;
      if (this.#receiveRejecter) {
        this.#receiveRejecter(reason);
        this.#receiveResolver = void 0;
        this.#receiveRejecter = void 0;
      }
    }
  }
};
var currentMapBuilder2;
var MapBuilder2 = class {
  static {
    __name(this, "MapBuilder");
  }
  context;
  captureMap = /* @__PURE__ */ new Map();
  instructions = [];
  constructor(subject, path) {
    if (currentMapBuilder2) {
      this.context = {
        parent: currentMapBuilder2,
        captures: [],
        subject: currentMapBuilder2.capture(subject),
        path
      };
    } else {
      this.context = {
        parent: void 0,
        captures: [],
        subject,
        path
      };
    }
    currentMapBuilder2 = this;
  }
  unregister() {
    currentMapBuilder2 = this.context.parent;
  }
  makeInput() {
    return new MapVariableHook2(this, 0);
  }
  makeOutput(result) {
    let devalued;
    try {
      devalued = Devaluator2.devaluate(result.value, void 0, this, result);
    } finally {
      result.dispose();
    }
    this.instructions.push(devalued);
    if (this.context.parent) {
      this.context.parent.instructions.push(
        [
          "remap",
          this.context.subject,
          this.context.path,
          this.context.captures.map((cap) => ["import", cap]),
          this.instructions
        ]
      );
      return new MapVariableHook2(this.context.parent, this.context.parent.instructions.length);
    } else {
      return this.context.subject.map(this.context.path, this.context.captures, this.instructions);
    }
  }
  pushCall(hook, path, params) {
    let devalued = Devaluator2.devaluate(params.value, void 0, this, params);
    devalued = devalued[0];
    let subject = this.capture(hook.dup());
    this.instructions.push(["pipeline", subject, path, devalued]);
    return new MapVariableHook2(this, this.instructions.length);
  }
  pushGet(hook, path) {
    let subject = this.capture(hook.dup());
    this.instructions.push(["pipeline", subject, path]);
    return new MapVariableHook2(this, this.instructions.length);
  }
  capture(hook) {
    if (hook instanceof MapVariableHook2 && hook.mapper === this) {
      return hook.idx;
    }
    let result = this.captureMap.get(hook);
    if (result === void 0) {
      if (this.context.parent) {
        let parentIdx = this.context.parent.capture(hook);
        this.context.captures.push(parentIdx);
      } else {
        this.context.captures.push(hook);
      }
      result = -this.context.captures.length;
      this.captureMap.set(hook, result);
    }
    return result;
  }
  // ---------------------------------------------------------------------------
  // implements Exporter
  exportStub(hook) {
    throw new Error(
      "Can't construct an RpcTarget or RPC callback inside a mapper function. Try creating a new RpcStub outside the callback first, then using it inside the callback."
    );
  }
  exportPromise(hook) {
    return this.exportStub(hook);
  }
  getImport(hook) {
    return this.capture(hook);
  }
  unexport(ids) {
  }
  onSendError(error4) {
  }
};
mapImpl2.sendMap = (hook, path, func) => {
  let builder = new MapBuilder2(hook, path);
  let result;
  try {
    result = RpcPayload2.fromAppReturn(withCallInterceptor2(builder.pushCall.bind(builder), () => {
      return func(new RpcPromise2(builder.makeInput(), []));
    }));
  } finally {
    builder.unregister();
  }
  if (result instanceof Promise) {
    result.catch((err) => {
    });
    throw new Error("RPC map() callbacks cannot be async.");
  }
  return new RpcPromise2(builder.makeOutput(result), []);
};
function throwMapperBuilderUseError2() {
  throw new Error(
    "Attempted to use an abstract placeholder from a mapper function. Please make sure your map function has no side effects."
  );
}
__name(throwMapperBuilderUseError2, "throwMapperBuilderUseError");
var MapVariableHook2 = class extends StubHook2 {
  static {
    __name(this, "MapVariableHook");
  }
  constructor(mapper, idx) {
    super();
    this.mapper = mapper;
    this.idx = idx;
  }
  // We don't have anything we actually need to dispose, so dup() can just return the same hook.
  dup() {
    return this;
  }
  dispose() {
  }
  get(path) {
    if (path.length == 0) {
      return this;
    } else if (currentMapBuilder2) {
      return currentMapBuilder2.pushGet(this, path);
    } else {
      throwMapperBuilderUseError2();
    }
  }
  // Other methods should never be called.
  call(path, args) {
    throwMapperBuilderUseError2();
  }
  map(path, captures, instructions) {
    throwMapperBuilderUseError2();
  }
  pull() {
    throwMapperBuilderUseError2();
  }
  ignoreUnhandledRejections() {
  }
  onBroken(callback) {
    throwMapperBuilderUseError2();
  }
};
var MapApplicator2 = class {
  static {
    __name(this, "MapApplicator");
  }
  constructor(captures, input) {
    this.captures = captures;
    this.variables = [input];
  }
  variables;
  dispose() {
    for (let variable of this.variables) {
      variable.dispose();
    }
  }
  apply(instructions) {
    try {
      if (instructions.length < 1) {
        throw new Error("Invalid empty mapper function.");
      }
      for (let instruction of instructions.slice(0, -1)) {
        let payload = new Evaluator2(this).evaluateCopy(instruction);
        if (payload.value instanceof RpcStub2) {
          let hook = unwrapStubNoProperties2(payload.value);
          if (hook) {
            this.variables.push(hook);
            continue;
          }
        }
        this.variables.push(new PayloadStubHook2(payload));
      }
      return new Evaluator2(this).evaluateCopy(instructions[instructions.length - 1]);
    } finally {
      for (let variable of this.variables) {
        variable.dispose();
      }
    }
  }
  importStub(idx) {
    throw new Error("A mapper function cannot refer to exports.");
  }
  importPromise(idx) {
    return this.importStub(idx);
  }
  getExport(idx) {
    if (idx < 0) {
      return this.captures[-idx - 1];
    } else {
      return this.variables[idx];
    }
  }
};
function applyMapToElement2(input, parent, owner, captures, instructions) {
  let inputHook = new PayloadStubHook2(RpcPayload2.deepCopyFrom(input, parent, owner));
  let mapper = new MapApplicator2(captures, inputHook);
  try {
    return mapper.apply(instructions);
  } finally {
    mapper.dispose();
  }
}
__name(applyMapToElement2, "applyMapToElement");
mapImpl2.applyMap = (input, parent, owner, captures, instructions) => {
  try {
    let result;
    if (input instanceof RpcPromise2) {
      throw new Error("applyMap() can't be called on RpcPromise");
    } else if (input instanceof Array) {
      let payloads = [];
      try {
        for (let elem of input) {
          payloads.push(applyMapToElement2(elem, input, owner, captures, instructions));
        }
      } catch (err) {
        for (let payload of payloads) {
          payload.dispose();
        }
        throw err;
      }
      result = RpcPayload2.fromArray(payloads);
    } else if (input === null || input === void 0) {
      result = RpcPayload2.fromAppReturn(input);
    } else {
      result = applyMapToElement2(input, parent, owner, captures, instructions);
    }
    return new PayloadStubHook2(result);
  } finally {
    for (let cap of captures) {
      cap.dispose();
    }
  }
};
var RpcTarget4 = RpcTarget2;
var newWebSocketRpcSession2 = newWebSocketRpcSession;

// ../beelay-worker/worker.ts
checkWebAssemblySupport();
console.log("WebAssembly module imported, will initialize lazily on first use");
var wasmInitialized = false;
var wasmInitPromise = null;
function checkWebAssemblySupport() {
  const isCFWorker = typeof navigator === "object" && true;
  const hasImportMetaUrl = typeof import.meta !== "undefined" && typeof import.meta.url === "string";
  if (isCFWorker && !hasImportMetaUrl) {
    console.log("\u26A0\uFE0F  Cloudflare Worker environment detected without import.meta.url support");
    console.log("WebAssembly will be disabled - this is expected behavior");
  }
  return { isCFWorker, hasImportMetaUrl };
}
__name(checkWebAssemblySupport, "checkWebAssemblySupport");
async function ensureWasmInitialized() {
  if (wasmInitialized) return;
  if (!wasmInitPromise) {
    wasmInitPromise = (async () => {
      console.log("=== WebAssembly Initialization ===");
      try {
        const isCFWorker = typeof navigator === "object" && true;
        console.log("Environment:", isCFWorker ? "Cloudflare Worker" : "Other");
        if (isCFWorker) {
          console.log("Using bundled WASM module for Cloudflare Workers");
          initSync(wasmModule);
          console.log("\u2705 WebAssembly initialized successfully with bundled module");
        } else {
          console.log("Using standard WebAssembly initialization");
          const hasImportMetaUrl = typeof import.meta !== "undefined" && typeof import.meta.url === "string";
          if (hasImportMetaUrl) {
            await subduction_wasm_default();
            console.log("\u2705 WebAssembly initialized successfully with import.meta.url");
          } else {
            console.log("Falling back to bundled WASM module");
            initSync(wasmModule);
            console.log("\u2705 WebAssembly initialized successfully with fallback bundled module");
          }
        }
        wasmInitialized = true;
        console.log("\u2705 WebAssembly initialization complete");
      } catch (error4) {
        console.error("\u274C WebAssembly initialization failed:", error4);
        console.error("This means WebAssembly features will not be available");
        globalThis.__WASM_DISABLED__ = true;
        wasmInitialized = true;
        console.log("Application will continue without WebAssembly features");
      }
    })();
  }
  await wasmInitPromise;
}
__name(ensureWasmInitialized, "ensureWasmInitialized");
var KEY_DELIM = "|";
function encodeStorageKey(key2) {
  if (key2.length === 0) {
    return "";
  }
  return key2.map((part) => `${part.length}:${part}`).join(KEY_DELIM);
}
__name(encodeStorageKey, "encodeStorageKey");
function encodeStoragePrefix(prefix) {
  if (prefix.length === 0) {
    return void 0;
  }
  const encoded = encodeStorageKey(prefix);
  return encoded.length ? `${encoded}${KEY_DELIM}` : void 0;
}
__name(encodeStoragePrefix, "encodeStoragePrefix");
function decodeStorageKey(encoded) {
  if (!encoded) {
    return [];
  }
  const parts = [];
  let index4 = 0;
  while (index4 < encoded.length) {
    const colonIndex = encoded.indexOf(":", index4);
    if (colonIndex === -1) {
      throw new Error(`Invalid encoded storage key: ${encoded}`);
    }
    const lengthPart = encoded.slice(index4, colonIndex);
    const length = Number(lengthPart);
    if (!Number.isFinite(length)) {
      throw new Error(`Invalid segment length in storage key: ${lengthPart}`);
    }
    const start = colonIndex + 1;
    const end = start + length;
    const segment = encoded.slice(start, end);
    parts.push(segment);
    index4 = end;
    if (index4 === encoded.length) {
      break;
    }
    if (encoded[index4] !== KEY_DELIM) {
      throw new Error(`Invalid storage key separator in: ${encoded}`);
    }
    index4 += 1;
  }
  return parts;
}
__name(decodeStorageKey, "decodeStorageKey");
function toUint8Array(value) {
  if (value instanceof Uint8Array) {
    return value;
  }
  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }
  if (ArrayBuffer.isView(value)) {
    const view = value;
    return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));
  }
  throw new Error("Unexpected stored value type; expected binary data");
}
__name(toUint8Array, "toUint8Array");
async function listEntries(storage, prefix) {
  if (prefix === void 0) {
    return await storage.list();
  }
  return await storage.list({ prefix });
}
__name(listEntries, "listEntries");
function encodeBase64(bytes) {
  let binary = "";
  const chunkSize = 32768;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}
__name(encodeBase64, "encodeBase64");
var DurableObjectStorageAdapter = class {
  constructor(storage) {
    this.storage = storage;
  }
  static {
    __name(this, "DurableObjectStorageAdapter");
  }
  async load(key2) {
    const stored = await this.storage.get(encodeStorageKey(key2));
    return stored === void 0 ? void 0 : toUint8Array(stored);
  }
  async loadRange(prefix) {
    const result = /* @__PURE__ */ new Map();
    const exactKey = encodeStorageKey(prefix);
    const exact = await this.storage.get(exactKey);
    if (exact !== void 0) {
      result.set(prefix, toUint8Array(exact));
    }
    const prefixString = encodeStoragePrefix(prefix);
    const entries = await listEntries(this.storage, prefixString);
    for (const [rawKey, rawValue] of entries) {
      const decodedKey = decodeStorageKey(rawKey);
      result.set(decodedKey, toUint8Array(rawValue));
    }
    return result;
  }
  async save(key2, data) {
    await this.storage.put(encodeStorageKey(key2), data);
  }
  async remove(key2) {
    await this.storage.delete(encodeStorageKey(key2));
  }
  async listOneLevel(prefix) {
    const results = [];
    const seen = /* @__PURE__ */ new Set();
    const prefixString = encodeStoragePrefix(prefix);
    const entries = await listEntries(this.storage, prefixString);
    for (const [rawKey] of entries) {
      const decoded = decodeStorageKey(rawKey);
      if (decoded.length <= prefix.length) {
        continue;
      }
      const child = decoded.slice(0, prefix.length + 1);
      const encodedChild = encodeStorageKey(child);
      if (!seen.has(encodedChild)) {
        seen.add(encodedChild);
        results.push(child);
      }
    }
    return results;
  }
};
function toBase64(data) {
  if (data.length === 0) return "";
  let binary = "";
  const chunkSize = 32768;
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}
__name(toBase64, "toBase64");
var BeelayHandler = class extends RpcTarget4 {
  constructor(factory) {
    super();
    this.factory = factory;
    this.clientTargets = /* @__PURE__ */ new Set();
  }
  static {
    __name(this, "BeelayHandler");
  }
  async getBeelay() {
    if (this.beelay) {
      return this.beelay;
    }
    if (!this.beelayPromise) {
      this.beelayPromise = (async () => {
        await ensureWasmInitialized();
        if (globalThis.__WASM_DISABLED__) {
          console.log("WebAssembly disabled - cannot create Beelay instance");
          throw new Error("WebAssembly not available in this environment - Beelay requires WebAssembly");
        }
        const { storage, signer } = this.factory ? await this.factory() : { storage: new MemoryStorageAdapter(), signer: new MemorySigner() };
        const instance = await Beelay.load({ storage, signer });
        this.beelay = instance;
        return instance;
      })();
    }
    return this.beelayPromise;
  }
  serializeCommit(commit) {
    let contents;
    const value = commit.contents;
    if (value instanceof Uint8Array) {
      contents = value;
    } else if (value instanceof ArrayBuffer) {
      contents = new Uint8Array(value);
    } else if (ArrayBuffer.isView(value)) {
      contents = new Uint8Array(value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength));
    } else if (typeof value === "string") {
      const decoded = Uint8Array.from(atob(value), (c2) => c2.charCodeAt(0));
      contents = decoded;
    } else if (Array.isArray(value)) {
      contents = new Uint8Array(value);
    } else {
      throw new Error("Unsupported commit contents type for serialization");
    }
    return {
      parents: commit.parents,
      hash: commit.hash,
      contents: toBase64(contents)
    };
  }
  async broadcast(event, docId) {
    console.log("\u{1F4E3} broadcast", {
      type: event?.type,
      docId,
      totalTargets: this.clientTargets.size,
      filteredTargets: [...this.clientTargets].filter((registration) => !docId || !registration.docId || registration.docId === docId).length
    });
    if (this.clientTargets.size === 0 && !this.sendToAll) {
      console.log("\u2139\uFE0F broadcast: no registered targets");
    }
    if (this.sendToAll) {
      this.sendToAll(event);
    }
    for (const registration of [...this.clientTargets]) {
      if (docId && registration.docId && registration.docId !== docId) {
        continue;
      }
      try {
        const result = registration.target.handleServerEvent(event);
        if (result && typeof result.then === "function") {
          await result;
        }
      } catch (error4) {
        console.error("Error delivering event to client target:", error4);
        if (typeof registration.target?.[Symbol.dispose] === "function") {
          try {
            registration.target[Symbol.dispose]();
          } catch (disposeError) {
            console.warn("broadcast dispose failed", disposeError);
          }
        }
        this.clientTargets.delete(registration);
        console.log("\u{1F9F9} removed client target after delivery failure", {
          remaining: this.clientTargets.size,
          docId: registration.docId
        });
      }
    }
  }
  async registerClientTarget(target, docId) {
    let retainedTarget = target;
    try {
      if (typeof target?.dup === "function") {
        retainedTarget = target.dup();
      } else {
        const rawSymbol = Object.getOwnPropertySymbols(target).find((symbol) => symbol.description === "realStub");
        if (rawSymbol) {
          const rawStub = target[rawSymbol];
          if (typeof rawStub?.dup === "function") {
            retainedTarget = rawStub.dup();
          }
        }
      }
    } catch (error4) {
      console.warn("registerClientTarget: failed to duplicate stub", error4);
    }
    const registration = { target: retainedTarget, originalTarget: target, docId };
    this.clientTargets.add(registration);
    console.log("\u2705 registered client target", {
      total: this.clientTargets.size,
      docId
    });
    if (retainedTarget && typeof retainedTarget.onRpcBroken === "function") {
      retainedTarget.onRpcBroken(() => {
        if (typeof registration.target?.[Symbol.dispose] === "function") {
          try {
            registration.target[Symbol.dispose]();
          } catch (disposeError) {
            console.warn("onRpcBroken dispose failed", disposeError);
          }
        }
        this.clientTargets.delete(registration);
      });
    }
    return { success: true };
  }
  async unregisterClientTarget(target, docId) {
    for (const registration of this.clientTargets) {
      if (registration.originalTarget === target && (!docId || registration.docId === docId)) {
        if (typeof registration.target?.[Symbol.dispose] === "function") {
          try {
            registration.target[Symbol.dispose]();
          } catch (disposeError) {
            console.warn("unregisterClientTarget dispose failed", disposeError);
          }
        }
        this.clientTargets.delete(registration);
        console.log("\u{1F9F9} unregistered client target", { total: this.clientTargets.size, docId });
        break;
      }
    }
    return { success: true };
  }
  async createDoc(options2) {
    const contents = new Uint8Array(options2.initialCommit.contents);
    const hashBuffer = await crypto.subtle.digest("SHA-256", contents);
    const hash2 = Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    options2.initialCommit.contents = contents;
    options2.initialCommit.hash = hash2;
    const beelay = await this.getBeelay();
    const doc = await beelay.createDoc(options2);
    await this.broadcast({ type: "docCreated", id: String(doc) }, String(doc));
    return { id: String(doc) };
  }
  async loadDocument(docId) {
    const beelay = await this.getBeelay();
    const commits = await beelay.loadDocument(docId);
    if (!commits) return [];
    return commits.map((commit) => {
      if (commit.type === "commit" && Array.isArray(commit.parents) && typeof commit.hash === "string" && commit.contents instanceof Uint8Array) {
        return {
          parents: commit.parents,
          hash: commit.hash,
          contents: encodeBase64(commit.contents)
        };
      }
      return commit;
    });
  }
  async addCommits(options2) {
    const beelay = await this.getBeelay();
    await beelay.addCommits(options2);
    await this.broadcast(
      {
        type: "commitsAdded",
        docId: options2.docId,
        commits: options2.commits.map((commit) => this.serializeCommit(commit))
      },
      options2.docId
    );
    return { success: true };
  }
  async addWorkerCommit(docId, content) {
    const beelay = await this.getBeelay();
    const currentCommits = await beelay.loadDocument(docId);
    if (!currentCommits || currentCommits.length === 0) {
      throw new Error("Document not found or empty");
    }
    const latestCommit = currentCommits[currentCommits.length - 1];
    if (latestCommit.type !== "commit") {
      throw new Error("Latest item is not a commit");
    }
    const contents = new TextEncoder().encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", contents);
    const hash2 = Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
    const newCommit = {
      parents: [latestCommit.hash],
      hash: hash2,
      contents
    };
    await beelay.addCommits({ docId, commits: [newCommit] });
    await this.broadcast(
      {
        type: "commitAdded",
        docId,
        commit: this.serializeCommit(newCommit)
      },
      docId
    );
    return { success: true, commitHash: hash2 };
  }
  async createContactCard() {
    const beelay = await this.getBeelay();
    const card = await beelay.createContactCard();
    return { card: String(card) };
  }
  async createStream(options2) {
    return { streamId: "placeholder" };
  }
  async waitUntilSynced(peerId) {
    const beelay = await this.getBeelay();
    await beelay.waitUntilSynced(peerId);
    return { synced: true };
  }
  async stop() {
    if (this.beelay) {
      await this.beelay.stop();
      this.beelay = void 0;
      this.beelayPromise = void 0;
    }
  }
  async hello(name) {
    return `Hello, ${name}!`;
  }
  async [Symbol.asyncDispose]() {
    await this.stop();
  }
};
var BeelayDO = class {
  constructor(state2, env2) {
    this.state = state2;
    this.env = env2;
    this.handler = new BeelayHandler(async () => {
      await ensureWasmInitialized();
      if (globalThis.__WASM_DISABLED__) {
        console.log("WebAssembly disabled in Durable Object - cannot create signer");
        throw new Error("WebAssembly not available - cannot create MemorySigner");
      }
      return {
        storage: new DurableObjectStorageAdapter(this.state.storage),
        signer: new MemorySigner()
      };
    });
    this.handler.sendToAll = void 0;
  }
  static {
    __name(this, "BeelayDO");
  }
  async fetch(request) {
    if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") {
      const webSocketPair = new WebSocketPair();
      const client = webSocketPair[0];
      const server2 = webSocketPair[1];
      server2.accept();
      newWebSocketRpcSession2(server2, this.handler);
      return new Response(null, {
        status: 101,
        webSocket: client
      });
    }
    return new Response("WebSocket required", { status: 400 });
  }
};
var worker_default2 = {
  async fetch(request, env2) {
    if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") {
      const id = env2.BEELAY_DO.idFromName("global");
      const stub = env2.BEELAY_DO.get(id);
      return stub.fetch(request);
    }
    return new Response("WebSocket required", { status: 400 });
  }
};

// src/worker.ts
var BeelayDO2 = class extends BeelayDO {
  static {
    __name(this, "BeelayDO");
  }
  constructor(state2, env2) {
    super(state2, env2);
  }
};
var UPGRADE_HEADER = "websocket";
var applySecurityHeaders2 = /* @__PURE__ */ __name((response) => {
  const headers2 = new Headers(response.headers);
  for (const [key2, value] of SECURITY_HEADER_ENTRIES2) {
    headers2.set(key2, value);
  }
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: headers2
  });
}, "applySecurityHeaders");
var worker_default3 = {
  async fetch(request, env2, ctx) {
    const upgradeHeader = request.headers.get("Upgrade")?.toLowerCase();
    if (upgradeHeader === UPGRADE_HEADER) {
      return worker_default2.fetch(request, env2);
    }
    if (env2.ASSETS && typeof env2.ASSETS === "object" && env2.ASSETS !== null && "fetch" in env2.ASSETS) {
      const originalAssets = env2.ASSETS;
      env2.ASSETS = {
        async fetch(req) {
          const assetResponse = await originalAssets.fetch(req);
          return applySecurityHeaders2(assetResponse);
        }
      };
    }
    const response = await worker_default.fetch(request, env2, ctx);
    return applySecurityHeaders2(response);
  }
};
export {
  BeelayDO2 as BeelayDO,
  worker_default3 as default
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
//# sourceMappingURL=worker.js.map
